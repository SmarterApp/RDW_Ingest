package org.opentestsystem.rdw.ingest.service;

import org.apache.commons.codec.digest.DigestUtils;
import org.beanio.BeanReader;
import org.beanio.StreamFactory;
import org.opentestsystem.rdw.ingest.auth.RdwUser;
import org.opentestsystem.rdw.ingest.model.ImportContent;
import org.opentestsystem.rdw.ingest.model.ImportStatus;
import org.opentestsystem.rdw.ingest.model.RdwImport;
import org.opentestsystem.rdw.ingest.repository.RdwImportRepository;
import org.opentestsystem.rdw.model.TDSReport;
import org.opentestsystem.rdw.model.XmlUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.List;
import java.util.Optional;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Default implementation of ExamService
 */
@Service
class DefaultExamService implements ExamService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultExamService.class);


    private RdwImportRepository repository;
    private final ExamSource source;

    @Autowired
    DefaultExamService(@NotNull RdwImportRepository repository, @NotNull final ExamSource source) {
        this.repository = checkNotNull(repository);
        this.source = checkNotNull(source);
    }

    @Override
    public RdwImport importExam(final RdwUser user, final String payload, final String contentType, final String batch) {
        final String digest = DigestUtils.md5Hex(payload).toUpperCase();

        RdwImport rdwImport = repository.findOneByDigest(digest);
        if (rdwImport != null) {
            logger.info("Ignoring exam payload with existing digest {}", digest);
            return rdwImport;
        }

        // TODO - save payload

        rdwImport = repository.create(RdwImport.builder()
                .content(ImportContent.EXAM)
                .contentType(contentType)
                .digest(digest)
                .status(ImportStatus.ACCEPTED)
                .creator(user.getUsername())
                .batch(batch)
                .build());

        // TODO - do something about this hole?
        // TODO   i.e. what to do with import record if submitExam fails?

        source.submitExam(user, payload, contentType, rdwImport.getId());

        return rdwImport;
    }

    @Override
    public List<RdwImport> importExamCsv(final RdwUser user, final InputStream is) {
        final String contentType = "text/csv";

        // this probably isn't great for really large files, but we need the digest (?)
        final InputStream markable = is.markSupported() ? is : new BufferedInputStream(is);

        String digest = null;
        try {
            markable.mark(Integer.MAX_VALUE);
            digest = DigestUtils.md5Hex(markable).toUpperCase();
            markable.reset();
        } catch (final IOException e) {
            logger.warn("error calculating digest for exam csv", e);
        }
        final String batch = digest;

        final List<RdwImport> imports = repository.findByBatch(batch);
        if (!imports.isEmpty()) {
            logger.info("Ignoring exam csv payload with existing records {}", batch);
            return imports;
        }

        try {
            final StreamFactory factory = StreamFactory.newInstance();
            factory.loadResource("mapping.xml");
            final BeanReader reader = factory.createReader("exam", new InputStreamReader(markable, "UTF-8"));
            reader.setErrorHandler(ex -> {
                logger.warn(ex.toString());
                for (int i=0, cnt=ex.getRecordCount(); i<cnt; i++) {
                    final String text = ex.getRecordContext(i).getRecordText();
                    imports.add(importInvalid(user, text, contentType, batch, ex.toString()));
                }
            });

            // skip the header row and read records
            reader.skip(1);
            int count = 0;
            for (TDSReport report = (TDSReport) reader.read(); report != null; report = (TDSReport) reader.read()) {
                imports.add(importExam(user, XmlUtils.tdsReportToXml(report), MediaType.APPLICATION_XML_VALUE, batch));
                ++count;
            }
            logger.info("extracted {} exams from exam csv", count);

        } catch (final UnsupportedEncodingException ignored) {
            // this will never happen in a modern JVM
        } catch (final Exception e) {
            logger.warn("error reading exam CSV", e);
            throw new RuntimeException(e);
        }

        return imports;
    }

    private RdwImport importInvalid(final RdwUser user, final String payload, final String contentType, final String batch, final String message) {
        final String digest = DigestUtils.md5Hex(payload).toUpperCase();

        final RdwImport rdwImport = repository.findOneByDigest(digest);
        if (rdwImport != null) {
            logger.info("Ignoring exam payload with existing digest {}", digest);
            return rdwImport;
        }

        return repository.create(RdwImport.builder()
                .content(ImportContent.EXAM)
                .contentType(contentType)
                .digest(digest)
                .status(ImportStatus.INVALID)
                .creator(user.getUsername())
                .batch(batch)
                .message(message)
                .build());
    }

    @Override
    public Optional<RdwImport> getImport(final long id) {
        return Optional.ofNullable(repository.findOne(id));
    }

    @Override
    public List<RdwImport> getImports(final String batch, final ImportStatus status) {
        if (batch != null && status != null) {
            throw new UnsupportedOperationException("must specify exactly one search criterium (for now)");
        } else if (batch != null) {
            return repository.findByBatch(batch);
        } else if (status != null) {
            return repository.findByStatus(status);
        } else {
            throw new IllegalArgumentException("must specify at least one search criterium");
        }
    }
}
