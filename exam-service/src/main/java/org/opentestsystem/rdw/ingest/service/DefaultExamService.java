package org.opentestsystem.rdw.ingest.service;

import org.apache.commons.codec.digest.DigestUtils;
import org.beanio.BeanReader;
import org.beanio.StreamFactory;
import org.opentestsystem.rdw.ingest.auth.RdwUser;
import org.opentestsystem.rdw.ingest.model.ImportContent;
import org.opentestsystem.rdw.ingest.model.ImportStatus;
import org.opentestsystem.rdw.ingest.model.RdwImport;
import org.opentestsystem.rdw.ingest.repository.RdwImportRepository;
import org.opentestsystem.rdw.model.TDSReport;
import org.opentestsystem.rdw.model.XmlUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;

import javax.validation.constraints.NotNull;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.Optional;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Default implementation of ExamService
 */
@Service
class DefaultExamService implements ExamService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultExamService.class);


    private RdwImportRepository repository;
    private final ExamSource source;

    @Autowired
    DefaultExamService(@NotNull RdwImportRepository repository, @NotNull final ExamSource source) {
        this.repository = checkNotNull(repository);
        this.source = checkNotNull(source);
    }

    @Override
    public RdwImport importExam(final RdwUser user, final String payload, final String contentType, final String batch) {
        final String digest = DigestUtils.md5Hex(payload).toUpperCase();

        final RdwImport rdwImport = repository.findOneByDigest(digest);
        if (rdwImport != null) {
            logger.info("Ignoring exam payload with existing digest {}", digest);
            return rdwImport;
        }

        // TODO - pass along digest? import id?
        source.submitExam(user, payload, contentType);

        return repository.create(RdwImport.builder()
                .content(ImportContent.EXAM)
                .contentType(contentType)
                .digest(digest)
                .status(ImportStatus.ACCEPTED)
                .creator(user.getUsername())
                .batch(batch)
                .build());
    }

    @Override
    public RdwImport importExamCsv(final RdwUser user, final InputStream is) {
        final String contentType = "text/csv";

        // this probably isn't great for really large files, but we need the digest (?)
        final InputStream markable = is.markSupported() ? is : new BufferedInputStream(is);

        String digest = null;
        try {
            markable.mark(Integer.MAX_VALUE);
            digest = DigestUtils.md5Hex(markable).toUpperCase();
            markable.reset();
        } catch (final IOException e) {
            logger.warn("error calculating digest for exam csv", e);
        }

        final RdwImport rdwImport = repository.findOneByDigest(digest);
        if (rdwImport != null) {
            logger.info("Ignoring exam csv payload with existing digest {}", digest);
            return rdwImport;
        }

        // TODO - should we create separate imports for each row? using digest as batch?
        try {
            final StreamFactory factory = StreamFactory.newInstance();
            factory.loadResource("mapping.xml");
            final BeanReader reader = factory.createReader("exam", new InputStreamReader(markable, "UTF-8"));
            reader.setErrorHandler(ex -> {
                logger.warn(ex.toString());
                for (int i=0, cnt=ex.getRecordCount(); i<cnt; i++) {
                    // TODO - do something to preserve record text, ex.getRecordContext(i).getRecordText()
                }
            });

            // skip the header row and read records
            reader.skip(1);
            int count = 0;
            for (TDSReport report = (TDSReport) reader.read(); report != null; report = (TDSReport) reader.read()) {
                final String examPayload = XmlUtils.tdsReportToXml(report);
                ++count;
                source.submitExam(user, examPayload, MediaType.APPLICATION_XML_VALUE);
            }
            logger.info("extracted {} exams from exam csv", count);

        } catch (final UnsupportedEncodingException ignored) {
            // this will never happen in a modern JVM
        } catch (final Exception e) {
            logger.warn("error reading exam CSV", e);
            throw new RuntimeException(e);
        }

        return repository.create(RdwImport.builder()
                .content(ImportContent.EXAM)
                .contentType(contentType)
                .digest(digest)
                .status(ImportStatus.ACCEPTED)
                .creator(user.getUsername())
                .build());
    }

    @Override
    public Optional<RdwImport> getImport(final long id) {
        return Optional.ofNullable(repository.findOne(id));
    }
}
