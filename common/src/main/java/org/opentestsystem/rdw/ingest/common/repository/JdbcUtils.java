package org.opentestsystem.rdw.ingest.common.repository;

import com.google.common.base.Charsets;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;

/**
 * Helper methods for JDBC
 */
public final class JdbcUtils {

    private static final int TextLimit = (2 << 15) - 1;

    /**
     * @param value string to store
     * @return text truncated to fit in SQL TEXT field
     */
    public static String safeText(final String value) {
        return stringToText(value, TextLimit);
    }

    /**
     * Truncate the string to no more than the limit, where the limit is the database field length.
     * <p>
     * Yes, this is a mess. To make sure the string is properly terminated we have to be fully
     * aware of the multibyte nature of the characters.
     * </p>
     *
     * @param value original string, may be null, empty, long, whatever
     * @param textLimit text limit; this is the byte length limit for the db field
     * @return a possibly shorter string, truncated to fit
     */
    public static String stringToText(final String value, final int textLimit) {
        if (value == null || value.isEmpty()) return value;

        final byte[] bytes = value.getBytes(Charsets.UTF_8);
        if (bytes.length < textLimit) return value;

        // set up decoder to quietly fail
        final CharsetDecoder decoder = Charsets.UTF_8.newDecoder();
        decoder.onMalformedInput(CodingErrorAction.IGNORE);

        // truncate the data using the byte buffer, then let decoder deal with end-of-data issues
        final CharBuffer out = CharBuffer.allocate(textLimit);
        decoder.decode(ByteBuffer.wrap(bytes, 0, textLimit), out, true);
        decoder.flush(out);

        return new String(out.array(), 0, out.position());
    }

    // hide utils class ctor
    private JdbcUtils() { }
}
