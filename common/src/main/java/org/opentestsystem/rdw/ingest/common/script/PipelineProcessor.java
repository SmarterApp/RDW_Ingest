package org.opentestsystem.rdw.ingest.common.script;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.common.util.TransformedPayloadArchiver;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineResults;
import org.opentestsystem.rdw.script.ScriptRuntimeException;

/**
 * Base class for processors that incorporate a pipeline for pre-processing their incoming messages.
 */
public abstract class PipelineProcessor {
    private static final Logger logger = LoggerFactory.getLogger(PipelineProcessor.class);

    protected final ImportRepository importRepository;
    private final PipelineService pipelineService;
    private final ArchiveService archiveService;

    /**
     * @param importRepository the import repository for updating import record state
     * @param pipelineService  pipeline service; expected to be tenant-aware and caching
     * @param archiveService archive service; expected to be tenant-aware
     */
    protected PipelineProcessor(final ImportRepository importRepository,
                                final PipelineService pipelineService,
                                final ArchiveService archiveService) {
        this.importRepository = importRepository;
        this.pipelineService = pipelineService;
        this.archiveService = archiveService;
    }

    /**
     * Get the pipeline by creating it or loading from cache and use it to pre-process the input.
     * <p>
     * This method is written as a helper: it will handle exceptions, logging and updating the
     * import record as appropriate. Child classes should simply catch any exception and return.
     * That is why the anti-pattern of log-and-throw is being used: this method is dealing with
     * the exception but it is using a thrown exception to indicate to the caller to give up.
     * </p>
     *
     * @param input the input data to preprocess
     * @param importId the import id used for updating status in case of a failure
     * @return the input altered by the pre-processing or the original input if there is no pipeline
     */
    protected byte[] processByPipeline(final PipelineType pipelineType, final byte[] input, final long importId) {

        // get the pipeline dynamically so it can use the current tenant
        // this expects the factory to deal with tenant and any caching
        final Pipeline pipeline;
        try {
            pipeline = pipelineService.getPipeline(pipelineType.code()).orElse(null);
        } catch (final PipelineBuildException e) {
            logger.error("Failed to load pipeline {}", pipelineType);
            importRepository.updateStatusAndMessageById(importId, ImportStatus.PIPELINE_FAILURE, e.getMessage());
            throw e;
        }

        try {
            if (pipeline == null) {
                return input;
            } else {
                // Run through pipeline and archive the transformation if any
                final PipelineResults results = pipeline.run(input);
                final byte [] transformedPayload = results.asByteArray();
                if (results.isModified()) {
                    TransformedPayloadArchiver.archive(input, transformedPayload, pipelineType, archiveService);
                }
                return transformedPayload;
            }
        } catch (final ScriptRuntimeException e) {
            if (e.getCause() instanceof ImportException) {
                final ImportException ie = (ImportException)e.getCause();
                logger.info("Error processing {}: {}", pipelineType.code(), ie.getMessage());
                importRepository.updateStatusAndMessageById(importId, ie.getStatus(), ie.getMessage());
            } else {
                logger.warn("Pipeline script failure: {}", e.getMessage());
                importRepository.updateStatusAndMessageById(importId, ImportStatus.PIPELINE_FAILURE, e.getMessage());
            }
            throw e;
        } catch (final Exception e) {
            logger.warn("Pipeline failed to process {}: {}", pipelineType.code(), e.getMessage());
            importRepository.updateStatusAndMessageById(importId, ImportStatus.PIPELINE_FAILURE, e.getMessage());
            throw new RuntimeException(e);
        }
    }
}
