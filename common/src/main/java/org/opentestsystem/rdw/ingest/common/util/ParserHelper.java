package org.opentestsystem.rdw.ingest.common.util;

import org.springframework.util.StringUtils;

import javax.validation.constraints.NotNull;
import java.time.LocalDate;
import java.time.Year;
import java.util.function.Function;

/**
 * Helper methods for parsing and validating data elements
 */
public class ParserHelper {

    private final DataElementErrorCollector elementErrorCollector;

    /**
     * General construction that collects errors in to a {@link DataElementErrorCollector}
     *
     * @param elementErrorCollector error collector to use for any errors
     */
    public ParserHelper(@NotNull final DataElementErrorCollector elementErrorCollector) {
        this.elementErrorCollector = elementErrorCollector;
    }

    /**
     * Basic typed validation.  Any exception is converted into an error and added to the error collector.
     *
     * @param name       name of field, used only for error message
     * @param rawValue   raw field value
     * @param validateFx validation function
     * @param <T>        data type
     * @return validated value of type T, may be null
     */
    public <T, R> R validate(final String name, final T rawValue, final Function<T, R> validateFx) {
        try {
            return validateFx.apply(rawValue);
        } catch (final Exception ex) {
            elementErrorCollector.add(new DataElementError(name, rawValue == null ? null : rawValue.toString(), ex.getMessage()));
            return null;
        }
    }

    /**
     * String value validation. It is a shortcut for {@link ParserHelper#checkNotBlank} and a string max length verification.
     *
     * @param name            name of field, used only for error message
     * @param rawValue        raw field value
     * @param maxLength       max length of the string for the successful validation
     * @param enforceNotEmpty to allow for null or empty value
     * @return validated value
     */
    public String validate(final String name, final String rawValue, final int maxLength, final boolean enforceNotEmpty) {
        if (enforceNotEmpty && !StringUtils.hasText(rawValue)) {
            elementErrorCollector.add(new DataElementError(name, rawValue, "value may not be blank"));
            return rawValue;
        }

        if (rawValue == null) return null;

        final String validatedString = rawValue.trim();

        if (validatedString.length() > maxLength) elementErrorCollector.add(new DataElementError(name, rawValue, "string is too long, max length is " + maxLength));
        return validatedString;
    }

    /*
     * Helper functions for string parsing to be passed into {@link ParserHelper#validate(String, Object, Function)}
     * as the validation {@link Function}
     */

    /**
     * Converts the given string value into a {@link Boolean}
     * <p>
     * Boolean@throws IllegalArgumentException if value can't be interpreted as a boolean
     */
    public static final Function<String, Boolean> toBoolean = value -> {
        if ("Yes".equalsIgnoreCase(value) || "y".equalsIgnoreCase(value)) return true;
        if ("No".equalsIgnoreCase(value) || "n".equalsIgnoreCase(value)) return false;

        throw new IllegalArgumentException("invalid value [" + value + "]");
    };

    public static final Function<String, Boolean> toBooleanOrNull = value ->
            StringUtils.hasText(value) ? toBoolean.apply(value.trim()) : null;

    /**
     * Convert a given {@link Long} value into a valid year
     */
    public static final Function<Long, Integer> toYear = value -> {
        if (value == null) throw new IllegalArgumentException("invalid year");

        if (value >= Year.MIN_VALUE && value <= Year.MAX_VALUE) return value.intValue();

        throw new IllegalArgumentException("invalid year");
    };

    public static final Function<String, String> checkNotBlank = value -> {
        Precondition.checkNotBlank(value);
        return value.trim();
    };

    public static final Function<String, Long> toLong = value -> {
        Precondition.checkNotBlank(value);
        return Long.parseLong(value);
    };

    public static final Function<String, Double> toDouble = value -> {
        Precondition.checkNotBlank(value);
        return Double.parseDouble(value);
    };

    public static final Function<String, Integer> toInteger = value -> {
        Precondition.checkNotBlank(value);
        return Integer.parseInt(value);
    };

    public static final Function<String, Integer> toIntegerOrNull = value ->
            StringUtils.hasText(value) ? Integer.parseInt(value.trim()) : null;

    public static final Function<String, LocalDate> toLocalDateOrNull = value ->
            StringUtils.hasText(value) ? LocalDate.parse(value.trim()) : null;

    public static Function<String, String> toGrade = value -> {
        Precondition.checkNotBlank(value);
        return value.length() == 1 ? "0" + value : value; //Grade codes need to be two characters. e.g. KG, PK, 01, 02, 11, 12..
    };
}
