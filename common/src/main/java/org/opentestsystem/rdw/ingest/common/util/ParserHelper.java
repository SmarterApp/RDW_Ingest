package org.opentestsystem.rdw.ingest.common.util;

import javax.validation.constraints.NotNull;
import java.util.function.Function;

import static com.google.common.base.Strings.isNullOrEmpty;

/**
 * Helper methods for parsing string fields
 */
public class ParserHelper {

    private final DataElementErrorCollector elementErrorCollector;

    /**
     * General construction that collects errors in to a {@link DataElementErrorCollector}
     *
     * @param elementErrorCollector error collector to use for any errors
     */
    public ParserHelper(@NotNull final DataElementErrorCollector elementErrorCollector) {
        this.elementErrorCollector = elementErrorCollector;
    }

    /**
     * Basic typed parsing. The parseFx function should convert from String to the desired type.
     * Any error will be added to the error collector.
     * Null value considered an invalid value.
     *
     * @param name     name of field, used only for error message
     * @param rawValue raw field value
     * @param parseFx  parsing function
     * @param <T>      data type
     * @return validated value of type T, may be null
     */
    public <T> T parseMandatory(final String name, final String rawValue, final Function<String, T> parseFx) {
        try {
            final T parsedValue = rawValue == null ? null : parseFx.apply(rawValue.trim());
            if (parsedValue == null) elementErrorCollector.add(new DataElementError(name, rawValue, "Invalid value"));
            return parsedValue;
        } catch (final Exception ex) {
            elementErrorCollector.add(new DataElementError(name, rawValue, ex.getMessage()));
            return null;
        }
    }

    /**
     * A null tolerant parsing. The parseFx function should convert from String to the desired type.
     * Any error will be added to the error collector.
     *
     * @param name     name of field, used only for error message
     * @param rawValue raw field value
     * @param parseFx  parsing function
     * @param <T>      data type
     * @return validated value of type T, may be null
     */
    public <T> T parseOptional(final String name, final String rawValue, final Function<String, T> parseFx) {
        if (rawValue == null) return null;

        final String valueToValidate = rawValue.trim();
        if (isNullOrEmpty(valueToValidate)) return null;

        return parseMandatory(name, rawValue, parseFx);
    }

    /**
     * Typed validation. Any error will be added to the error collector.
     *
     * @param name       name of field, used only for error message
     * @param rawValue   raw field value
     * @param validateFx validating function, returns null for error
     * @param <T>        type of the field to be validated
     * @param <R>        return type of the validating function
     * @return validated instance of type R, may be null
     */
    public <T, R> R validate(final String name, @NotNull final T rawValue, final Function<T, R> validateFx) {

        if (rawValue == null) {
            elementErrorCollector.add(new DataElementError(name, null, "Must not be null"));
            return null;
        }

        try {
            final R valueR = validateFx.apply(rawValue);
            if (valueR == null) elementErrorCollector.add(new DataElementError(name, rawValue.toString(), "Unknown value"));
            return valueR;
        } catch (final Exception ex) {
            elementErrorCollector.add(new DataElementError(name, rawValue.toString(), ex.getMessage()));
            return null;
        }
    }

    /**
     * Typed validation that chains parsing with the validation. Any non-null value from the parsing function
     * is passed to the validation function.
     * <p>
     * Yes, in theory a single function could be used but this was initially created to make it easy to
     * combine parsing with repository lookups which expect well behaved input.
     * </p>
     *
     * @param name       name of field, used only for error message
     * @param rawValue   raw field value
     * @param parseFx    parsing function
     * @param validateFx validating function, returns null for error
     * @param <T>        return type of first parsing function, parameter type of validating function
     * @param <R>        return type of validating function
     * @return validated type of type R, may be null
     */
    public <T, R> R parseMandatoryAndValidate(final String name, final String rawValue,
                                              final Function<String, T> parseFx, final Function<T, R> validateFx) {
        final T valueT = parseMandatory(name, rawValue, parseFx);
        if (valueT == null) return null;

        return validate(name, valueT, validateFx);
    }

    /**
     * Converts the given string value into a {@link Boolean}
     *
     * @param value the value to convert
     * @return the parsed {@link Boolean}
     * @throws IllegalArgumentException if value can't be interpreted as a boolean
     */
    public static Boolean toBoolean(final String value) throws IllegalArgumentException {
        if ("Yes".equalsIgnoreCase(value) || "y".equalsIgnoreCase(value)) return true;
        if ("No".equalsIgnoreCase(value) || "n".equalsIgnoreCase(value)) return false;

        throw new IllegalArgumentException("an invalid value [" + value + "]");
    }
}
