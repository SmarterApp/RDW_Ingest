package org.opentestsystem.rdw.ingest.common.script;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import org.opentestsystem.rdw.ingest.common.repository.PipelineRepository;
import org.opentestsystem.rdw.multitenant.TenantIdResolver;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineFactory;

/**
 * Default implementation uses a repository to get the active version and the
 * default pipeline factory to build the pipeline. It also caches pipelines
 * (and the cache is tenant-aware).
 */
public class DefaultPipelineService implements PipelineService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultPipelineService.class);

    private final TenantIdResolver tenantIdResolver;
    private final PipelineFactory pipelineFactory;

    private final LoadingCache<String, Optional<String>> versions;  // tenantId_pipelineCode -> active version
    private final Map<String, Optional<Pipeline>> pipelines;        // tenantId_pipelineCode -> pipeline

    /**
     * @param tenantIdResolver tenant id resolver
     * @param pipelineFactory tenant aware pipeline factory
     * @param pipelineRepository tenant aware pipeline factory
     * @param cacheConfig cache builder config string, e.g. "maximumSize=100,expireAfterWrite=300s"
     */
    public DefaultPipelineService(final TenantIdResolver tenantIdResolver,
                                  final PipelineFactory pipelineFactory,
                                  final PipelineRepository pipelineRepository,
                                  final String cacheConfig) {
        this.tenantIdResolver = tenantIdResolver;
        this.pipelineFactory = pipelineFactory;

        pipelines = new ConcurrentHashMap<>();

        versions = CacheBuilder.from(cacheConfig)
                .build(new CacheLoader<String, Optional<String>>() {
                    @Override
                    public Optional<String> load(final String key) {
                        return Optional.ofNullable(pipelineRepository.findActiveVersion(key.split("_")[1]));
                    }
                });
    }

    @Override
    public synchronized Optional<Pipeline> getPipeline(final String pipelineCode) {
        final String tenantId = tenantIdResolver.getTenantId()
                .orElseThrow(() -> new IllegalStateException("No tenant id set"));

        final String key = tenantId + "_" + pipelineCode;
        final String activeVersion = versions.getUnchecked(key).orElse(null);

        // If the pipeline has already been created for this key then check the
        // version, purging it if the version doesn't match the active version.
        // (logic is a bit annoying because pipelines may be null)
        if (pipelines.containsKey(key)) {
            final Pipeline pipeline = pipelines.get(key).orElse(null);
            if ((pipeline == null && activeVersion == null)
             || (pipeline != null && Objects.equals(activeVersion, pipeline.getSource().getVersion()))) {
                return Optional.ofNullable(pipeline);
            }
            logger.info("Evicting {} pipeline because version has changed", key);
            pipelines.remove(key);
        }

        // if we get here, we need to compute the pipeline
        return pipelines.computeIfAbsent(key, k -> {
            logger.info("Loading {} pipeline version {}", pipelineCode, activeVersion);
            final Pipeline pipeline = pipelineFactory.getPipeline(pipelineCode, activeVersion);
            // if there isn't an active version the factory will create a pipeline
            // from the system scripts; if it does that and there is no system
            // pre/post script, we don't want to return an "empty" pipeline.
            if (activeVersion == null && pipeline != null && pipeline.getScripts().isEmpty()) {
                return Optional.empty();
            }
            return Optional.ofNullable(pipeline);
        });
    }

    @VisibleForTesting
    void clearVersionsCache() {
        versions.invalidateAll();
    }
}
