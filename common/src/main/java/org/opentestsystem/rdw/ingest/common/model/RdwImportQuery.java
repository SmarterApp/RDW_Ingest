package org.opentestsystem.rdw.ingest.common.model;

import java.time.Duration;
import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.StringJoiner;

import static com.google.common.base.Strings.emptyToNull;
import static com.google.common.base.Strings.isNullOrEmpty;

/**
 * Container for query parameters.
 */
public class RdwImportQuery {
    private ImportContent content;
    private ImportStatus status;
    private String batch;
    private String creator;
    private Instant before;
    private Instant after;
    private Integer limit;

    public ImportContent getContent() {
        return content;
    }

    public ImportStatus getStatus() {
        return status;
    }

    public String getBatch() {
        return batch;
    }

    public String getCreator() {
        return creator;
    }

    public Instant getBefore() {
        return before;
    }

    public Instant getAfter() {
        return after;
    }

    public Integer getLimit() {
        return limit;
    }

    public Builder copy() {
        return builder().copy(this);
    }

    public boolean isEmpty() {
        return content == null && status == null && batch == null && creator == null
            && before == null && after == null && limit == null;
    }

    /**
     * @return query as a param-like (ampersand-delimited) string
     */
    public String asParamString() {
        final StringJoiner joiner = new StringJoiner("&");
        if (content != null) joiner.add("content=" + content);
        if (status != null) joiner.add("status=" + status);
        if (batch != null) joiner.add("batch=" + batch);
        if (creator != null) joiner.add("creator=" + creator);
        if (before != null) joiner.add("before=" + before.toString());
        if (after != null) joiner.add("after=" + after.toString());
        if (limit != null) joiner.add("limit=" + limit.toString());
        return joiner.toString();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private ImportContent content;
        private ImportStatus status;
        private String batch;
        private String creator;
        private Instant before;
        private Instant after;
        private Integer limit;

        public RdwImportQuery build() {
            final RdwImportQuery query = new RdwImportQuery();
            query.content = content;
            query.status = status;
            query.batch = batch;
            query.creator = creator;
            query.before = before;
            query.after = after;
            query.limit = limit;
            return query;
        }

        public Builder copy(final RdwImportQuery query) {
            content = query.content;
            status = query.status;
            batch = query.batch;
            creator = query.creator;
            before = query.before;
            after = query.after;
            limit = query.limit;
            return this;
        }

        /**
         * Extract values from a params-like (ampersand-delimited) string.
         * Note that calling {@link RdwImportQuery#asParamString()} on the resulting query may
         * produce a string with the parameters in a different order.
         *
         * @param params params-like string, e.g. content=EXAM&status=PROCESSED&after=-PT10H
         * @return this builder
         */
        public Builder params(final String params) {
            for (final String param : (params.startsWith("?") ? params.substring(1) : params).split("&")) {
                final int equals = param.indexOf('=');
                if (equals == -1) continue;
                final String value = (equals+1) < param.length() ? emptyToNull(param.substring(equals+1).trim()) : null;
                switch(param.substring(0, equals).trim().toLowerCase()) {
                    case "content": content(value); break;
                    case "status":  status(value); break;
                    case "batch":   batch(value); break;
                    case "creator": creator(value); break;
                    case "before":  before(value); break;
                    case "after":   after(value); break;
                    case "limit":   limit(value); break;
                    default:        break;  // just ignore extra params
                }
            }
            return this;
        }

        public Builder content(final ImportContent content) {
            this.content = content;
            return this;
        }

        public Builder content(final String content) {
            if (isNullOrEmpty(content)) {
                return content((ImportContent)null);
            }
            return content(ImportContent.valueOf(content.toUpperCase()));
        }

        public Builder status(final ImportStatus status) {
            this.status = status;
            return this;
        }

        public Builder status(final String status) {
            if (isNullOrEmpty(status)) {
                return status((ImportStatus)null);
            }
            try {
                return status(ImportStatus.valueOf(status.toUpperCase()));
            } catch (final IllegalArgumentException e) {
                return status(ImportStatus.fromValue(Integer.valueOf(status)));
            }
        }

        public Builder batch(final String batch) {
            this.batch = batch;
            return this;
        }

        public Builder creator(final String creator) {
            this.creator = creator;
            return this;
        }

        public Builder before(final Instant before) {
            this.before = before;
            return this;
        }

        public Builder before(final String before) {
            return before(parseInstant(before));
        }

        public Builder after(final Instant after) {
            this.after = after;
            return this;
        }

        public Builder after(final String after) {
            return after(parseInstant(after));
        }

        public Builder limit(final Integer limit) {
            this.limit = limit;
            return this;
        }

        public Builder limit(final String limit) {
            if (isNullOrEmpty(limit)) {
                return limit((Integer)null);
            }
            return limit(Integer.valueOf(limit));
        }

        /**
         * Parses string as a flexible instant representation. Value may be:<ul>
         *     <li>null or empty</li>
         *     <li>now - use current instant</li>
         *     <li>ISO-8601 duration, PnDTnHnMn.nS, e.g. -PT6H = -6 hours, added to now()</li>
         *     <li>ISO-8601 instant, YYYY-MM-DDThh:mm:ss.sssZ</li>
         * </ul>
         *
         * @param value value to parse
         * @return appropriate instant
         */
        private static Instant parseInstant(final String value) {
            if (isNullOrEmpty(value)) {
                return null;
            } else if ("now".equalsIgnoreCase(value)) {
                return Instant.now();
            }
            try {
                return Instant.now().plus(Duration.parse(value));
            } catch (final DateTimeParseException ignored) {
            }
            try {
                return Instant.parse(value);
            } catch (final DateTimeParseException e) {
                throw new IllegalArgumentException(e);
            }
        }
    }
}
