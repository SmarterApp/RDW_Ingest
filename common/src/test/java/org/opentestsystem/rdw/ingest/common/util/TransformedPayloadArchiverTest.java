package org.opentestsystem.rdw.ingest.common.util;

import org.apache.commons.lang3.RandomUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.springframework.util.DigestUtils;

import java.util.Arrays;
import java.util.Properties;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.ingest.common.util.TransformedPayloadArchiver.CONTENT_LENGTH_PROPERTY;
import static org.opentestsystem.rdw.ingest.common.util.TransformedPayloadArchiver.CONTENT_TYPE_HEADER;
import static org.opentestsystem.rdw.ingest.common.util.TransformedPayloadArchiver.CONTENT_TYPE_PROPERTY;
import static org.opentestsystem.rdw.ingest.common.util.TransformedPayloadArchiver.SUFFIX;

public class TransformedPayloadArchiverTest {

    public static final String CONTENT = "EXAM";
    public static final String CONTENT_TYPE = "application/xml";
    private ByteArrayContentWriter archiveService;
    private RdwMessageHeaderAccessor accessor;

    private final TransformedPayloadArchiver archiver = new TransformedPayloadArchiver();
    private final byte [] originalPayload = RandomUtils.nextBytes(100);
    private final byte [] transformedPayload = RandomUtils.nextBytes(100);
    private final String digest = DigestUtils.md5DigestAsHex(originalPayload).toUpperCase();

    @Before
    public void setUp() {
        archiveService = mock(ByteArrayContentWriter.class);
        accessor = mock(RdwMessageHeaderAccessor.class);

        when(accessor.getContent()).thenReturn(CONTENT);
        when(accessor.getHeader(CONTENT_TYPE_HEADER)).thenReturn(CONTENT_TYPE);
    }

    @Test
    public void itShouldTransformedPayloadToOutput() {
        archiver.archive(accessor, originalPayload, transformedPayload, archiveService);

        final ArgumentCaptor<String> locationCaptor = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<Properties> propsCaptor = ArgumentCaptor.forClass(Properties.class);

        verify(archiveService).writeResource(locationCaptor.capture(), eq(transformedPayload), propsCaptor.capture());

        final String location = locationCaptor.getValue();
        assertThat(location).contains(CONTENT);
        assertThat(location.replace("/", "")).contains(digest);
        assertThat(location).endsWith(SUFFIX);

        final Properties properties = propsCaptor.getValue();
        assertThat(properties.getProperty(CONTENT_TYPE_PROPERTY)).isEqualTo(CONTENT_TYPE);
        assertThat(properties.get(CONTENT_LENGTH_PROPERTY)).isEqualTo(transformedPayload.length);
    }

    @Test
    public void itShouldSuppressOutputForUnchanged() {
        final byte [] copiedPayload = Arrays.copyOf(originalPayload, originalPayload.length);

        archiver.archive(accessor, originalPayload, copiedPayload, archiveService);

        verifyZeroInteractions(archiveService);
    }
}