package org.opentestsystem.rdw.ingest.common.script;

import org.junit.Before;
import org.junit.Test;

import java.util.Collections;
import java.util.Optional;
import org.opentestsystem.rdw.ingest.common.repository.PipelineRepository;
import org.opentestsystem.rdw.multitenant.TenantIdResolver;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class DefaultPipelineServiceTest {

    private PipelineFactory pipelineFactory;
    private PipelineRepository pipelineRepository;
    private TenantIdResolver tenantIdResolver;

    private DefaultPipelineService service;

    @Before
    public void createService() {
        pipelineFactory = mock(PipelineFactory.class);
        pipelineRepository = mock(PipelineRepository.class);
        tenantIdResolver = mock(TenantIdResolver.class);

        service = new DefaultPipelineService(tenantIdResolver, pipelineFactory, pipelineRepository);
    }

    @Test(expected = IllegalStateException.class)
    public void itShouldRequireATenant() {
        when(tenantIdResolver.getTenantId()).thenReturn(Optional.empty());
        service.getPipeline("exam");
    }

    @Test
    public void itShouldCacheAndReturnNullForNoPipeline() {
        when(tenantIdResolver.getTenantId()).thenReturn(Optional.of("CA"));
        when(pipelineRepository.findActiveVersion("exam")).thenReturn(null);
        when(pipelineFactory.getPipeline("exam", null)).thenReturn(null);

        assertThat(service.getPipeline("exam")).isEmpty();
        assertThat(service.getPipeline("exam")).isEmpty();
        assertThat(service.getPipeline("exam")).isEmpty();
        verify(pipelineRepository, times(1)).findActiveVersion("exam");
        verify(pipelineFactory, times(1)).getPipeline("exam", null);
    }

    @Test
    public void itShouldEvictAndGetIfVersionChanges() {
        when(tenantIdResolver.getTenantId()).thenReturn(Optional.of("CA"));
        when(pipelineRepository.findActiveVersion("exam")).thenReturn("1").thenReturn("2");
        final Pipeline p1 = createTestPipeline("1");
        final Pipeline p2 = createTestPipeline("2");
        when(pipelineFactory.getPipeline("exam", "1")).thenReturn(p1);
        when(pipelineFactory.getPipeline("exam", "2")).thenReturn(p2);

        assertThat(service.getPipeline("exam").get()).isSameAs(p1);
        assertThat(service.getPipeline("exam").get()).isSameAs(p1);
        service.clearVersionsCache();
        assertThat(service.getPipeline("exam").get()).isSameAs(p2);
        assertThat(service.getPipeline("exam").get()).isSameAs(p2);

        verify(pipelineRepository, times(2)).findActiveVersion("exam");
        verify(pipelineFactory, times(1)).getPipeline("exam", "1");
        verify(pipelineFactory, times(1)).getPipeline("exam", "2");
    }

    @Test
    public void itShouldEvictAndGetIfVersionChangesFromEmpty() {
        when(tenantIdResolver.getTenantId()).thenReturn(Optional.of("CA"));
        when(pipelineRepository.findActiveVersion("exam")).thenReturn(null).thenReturn("1");
        final Pipeline p0 = createTestPipeline(null); // empty pipeline, so like null
        final Pipeline p1 = createTestPipeline("1");
        when(pipelineFactory.getPipeline("exam", null)).thenReturn(p0);
        when(pipelineFactory.getPipeline("exam", "1")).thenReturn(p1);

        assertThat(service.getPipeline("exam")).isEmpty();
        assertThat(service.getPipeline("exam")).isEmpty();
        service.clearVersionsCache();
        assertThat(service.getPipeline("exam").get()).isSameAs(p1);
        assertThat(service.getPipeline("exam").get()).isSameAs(p1);

        verify(pipelineRepository, times(2)).findActiveVersion("exam");
        verify(pipelineFactory, times(1)).getPipeline("exam", null);
        verify(pipelineFactory, times(1)).getPipeline("exam", "1");
    }

    private Pipeline createTestPipeline(final String version) {
        return new Pipeline(PipelineDefinition.builder()
                .version(version)
                .scripts(Collections.emptyList())
                .build(), Collections.emptyList(), null);
    }
}
