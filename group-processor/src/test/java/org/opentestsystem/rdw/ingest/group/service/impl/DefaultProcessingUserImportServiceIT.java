package org.opentestsystem.rdw.ingest.group.service.impl;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.junit.Test;
import org.opentestsystem.rdw.ingest.group.RepositoryBackedIT;
import org.opentestsystem.rdw.ingest.group.service.ProcessingUserImportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.jdbc.Sql;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;

@Import(DefaultProcessingUserImportService.class)
@Sql(scripts = {
        "classpath:WarehouseImportSetup.sql",
        "classpath:WarehouseCodesSetup.sql",
        "classpath:WarehouseEntitiesSetup.sql",
        "classpath:WarehouseUserImportServiceSetup.sql"
})
public class DefaultProcessingUserImportServiceIT extends RepositoryBackedIT {
    private static final Set<Integer> SchoolIds = ImmutableSet.of(-1, -98);

    @Autowired
    public ProcessingUserImportService service;

    @Autowired
    public NamedParameterJdbcTemplate template;

    @Test
    public void itShouldIgnoreExistingStudentRecords() {
        executeService();

        final List<Map<String, Object>> rows = template.queryForList(
                "SELECT * from upload_student_group WHERE batch_id=33 ORDER BY student_ssid",
                new HashMap<>());

        assertThat(rows.size()).isEqualTo(6);
        final Map<String, Object> existing = rows.stream()
                .filter(record -> "88".equals(record.get("student_ssid")))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Student 88 not found"));
        assertThat(existing.get("student_id")).isEqualTo(-88);
    }

    @Test
    public void itShouldIgnoreNonStudentRecords() {
        executeService();

        final List<Map<String, Object>> rows = template.queryForList(
                "SELECT * from upload_student_group WHERE batch_id=33 ORDER BY student_ssid",
                new HashMap<>());

        assertThat(rows.size()).isEqualTo(6);
        assertThat(rows.get(0).get("student_ssid")).isNull();
    }

    @Test
    public void itShouldCreateAnImportForNonExistingStudentsBySchool() {
        executeService();

        final List<Map<String, Object>> imports = template.queryForList(
                "SELECT cast(digest AS SIGNED INTEGER) AS school_id, updated from import WHERE batch='33'",
                new HashMap<>());

        assertThat(imports).hasSize(2);
        assertThat(imports.get(0).get("updated")).isNotEqualTo(imports.get(1).get("updated"));
        assertThat(imports.stream()
                .map(record -> record.get("school_id")))
                .containsOnly(-1L, -98L);
    }

    @Test
    public void itShouldUpdateNonExistingStudentReferences() {
        executeService();

        final List<Map<String, Object>> rows = template.queryForList(
                "SELECT * from upload_student_group WHERE batch_id=33 ORDER BY student_ssid",
                new HashMap<>());

        final Map<String, Integer> ssidToId = rows.stream()
                .filter(row -> row.get("student_id") != null && row.get("student_ssid") != null)
                .collect(Collectors.toMap(
                        row -> (String) row.get("student_ssid"),
                        row -> (int) row.get("student_id")
                ));

        assertThat(ssidToId.get("unknown_student1")).isNotNull();
        assertThat(ssidToId.get("unknown_student2")).isNotNull();
        assertThat(ssidToId.get("unknown_student3")).isNotNull();

        //Assert the new students have imports assigned by school
        final List<Map<String, Object>> students = template.queryForList(
                "SELECT * from student WHERE id in (:student_ids)",
                ImmutableMap.of("student_ids", ssidToId.values()));

        final Map<String, Long> ssidToImport = students.stream()
                .collect(Collectors.toMap(
                        student -> (String) student.get("ssid"),
                        student -> (long)student.get("import_id")
                ));
        assertThat(ssidToImport.get("unknown_student1"))
                .isNotNull()
                .isEqualTo(ssidToImport.get("unknown_student2"));
        assertThat(ssidToImport.get("unknown_student3"))
                .isNotNull()
                .isNotEqualTo(ssidToImport.get("unknown_student1"));
    }

    @Test
    public void itShouldCreateAnImportForDeletedStudents() {
        executeService();

        //Assert the deleted student has an id assigned
        final List<Map<String, Object>> rows = template.queryForList(
                "SELECT * from upload_student_group WHERE batch_id=33 ORDER BY student_ssid",
                new HashMap<>());

        final Integer deletedStudentId = (int) rows.stream()
                .filter(row -> "89".equals(row.get("student_ssid")))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Deleted Student '89' not found"))
                .get("student_id");

        assertThat(deletedStudentId).isEqualTo(-89);

        //Assert the new students have imports assigned by school
        final Map<String, Object> student = template.queryForList(
                "SELECT * from student WHERE id=:student_id",
                ImmutableMap.of("student_id", deletedStudentId))
                .get(0);

        assertThat(student.get("update_import_id"))
                .isNotNull()
                .isNotEqualTo(student.get("import_id"));
    }

    private void executeService() {
        for (final int schoolId : SchoolIds) {
            service.createImports(33, schoolId);
            service.insertMissingStudents(33, schoolId);
            service.updateDeletedStudents(33, schoolId);
            service.triggerImport(33, schoolId);
        }
        service.cleanupBatch(33);
    }
}