package org.opentestsystem.rdw.ingest.group.service.impl;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import org.junit.Test;
import org.opentestsystem.rdw.ingest.group.RepositoryBackedIT;
import org.opentestsystem.rdw.ingest.group.service.ProcessingGroupImportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.dao.IncorrectResultSizeDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.jdbc.Sql;

import java.sql.Timestamp;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;

@Import(DefaultProcessingGroupImportService.class)
@Sql(scripts = {
        "classpath:WarehouseImportSetup.sql",
        "classpath:WarehouseCodesSetup.sql",
        "classpath:WarehouseEntitiesSetup.sql",
        "classpath:WarehouseGroupImportServiceSetup.sql"
})
public class DefaultProcessingGroupImportServiceIT extends RepositoryBackedIT {

    private static final long BatchId = 33;
    private static final Set<Integer> SchoolIds = ImmutableSet.of(-1, -98, -99);

    @Autowired
    public ProcessingGroupImportService service;

    @Autowired
    public NamedParameterJdbcTemplate template;

    @Test
    public void itShouldStageNewGroupsForImport() {
        createImports(BatchId);

        final List<Map<String, Object>> imports = template.queryForList(
                "SELECT * from upload_student_group_import WHERE batch_id=33 AND ref_type = 2",
                new HashMap<>());

        //NOTE: This also stages the "deleted" groups for import
        assertThat(imports).hasSize(3);
        final List<Integer> schoolIds = imports.stream()
                .map(record -> (int) record.get("school_id"))
                .collect(Collectors.toList());
        assertThat(schoolIds).containsOnly(-98, -1, -99);
    }

    @Test
    public void itShouldStageGroupMembershipChangesForImport() {
        createImports(BatchId);

        final List<Map<String, Object>> imports = template.queryForList(
                "SELECT * from upload_student_group_import WHERE batch_id=33 AND ref_type = 3",
                new HashMap<>());

        assertThat(imports).hasSize(2);
        final List<Integer> schoolIds = imports.stream()
                .map(record -> (int) record.get("school_id"))
                .collect(Collectors.toList());
        assertThat(schoolIds).containsOnly(-98, -1);
    }

    @Test
    public void itShouldStageGroupUserChangesForImport() {
        createImports(BatchId);

        final List<Map<String, Object>> imports = template.queryForList(
                "SELECT * from upload_student_group_import WHERE batch_id=33 AND ref_type = 4",
                new HashMap<>());

        assertThat(imports).hasSize(2);
        final List<Integer> schoolIds = imports.stream()
                .map(record -> (int) record.get("school_id"))
                .collect(Collectors.toList());
        assertThat(schoolIds).containsOnly(-98, -1);
    }

    @Test
    public void itShouldStageGroupSubjectChangesForImport() {
        createImports(BatchId);

        final List<Map<String, Object>> imports = template.queryForList(
                "SELECT * from upload_student_group_import WHERE batch_id=33 AND ref_type = 5",
                new HashMap<>());

        assertThat(imports).hasSize(1);
        final List<Integer> schoolIds = imports.stream()
                .map(record -> (int) record.get("school_id"))
                .collect(Collectors.toList());
        assertThat(schoolIds).containsOnly(-1);
    }

    @Test
    public void itShouldCreateAnImportPerSchool() {
        createImports(BatchId);

        final List<Map<String, Object>> imports = template.queryForList(
                "SELECT * from import WHERE batch='33'",
                new HashMap<>());

        assertThat(imports).hasSize(3);
        final List<Integer> schoolIds = imports.stream()
                .map(record -> Integer.valueOf((String) record.get("digest")))
                .collect(Collectors.toList());
        assertThat(schoolIds).containsOnly(-1, -98, -99);
    }

    @Test
    public void itShouldUpdateImportReferences() {
        createImports(BatchId);

        final List<Map<String, Object>> records = template.queryForList(
                "SELECT * from upload_student_group WHERE batch_id=33",
                new HashMap<>());

        final Map<Long, Integer> importToSchool = new HashMap<>();
        records.forEach(row -> {
                    final Long importId = (long) row.get("import_id");
                    final Integer schoolId = (int) row.get("school_id");
                    importToSchool.put(importId, schoolId);
                });
        assertThat(importToSchool.values()).containsOnly(-1, -98, -99);
    }

    @Test
    public void itShouldInsertNewGroups() {
        final List<Integer> existingGroups = template.queryForList(
                "SELECT id from student_group",
                new HashMap<>(),
                Integer.class);

        insertMissingGroups(BatchId);

        final List<Map<String, Object>> newGroups = template.queryForList(
                "SELECT * from student_group WHERE id NOT IN (:existing_groups)",
                ImmutableMap.of("existing_groups", existingGroups));

        assertThat(newGroups).hasSize(2);
        final List<String> groupNames = newGroups.stream()
                .map(record -> (String) record.get("name"))
                .collect(Collectors.toList());
        assertThat(groupNames).containsOnly("New Group 1", "New Group 2");
    }

    @Test
    public void itShouldUpdateDeletedGroups() {
        updateDeletedGroups(BatchId);

        final Map<String, Object> deletedGroup = template.queryForMap(
                "SELECT * from student_group WHERE name = 'Test Student Group 9 - updated school'",
                new HashMap<>());

        assertThat(deletedGroup.get("deleted")).isEqualTo(0);
    }

    @Test
    public void itShouldAssignCreatedAndUnDeletedGroupIds() {
        updateModifiedGroups(BatchId);

        final List<Map<String, Object>> noGroupId = template.queryForList(
                "SELECT * from upload_student_group WHERE batch_id = :batch_id AND group_id IS NULL",
                new MapSqlParameterSource("batch_id", BatchId));

        assertThat(noGroupId).isEmpty();
    }

    @Test
    public void itShouldUpdateModifiedGroupSubjects() {
        updateModifiedGroups(BatchId);

        final Map<String, Object> modifiedGroup = template.queryForMap(
                "SELECT * from student_group WHERE name = 'Test Student Group 8'",
                new HashMap<>());

        assertThat(modifiedGroup.get("subject_id")).isEqualTo(1);
    }

    @Test
    public void itShouldUpdateModifiedGroupUsers() {
        updateModifiedGroupUsers(BatchId);

        final List<Map<String, Object>> group8Users = template.queryForList(
                "SELECT * from user_student_group WHERE student_group_id = -8",
                new HashMap<>());
        assertThat(group8Users).hasSize(2);
        assertThat(group8Users.stream().map(row -> row.get("user_login")))
                .containsOnly("user1@somewhere.com", "user2@somewhere.com");

        final List<Map<String, Object>> group7Users = template.queryForList(
                "SELECT * from user_student_group WHERE student_group_id = -7",
                new HashMap<>());
        assertThat(group7Users).hasSize(1);
        assertThat(group7Users.stream().map(row -> row.get("user_login")))
                .containsOnly("user3@somewhere.com");

        final List<Map<String, Object>> unchangedUsers = template.queryForList(
                "SELECT * from user_student_group WHERE student_group_id = -6",
                new HashMap<>());
        assertThat(unchangedUsers).hasSize(2);
        assertThat(unchangedUsers.stream().map(row -> row.get("user_login")))
                .containsOnly("dwtest@example.com-6-1", "dwtest@example.com-6-2");
    }

    @Test
    public void itShouldUpdateModifiedGroupStudents() {
        updateModifiedGroupStudents(BatchId);

        Map<String, Object> group = template.queryForMap(
                "SELECT * from student_group WHERE id = -8",
                new HashMap<>());
        assertThat(((Timestamp) group.get("updated")).toInstant()).isGreaterThan(Instant.now().minus(Duration.ofMinutes(1)));

        final List<Map<String, Object>> group8Students = template.queryForList(
                "SELECT * from student_group_membership WHERE student_group_id = -8",
                new HashMap<>());
        assertThat(group8Students).hasSize(2);
        assertThat(group8Students.stream().map(row -> row.get("student_id")))
                .containsOnly(-88, -86);

        group = template.queryForMap(
                "SELECT * from student_group WHERE id = -7",
                new HashMap<>());
        assertThat(((Timestamp) group.get("updated")).toInstant()).isGreaterThan(Instant.now().minus(Duration.ofMinutes(1)));

        final List<Map<String, Object>> group7Students = template.queryForList(
                "SELECT * from student_group_membership WHERE student_group_id = -7",
                new HashMap<>());
        assertThat(group7Students).hasSize(1);
        assertThat(group7Students.stream().map(row -> row.get("student_id")))
                .containsOnly(-88);

        group = template.queryForMap(
                "SELECT * from student_group WHERE id = -6",
                new HashMap<>());
        assertThat(((Timestamp) group.get("updated")).toInstant()).isLessThan(Instant.now().minus(Duration.ofMinutes(1)));

        final List<Map<String, Object>> unchangedUsers = template.queryForList(
                "SELECT * from student_group_membership WHERE student_group_id = -6",
                new HashMap<>());
        assertThat(unchangedUsers).hasSize(3);
        assertThat(unchangedUsers.stream().map(row -> row.get("student_id")))
                .containsOnly(-87, -86, -33);
    }

    @Test
    public void itShouldAddStudentsToEmptyGroup() {
        createImports(34);

        final Map<String, Object> groupWithAddedStudents = template.queryForMap(
                "SELECT * from upload_student_group where group_id = -5",
                new HashMap<>());
        assertThat(groupWithAddedStudents.get("import_id")).isNotNull();
    }

    @Test
    public void itShouldClearStudentsFromPopulatedGroup() {
        createImports(35);

        final Map<String, Object> groupWithClearedStudents = template.queryForMap(
                "SELECT * from upload_student_group where group_id = -3",
                new HashMap<>());
        assertThat(groupWithClearedStudents.get("import_id")).isNotNull();
    }

    @Test
    public void itShouldAddUsersToEmptyGroup() {
        createImports(36);

        final Map<String, Object> groupWithClearedStudents = template.queryForMap(
                "SELECT * from upload_student_group where group_id = -4",
                new HashMap<>());
        assertThat(groupWithClearedStudents.get("import_id")).isNotNull();
    }

    @Test
    public void itShouldClearUsersFromPopulatedGroup() {
        createImports(37);

        final Map<String, Object> groupWithClearedStudents = template.queryForMap(
                "SELECT * from upload_student_group where group_id = -2",
                new HashMap<>());
        assertThat(groupWithClearedStudents.get("import_id")).isNotNull();
    }

    @Test
    public void itShouldTriggerAMigration() {
        triggerImports(BatchId);

        final List<Map<String, Object>> imports = template.queryForList(
                "SELECT * FROM import WHERE batch = '33'",
                ImmutableMap.of());

        assertThat(imports).hasSize(3);
        assertThat(imports.stream().map(row -> row.get("status")))
                .containsOnly(1);
    }

    @Test
    public void itShouldFailInsertingMissingGroupsForBadSchoolYear() {
        // This test plays with the situation where an invalid school year was set for a group
        // (the CSV validation has been improved so this shouldn't happen any more but ...)
        //
        // The problem is that `insertMissingGroups` silently fails to insert the missing group
        // because of a data integrity violation. After that, other steps no-op because they are
        // joining to the student_group table which doesn't have an entry.
        //
        // All that said, the worst that will happen is the import will be marked PROCESSED which
        // might be misleading since nothing was imported.

        service.createImports(50, -1);

        assertThat(template.queryForObject("SELECT status FROM import WHERE batch='50' AND digest='-1'",
                new HashMap<>(), Integer.class)).isEqualTo(0);

        assertThat(template.queryForObject("SELECT school_id from upload_student_group_import WHERE batch_id=50 AND ref_type = 2",
                new HashMap<>(), Long.class)).isEqualTo(-1);

        service.insertMissingGroups(50, -1);
        try {
            template.queryForObject("SELECT school_id FROM student_group WHERE name='Bad Year'",
                    new HashMap<>(), Long.class);
            fail("it should've thrown an exception due to the missing row");
        } catch (final IncorrectResultSizeDataAccessException expected) {
            // this query for (single) object fails due to the missing row
        }

        // demonstrate that it continues without "error" ...
        service.updateDeletedGroups(50, -1);
        service.updateModifiedGroups(50, -1);
        service.updateModifiedGroupUsers(50, -1);
        service.updateModifiedGroupStudents(50, -1);
        service.triggerImport(50, -1);

        assertThat(template.queryForObject("SELECT status FROM import WHERE batch='50' AND digest='-1'",
                new HashMap<>(), Integer.class)).isEqualTo(1);

        service.cleanupBatch(50);
    }

    private void createImports(final long batchId) {
        for (final int schoolId : SchoolIds) {
            service.createImports(batchId, schoolId);
        }
    }

    private void insertMissingGroups(final long batchId) {
        for (final int schoolId : SchoolIds) {
            service.createImports(batchId, schoolId);
            service.insertMissingGroups(batchId, schoolId);
        }
    }

    private void updateDeletedGroups(final long batchId) {
        for (final int schoolId : SchoolIds) {
            service.createImports(batchId, schoolId);
            service.insertMissingGroups(batchId, schoolId);
            service.updateDeletedGroups(batchId, schoolId);
        }
    }

    private void updateModifiedGroups(final long batchId) {
        for (final int schoolId : SchoolIds) {
            service.createImports(batchId, schoolId);
            service.insertMissingGroups(batchId, schoolId);
            service.updateDeletedGroups(batchId, schoolId);
            service.updateModifiedGroups(batchId, schoolId);
        }
    }

    private void updateModifiedGroupUsers(final long batchId) {
        for (final int schoolId : SchoolIds) {
            service.createImports(batchId, schoolId);
            service.insertMissingGroups(batchId, schoolId);
            service.updateDeletedGroups(batchId, schoolId);
            service.updateModifiedGroups(batchId, schoolId);
            service.updateModifiedGroupUsers(batchId, schoolId);
        }
    }

    private void updateModifiedGroupStudents(final long batchId) {
        for (final int schoolId : SchoolIds) {
            service.createImports(batchId, schoolId);
            service.insertMissingGroups(batchId, schoolId);
            service.updateDeletedGroups(batchId, schoolId);
            service.updateModifiedGroups(batchId, schoolId);
            service.updateModifiedGroupUsers(batchId, schoolId);
            service.updateModifiedGroupStudents(batchId, schoolId);
        }
    }

    private void triggerImports(final long batchId) {
        for (final int schoolId : SchoolIds) {
            service.createImports(batchId, schoolId);
            service.insertMissingGroups(batchId, schoolId);
            service.updateDeletedGroups(batchId, schoolId);
            service.updateModifiedGroups(batchId, schoolId);
            service.updateModifiedGroupUsers(batchId, schoolId);
            service.updateModifiedGroupStudents(batchId, schoolId);
            service.triggerImport(batchId, schoolId);
        }
    }
}