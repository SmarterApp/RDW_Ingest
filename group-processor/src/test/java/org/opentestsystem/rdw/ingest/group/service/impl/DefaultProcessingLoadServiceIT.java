package org.opentestsystem.rdw.ingest.group.service.impl;

import com.amazonaws.services.s3.Headers;
import com.google.common.collect.ImmutableMap;
import org.junit.Test;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.ingest.common.util.LocationStrategy;
import org.opentestsystem.rdw.ingest.group.ArchiveServiceConfiguration;
import org.opentestsystem.rdw.ingest.group.RepositoryBackedIT;
import org.opentestsystem.rdw.ingest.group.service.ProcessingLoadService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import static com.google.common.collect.ImmutableSortedSet.of;
import static com.google.common.io.Resources.getResource;
import static com.google.common.io.Resources.toByteArray;
import static org.assertj.core.api.Assertions.assertThat;

@Import({
        DefaultProcessingLoadService.class,
        ArchiveServiceConfiguration.class
})
public class DefaultProcessingLoadServiceIT extends RepositoryBackedIT {

    @Autowired
    public ProcessingLoadService service;

    @Autowired
    public ArchiveService archiveService;

    @Autowired
    public NamedParameterJdbcTemplate template;

    @Test
    public void itShouldLoadACSVWithCRLFIntoDatabase() throws Exception {
        final String digest = "ABCD001";
        final long batchId = 121L;
        final String location = saveResource("sample-group-001.crlf.csv", "\\r\\n", ",", digest);
        try {
            service.loadGroup(digest, batchId);
            verify(batchId);
        } finally {
            archiveService.delete(location);
        }
    }

    @Test
    public void itShouldLoadACSVWithCRIntoDatabase() throws Exception {
        final String digest = "ABCD002";
        final long batchId = 122L;
        final String location = saveResource("sample-group-002.cr.csv", "\\r", ",", digest);
        try {
            service.loadGroup(digest, batchId);
            verify(batchId);
        } finally {
            archiveService.delete(location);
        }
    }

    @Test
    public void itShouldLoadACSVWithLFIntoDatabase() throws Exception {
        final String digest = "ABCD003";
        final long batchId = 123L;
        final String location = saveResource("sample-group-003.lf.csv", "\\n", ",", digest);
        try {
            service.loadGroup(digest, batchId);
            verify(batchId);
        } finally {
            archiveService.delete(location);
        }
    }

    @Test
    public void itShouldLoadACSVWithCRLFAndTabsIntoDatabase() throws Exception {
        // although this can't actually happen in the wild, demonstrate that tab-delimiter works
        final String digest = "ABCD004";
        final long batchId = 124L;
        final String location = saveResource("sample-group-004.crlf.tsv", "\\n", "\\t", digest);
        try {
            service.loadGroup(digest, batchId);
            verify(batchId);
        } finally {
            archiveService.delete(location);
        }
    }

    private String saveResource(final String resource, final String newline, final String delimiter, final String digest) throws IOException {
        final String location = new LocationStrategy.GroupUploadContentLocationStrategy().location(digest);
        final byte[] csvBytes = toByteArray(getResource(resource));
        final Properties properties = new Properties();
        properties.put(Headers.CONTENT_LENGTH, csvBytes.length);
        properties.put("delimiter", delimiter);
        properties.put("newline", newline);
        archiveService.writeResource(location, csvBytes, properties);
        return location;
    }

    private void verify(final long importId) {
        final List<Map<String, Object>> rows = template.queryForList(
                "SELECT * FROM upload_student_group WHERE import_id = :import_id",
                ImmutableMap.of("import_id", importId));

        assertThat(rows.size()).isEqualTo(12);
        final Set<String> groupNames = of("JT4thGrade", "ME6thGradeMath");
        final Set<String> schools = of("DS9002");
        final Set<Integer> years = of(2018);
        final Set<String> students = of(
                "SSID001",
                "SSID002",
                "SSID003",
                "SSID010",
                "SSID011",
                "SSID012");
        final Set<String> users = of(
                "jteacher@example.com",
                "btutor@example.com",
                "meducator@example.com",
                "sinstructor@example.com");

        for (final Map<String, Object> row : rows) {
            assertThat(groupNames).contains((String) row.get("group_name"));
            assertThat(schools).contains((String) row.get("school_natural_id"));
            assertThat(years).contains((int) row.get("school_year"));
            if (row.get("student_ssid") != null) {
                assertThat(students).contains((String) row.get("student_ssid"));
            }
            if (row.get("group_user_login") != null) {
                assertThat(users).contains((String) row.get("group_user_login"));
            }
        }
    }
}