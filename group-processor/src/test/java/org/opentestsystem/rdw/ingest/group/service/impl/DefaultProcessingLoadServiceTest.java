package org.opentestsystem.rdw.ingest.group.service.impl;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.ingest.common.repository.SqlListExecutionRepository;
import org.opentestsystem.rdw.ingest.common.util.LocationStrategy;
import org.opentestsystem.rdw.ingest.group.configuration.GroupProcessingSqlConfiguration;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import static com.google.common.collect.Maps.newHashMap;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.entry;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.archive.ArchiveService.RawURI;

@RunWith(MockitoJUnitRunner.class)
public class DefaultProcessingLoadServiceTest{

    @Mock
    private ArchiveService archiveService;

    @Mock
    private SqlListExecutionRepository repository;

    @Mock
    private GroupProcessingSqlConfiguration sqlConfiguration;

    private final String digest = "ABCDEF";
    private final String location = new LocationStrategy.GroupUploadContentLocationStrategy().location(digest);
    private final Properties properties = new Properties();

    private DefaultProcessingLoadService service;

    @Before
    public void createLoadService() throws IOException {
        properties.clear();
        properties.setProperty("delimiter", ",");
        properties.setProperty("newline", "\\r\\n");

        when(archiveService.exists(location)).thenReturn(true);
        when(archiveService.readProperties(location)).thenReturn(properties);

        when(sqlConfiguration.getEntities()).thenReturn(newHashMap());

        service = new DefaultProcessingLoadService(archiveService, repository, sqlConfiguration);
        service.rawSql = "%s '%s' '%s'";    // make verification easier
    }

    @Test
    public void itShouldCreateLocalSql() {
        properties.setProperty(RawURI, "file:///tmp/location");

        service.loadBatch(digest, 1L);

        final ArgumentCaptor<List> sqlListCaptor = ArgumentCaptor.forClass(List.class);
        final ArgumentCaptor<Map> mapCaptor = ArgumentCaptor.forClass(Map.class);
        verify(repository).execute(sqlListCaptor.capture(), mapCaptor.capture());
        assertThat((String) sqlListCaptor.getValue().get(0)).isEqualTo("LOCAL INFILE ',' '\\r\\n'");
        assertThat(mapCaptor.getValue()).contains(entry("batch_id",1L), entry("uri", "/tmp/location"));
    }

    @Test
    public void itShouldCreateS3Sql() {
        properties.setProperty(RawURI, "s3://lo/ca/location");

        service.loadBatch(digest, 1L);

        final ArgumentCaptor<List> sqlListCaptor = ArgumentCaptor.forClass(List.class);
        final ArgumentCaptor<Map> mapCaptor = ArgumentCaptor.forClass(Map.class);
        verify(repository).execute(sqlListCaptor.capture(), mapCaptor.capture());
        assertThat((String) sqlListCaptor.getValue().get(0)).isEqualTo("FROM S3 ',' '\\r\\n'");
        assertThat(mapCaptor.getValue()).contains(entry("batch_id",1L), entry("uri", "s3://lo/ca/location"));
    }

    @Test
    public void itShouldUseDefaultDelimiterAndNewline() {
        properties.remove("delimiter");
        properties.remove("newline");
        properties.setProperty(RawURI, "file:///tmp/location");

        service.loadBatch(digest, 1L);

        final ArgumentCaptor<List> sqlListCaptor = ArgumentCaptor.forClass(List.class);
        verify(repository).execute(sqlListCaptor.capture(), any(Map.class));
        assertThat((String) sqlListCaptor.getValue().get(0)).isEqualTo("LOCAL INFILE ',' '\\n'");
    }

    @Test
    public void itShouldValidateDelimiterAndNewline() {
        properties.setProperty("delimiter", "R");
        properties.setProperty("newline", "|");
        properties.setProperty(RawURI, "file:///tmp/location");

        service.loadBatch(digest, 1L);

        final ArgumentCaptor<List> sqlListCaptor = ArgumentCaptor.forClass(List.class);
        verify(repository).execute(sqlListCaptor.capture(), any(Map.class));
        assertThat((String) sqlListCaptor.getValue().get(0)).isEqualTo("LOCAL INFILE ',' '\\n'");
    }
}