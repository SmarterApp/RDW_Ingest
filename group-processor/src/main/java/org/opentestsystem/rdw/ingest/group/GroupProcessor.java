package org.opentestsystem.rdw.ingest.group;

import com.google.gson.Gson;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.group.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.ingest.group.service.GroupMessageProcessor;
import org.opentestsystem.rdw.messaging.GroupMessage;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Processor;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.messaging.Message;

import java.nio.charset.StandardCharsets;

@EnableBinding(Sink.class)
public class GroupProcessor {
    private static final Logger logger = LoggerFactory.getLogger(GroupProcessor.class);

    private final GroupMessageProcessor groupMessageProcessor;
    private final StudentGroupBatchRepository batchRepository;

    @Autowired
    public GroupProcessor(final GroupMessageProcessor groupMessageProcessor,
                          final StudentGroupBatchRepository batchRepository) {
        this.groupMessageProcessor = groupMessageProcessor;
        this.batchRepository = batchRepository;
    }

    // TODO - verify that processing results in timestamps that vary and not all with the same values

    @ServiceActivator(inputChannel = Processor.INPUT)
    public void process(final Message<?> message) {
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(message);
        try {
            // TODO - change expectation of payload
            // TODO   expect just the digest in the body, not a structured GroupMessage
            //payload should be a json object
            final String payload = new String((byte[]) message.getPayload(), StandardCharsets.UTF_8);

            logger.debug("received id: {} headers: {}", accessor.getImportId(), accessor);

            final GroupMessage gm = new Gson().fromJson(payload, GroupMessage.class);
            groupMessageProcessor.process(gm);
            batchRepository.updateBatch(gm.getUploadId(), ImportStatus.PROCESSED);
        } catch (final ImportException e) {
            logger.warn("failed with an unexpected import error: " + e.getMessage());
            // TODO change this to update import record
            try {
                batchRepository.updateBatch(accessor.getImportId(), e.getStatus(), e.getMessage());
            } catch (final Exception e2) {
                logger.error("Failed to update batch status: {}", accessor.getImportId());
            }
        } catch (final Exception e) {
            logger.warn("failed with an unexpected error: " + e.getMessage());
            // TODO change this to update import record
            try {
                batchRepository.updateBatch(accessor.getImportId(), ImportStatus.BAD_DATA, e.getMessage());
            } catch (final Exception e2) {
                logger.error("Failed to update batch status: {}", accessor.getImportId());
            }
        }
    }
}
