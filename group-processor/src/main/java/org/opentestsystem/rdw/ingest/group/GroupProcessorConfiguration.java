package org.opentestsystem.rdw.ingest.group;

import com.google.gson.Gson;
import org.opentestsystem.rdw.ingest.common.model.GroupMessage;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.group.repository.StudentGroupBatchRepository;
import org.opentestsystem.rdw.ingest.group.service.GroupProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Processor;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.messaging.Message;

import java.nio.charset.StandardCharsets;


@EnableBinding(Sink.class)
public class GroupProcessorConfiguration {
    private static final Logger logger = LoggerFactory.getLogger(GroupProcessorConfiguration.class);

    private final GroupProcessor groupProcessor;
    private final StudentGroupBatchRepository batchRepository;

    @Autowired
    public GroupProcessorConfiguration(final GroupProcessor groupProcessor,
                                       final StudentGroupBatchRepository batchRepository) {
        this.groupProcessor = groupProcessor;
        this.batchRepository = batchRepository;
    }

    @ServiceActivator(inputChannel = Processor.INPUT)
    public void process(final Message<?> message) {
        RdwMessageHeaderAccessor accessor = null;
        try {
            //payload should be a json object
            accessor = RdwMessageHeaderAccessor.wrap(message);
            final String payload = new String((byte[]) message.getPayload(), StandardCharsets.UTF_8);

            logger.info("received id: {} headers: {}", accessor.getImportId(), accessor);

            logger.info("Received payload: {}", (payload.length() > 80 ? payload.substring(0, 80) + "..." : payload));


            final GroupMessage gm = new Gson().fromJson(payload, GroupMessage.class);
            groupProcessor.process(gm);
            batchRepository.updateBatchStatus(gm.getUploadId(), ImportStatus.PROCESSED, "");
        } catch (final ImportException e) {
            logger.warn("failed with an unexpected import error: " + e.getMessage());
            if (accessor != null) {
                try {
                    batchRepository.updateBatchStatus(accessor.getImportId(), e.getStatus(), e.getMessage());
                } catch (final Exception e2) {
                    logger.error("Failed to update batch status: {}", accessor.getImportId());
                }
            }
        } catch (final Exception e) {
            logger.warn("failed with an unexpected import error: " + e.getMessage());
            if (accessor != null) {
                try {
                    batchRepository.updateBatchStatus(accessor.getImportId(), ImportStatus.BAD_DATA, e.getMessage());
                } catch (final Exception e2) {
                    logger.error("Failed to update batch status: {}", accessor.getImportId());
                }
            }
        }
    }

}
