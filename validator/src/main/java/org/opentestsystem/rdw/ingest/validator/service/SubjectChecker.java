package org.opentestsystem.rdw.ingest.validator.service;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.subject.AltScore;
import org.opentestsystem.rdw.common.model.subject.AltScoring;
import org.opentestsystem.rdw.common.model.subject.Claim;
import org.opentestsystem.rdw.common.model.subject.OverallScoring;
import org.opentestsystem.rdw.common.model.subject.Scorable;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.common.model.subject.SubjectMessage;
import org.opentestsystem.rdw.common.model.subject.Target;

import static java.util.stream.Collectors.counting;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.toList;
import static org.apache.commons.lang3.StringUtils.isBlank;

/**
 * Helper to partition logic for checking subjects.
 */
class SubjectChecker {

    static void checkSubjects(final MessageSink messageSink, final List<Subject> subjects) {
        // They all have to have distinct codes
        // (reduce to a map of code -> count, then filter out those that have count > 1)
        for (final String code : subjects.stream()
                .collect(groupingBy(Subject::getCode, counting())).entrySet().stream()
                .filter(entry -> entry.getValue() > 1).map(Map.Entry::getKey).collect(toList())) {
            messageSink.error("duplicate subject code {0}", code);
        }

        // They should all have distinct names
        for (final String name : subjects.stream()
                .collect(groupingBy(Subject::getName, counting())).entrySet().stream()
                .filter(entry -> entry.getValue() > 1).map(Map.Entry::getKey).collect(toList())) {
            messageSink.warning("duplicate subject name {0} may be confusing for users", name);
        }

        for (final Subject subject : subjects) {
            checkSubject(messageSink, subject);
        }
    }

    private static void checkSubject(final MessageSink messageSink, final Subject subject) {
        final String prefix = "subject " + subject.getCode() + ": ";

        final List<SubjectMessage> subjectMessages = subject.getSubjectMessages();
        if (subjectMessages != null &&
                subjectMessages.stream().map(SubjectMessage::getKey).collect(Collectors.toSet()).size() < subjectMessages.size()) {
            messageSink.error(prefix + "message keys must be unique");
        }

        for (final SubjectAssessmentType type : subject.getAssessmentTypes()) {
            // should have a message for the type
            if (subjectMessages != null && subjectMessages.stream().noneMatch(m -> m.getKey().equals(type.getCode() + ".performance-info"))) {
                messageSink.error(prefix + "missing performance-info message for {0}", type.getCode());
            }

            // targetReport should really only be enabled for summative assessments
            if (type.isTargetReport() && !AssessmentType.SUMMATIVE.code().equals(type.getCode())) {
                messageSink.warning(prefix + "only summative assessments should have targetReport enabled");
            }

            // OverallScoring checks
            final OverallScoring overallScoring = type.getOverallScoring();
            if (isBlank(overallScoring.getName())) {
                messageSink.error(prefix + "OverallScoring must have a name");
            }
            if (overallScoring.getMinScore() == null || overallScoring.getMaxScore() == null) {
                messageSink.warning(prefix + "OverallScoring should have min/maxScore (it improves data validation)");
            }
            // TODO - do we need to check the performance level levels (i.e. contiguous increasing from 1)?

            final AltScoring altScoring = type.getAltScoring();
            if (altScoring != null) {
                if (isBlank(altScoring.getName())) {
                    messageSink.error(prefix + "AltScoring must have a name");
                }
            }

            // IAB-specific checks
            if (AssessmentType.IAB.code().equals(type.getCode())) {
                if (overallScoring.getPerformanceLevels().getStandardCutoff() != null) {
                    messageSink.error(prefix + "IABs do not support a standard cutoff");
                }
                if (overallScoring.getPerformanceLevels().getPerformanceLevels().size() != 3) {
                    messageSink.error(prefix + "IABs must have exactly 3 performance levels");
                }
                if (type.getAltScoring() != null) {
                    messageSink.error(prefix + "IABs may not have AltScoring");
                }
                if (type.getClaimScoring() != null) {
                    messageSink.error(prefix + "IABs may not have ClaimScoring");
                }
            }
        }

        // AltScoring: if any assessment type specifies AltScoring then AltScores
        // should be there (and vice versa)
        final boolean alts = (subject.getAltScores() != null);
        final boolean typeUsesAlts = subject.getAssessmentTypes().stream().anyMatch(t -> t.getAltScoring() != null);
        if (alts && !typeUsesAlts) {
            messageSink.warning(prefix + "AltScores specified but no assessment type uses them");
        } else if (!alts && typeUsesAlts) {
            messageSink.error(prefix + "AltScores required (at least one assessment type uses them)");
        }

        // ClaimScoring: if any assessment type specifies ClaimScoring then
        // there should be at least one scoreable Claim
        final boolean claims = subject.getClaims() != null && subject.getClaims().stream().anyMatch(Claim::isScorable);
        final boolean typeUsesClaims = subject.getAssessmentTypes().stream().anyMatch(t -> t.getClaimScoring() != null);
        if (claims && !typeUsesClaims) {
            messageSink.warning(prefix + "Claims specified but no assessment type uses them");
        } else if (!claims && typeUsesClaims) {
            messageSink.error(prefix + "Claims required (at least one assessment type uses them)");
        }

        // AltScores and Claims must, as a group, have unique codes
        final List<String> codes = new ArrayList<>();
        if (subject.getClaims() != null) {
            codes.addAll(subject.getClaims().stream().map(Claim::getCode).collect(toList()));
        }
        if (subject.getAltScores() != null) {
            codes.addAll(subject.getAltScores().stream().map(AltScore::getCode).collect(toList()));
        }
        for (final String code : codes.stream()
                .collect(groupingBy(c -> c, counting())).entrySet().stream()
                .filter(entry -> entry.getValue() > 1).map(Map.Entry::getKey).collect(toList())) {
            messageSink.error(prefix + "duplicate alt/claim code {0}", code);
        }

        // target codes must be unique within a claim
        if (subject.getClaims() != null) {
            for (final Claim claim : subject.getClaims()) {
                if (claim.getTargets() == null) continue;
                for (final String code: claim.getTargets().stream()
                        .collect(groupingBy(Target::getCode, counting())).entrySet().stream()
                        .filter(entry -> entry.getValue() > 1).map(Map.Entry::getKey).collect(toList())) {
                    messageSink.error(prefix + "duplicate target code {0} for claim {1}", code, claim.getCode());
                }
            }
        }

        // AltScores and Claims should have an icon; and the icon name must start with "fa-"
        checkScorableIcon(messageSink, prefix, subject.getAltScores());
        checkScorableIcon(messageSink, prefix, subject.getClaims());

        // TODO - item details should be consistent
        // TODO   ItemDifficulties, DepthsOfKnowledge, (organizational) Claims, Targets, Standards

        // TODO - bunch of stuff to do with ReportGrades?
    }

    private static void checkScorableIcon(final MessageSink messageSink, final String prefix,
                                          final List<? extends Scorable> scorables) {
        if (scorables == null || scorables.isEmpty()) return;

        for (final Scorable scorable : scorables) {
            if (!scorable.getIcon().startsWith("fa-")) {
                messageSink.error(prefix + "icon does not start with \"fa-\" for {0}", scorable.getCode());
            }
        }
    }

}
