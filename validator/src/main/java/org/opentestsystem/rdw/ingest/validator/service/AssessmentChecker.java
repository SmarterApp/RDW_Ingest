package org.opentestsystem.rdw.ingest.validator.service;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.assessment.Assessment;
import org.opentestsystem.rdw.common.model.assessment.Scoring;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;

import static java.util.stream.Collectors.counting;
import static java.util.stream.Collectors.groupingBy;
import static java.util.stream.Collectors.toMap;

/**
 * Helper to partition logic for checking assessments.
 */
class AssessmentChecker {

    private static final List<String> GradeCodes = Arrays.asList(
         "IT", "PR", "PK", "TK", "KG", "PS", "UG",
         "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13",
         // we allow single digit grade codes even though they aren't in the spec
         "1", "2", "3", "4", "5", "6", "7", "8", "9"
    );

    static void checkAssessments(final MessageSink messageSink,
                                 final List<Assessment> assessments,
                                 final List<Subject> subjects) {

        // if the assessments came from multiple files there could be duplicate ids (which is bad)
        for (final String id : assessments.stream()
            .collect(groupingBy(Assessment::getId, counting()))
            .entrySet().stream().filter(entry -> entry.getValue() > 1).map(Map.Entry::getKey).collect(Collectors.toList())) {
            messageSink.error("duplicate assessment id {0}", id);
        }

        // duplicate labels within a single year may be confusing to users
        for (final String key : assessments.stream()
            .collect(groupingBy(a -> String.join("/", a.getLabel(), ""+a.getSchoolYear()), counting()))
            .entrySet().stream().filter(entry -> entry.getValue() > 1).map(Map.Entry::getKey).collect(Collectors.toList())) {
            messageSink.warning("duplicate assessment label/year {0} may be confusing for users", key);
        }

        // there should be a single summative per subject per grade per school year
        for (final String key : assessments.stream()
                .filter(a -> AssessmentType.SUMMATIVE.equals(a.getType()))
                .collect(groupingBy(a -> String.join("-", a.getSubject(), a.getGrade(), ""+a.getSchoolYear()), counting()))
                .entrySet().stream().filter(entry -> entry.getValue() > 1).map(Map.Entry::getKey).collect(Collectors.toList())) {
            messageSink.error("multiple summatives found for {0}", key);
        }

        // there should be a single ICA per subject per grade per school year
        for (final String key : assessments.stream()
                .filter(a -> AssessmentType.ICA.equals(a.getType()))
                .collect(groupingBy(a -> String.join("-", a.getSubject(), a.getGrade(), ""+a.getSchoolYear()), counting()))
                .entrySet().stream().filter(entry -> entry.getValue() > 1).map(Map.Entry::getKey).collect(Collectors.toList())) {
            messageSink.error("multiple ICAs found for {0}", key);
        }

        // to facilitate looking them up case insensitively
        final Map<String, Subject> subjectMap = subjects.stream().collect(toMap(s -> s.getCode().toUpperCase(), s -> s));
        for (final Assessment assessment : assessments) {
            final Subject subject = subjectMap.get(assessment.getSubject().toUpperCase());
            if (subject == null && !subjects.isEmpty()) {
                messageSink.warning("{0}: subject {1} not found; skipping subject validation",
                        assessment.getId(), assessment.getSubject());
            }
            checkAssessment(messageSink, assessment, subject);
        }
    }

    private static void checkAssessment(final MessageSink messageSink, final Assessment assessment, final Subject subject) {
        final String prefix = assessment.getId() + ": ";

        // grade code must be valid
        if (!GradeCodes.contains(assessment.getGrade())) {
            messageSink.error(prefix + "invalid grade code {0}", assessment.getGrade());
        }

        // subject has to exist to continue
        if (subject == null) {
            return;
        }

        // assessment type must be defined in subject
        final SubjectAssessmentType subjectAssessmentType = subject.getAssessmentTypes().stream()
                .filter(type -> type.getCode().equals(assessment.getType().code())).findFirst().orElse(null);
        if (subjectAssessmentType == null) {
            messageSink.error(prefix + "assessment type ({0}) not defined for subject {1}",
                    assessment.getType(), subject.getCode());
            return;
        }

        // check (overall/alt) scoring
        // scoring is special for IABs
        final boolean iab = AssessmentType.IAB.code().equals(assessment.getType().code());
        checkScoring(messageSink, prefix, iab, subjectAssessmentType.getOverallScoring(), assessment.getOverallScoring());
        if (assessment.getAltScorings() != null) {
            if (subject.getAltScores() == null) {
                messageSink.error(prefix + "alt scores not defined for subject {0}", subject.getCode());
            } else if (assessment.getAltScorings().size() != subject.getAltScores().size()) {
                messageSink.error(prefix + "number of alt scores ({0}) does not match subject ({1})",
                        assessment.getAltScorings().size(), subject.getAltScores().size());
            }

            if (subjectAssessmentType.getAltScoring() == null) {
                messageSink.error(prefix + "alt scoring is not defined for subject {0}", subject.getCode());
            } else {
                for (final Scoring scoring : assessment.getAltScorings()) {
                    checkScoring(messageSink, prefix, iab, subjectAssessmentType.getAltScoring(), scoring);
                }
            }
        }

        // TODO - item validation
    }

    private static void checkScoring(final MessageSink messageSink, final String prefix, final boolean iab,
                                     final org.opentestsystem.rdw.common.model.subject.Scoring subjectScoring,
                                     final org.opentestsystem.rdw.common.model.assessment.Scoring assessmentScoring) {

        // IAB specialness
        final int expectedLevelCount = iab ? 4 : subjectScoring.getPerformanceLevels().getPerformanceLevels().size();
        if (assessmentScoring.getLevelCount() != expectedLevelCount) {
            messageSink.error(prefix + "level count ({0}) does not match subject ({1})",
                    assessmentScoring.getLevelCount(), expectedLevelCount);
        }

        final Double minScore = subjectScoring.getMinScore();
        if (minScore != null && assessmentScoring.getMinScore() < minScore) {
            messageSink.error(prefix + "minimum score ({0}) less than subject minimum score ({1})",
                    assessmentScoring.getMinScore(), minScore);
        }

        final Double maxScore = subjectScoring.getMaxScore();
        if (maxScore != null && assessmentScoring.getMaxScore() > maxScore) {
            messageSink.error(prefix + "maximum score ({0}) greater than subject maximum score ({1})",
                    assessmentScoring.getMaxScore(), maxScore);
        }
    }


}
