package org.opentestsystem.rdw.ingest.validator.service;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import org.opentestsystem.rdw.common.model.assessment.Assessment;
import org.opentestsystem.rdw.common.model.assessment.AssessmentSerializationService;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectSerializationService;
import org.opentestsystem.rdw.ingest.validator.ApplicationConfiguration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;

/**
 * NOTE: when writing these tests, avoid creating test Assessments that couldn't result when
 * loading from CSV, where the serializer enforces "schema-like" requirements. Either load
 * from CSV (duh) or be diligent when building an Assessment.
 */
public class AssessmentCheckerTest {

    private final AssessmentSerializationService assessmentSerializationService = ApplicationConfiguration.assessmentSerializationService();
    private final SubjectSerializationService subjectSerializationService = ApplicationConfiguration.subjectSerializationService();
    private MessageCollector messageCollector;

    @Before
    public void createMessageCollector() {
        messageCollector = new MessageCollector();
    }

    @Test
    public void itShouldCheckForDuplicates() {
        final List<Assessment> assessments = loadAssessmentsFromResource("assessments.minimal.csv");
        // a cheap way to get duplicates
        assessments.addAll(loadAssessmentsFromResource("assessments.minimal.csv"));
        AssessmentChecker.checkAssessments(messageCollector, assessments, new ArrayList<>());
        assertThat(messageCollector.getMessages()).contains(
                "Error: duplicate assessment id GEO-GRADE-01-2018",
                "Error: duplicate assessment id GEO-GRADE-12-2018"
        );
    }

    @Test
    public void itShouldCheckForDuplicatesBySubjectGradeAndYear() {
        checkAssessmentResource("assessments.dups.csv", null);
        assertThat(messageCollector.getMessages()).contains(
                "Warning: duplicate assessment label/year GEO Grade 8/2018 may be confusing for users",
                "Error: multiple summatives found for GEO-08-2018",
                "Error: multiple ICAs found for GEO-08-2018"
        );
    }

    @Test
    public void itShouldCheckForDuplicateNamesAcrossSubjects() {
        checkAssessmentResource("assessments.dup-name.csv", null);
        assertThat(messageCollector.getMessages()).contains(
                "Error: duplicate assessment name GEO-ASMT across subjects [GEO, HIST]"
        );
    }

    @Test
    public void itShouldSilentlySkipSubjectValidationIfNoSubjects() {
        checkAssessmentResource("assessments.minimal.csv", null);
        assertThat(messageCollector.getMessages()).isEmpty();
    }

    @Test
    public void itShouldCheckForSubject() {
        checkAssessmentResource("assessments.minimal.csv", "ELPAC_subject.xml");
        assertThat(messageCollector.getMessages()).contains(
                "Warning: GEO-GRADE-01-2018: subject GEO not found; skipping subject validation"
        );
    }

    @Test
    public void itShouldCheckForSubjectAssessmentType() {
        checkAssessmentResource("assessments.ica.csv", "subject.minimal.xml");
        assertThat(messageCollector.getMessages()).contains(
                "Error: GEO-GRADE-01-2018: assessment type (ICA) not defined for subject GEO"
        );
    }

    @Test
    public void itShouldCheckScoring() {
        checkAssessmentResource("assessments.bad-score.csv", "subject.xml");
        assertThat(messageCollector.getMessages()).contains(
                "Error: GEO-GRADE-01-2018: invalid grade code 23",
                "Error: GEO-GRADE-01-2018: level count (3) does not match subject (4)",
                "Error: GEO-GRADE-01-2018: minimum score (100) less than subject minimum score (200)",
                "Error: GEO-GRADE-01-2018: maximum score (1,000) greater than subject maximum score (800)",
                "Error: GEO-GRADE-01-2018: number of alt scores (1) does not match subject (2)",
                "Error: GEO-GRADE-01-2018: level count (1) does not match subject (4)",
                "Error: GEO-GRADE-01-2018: minimum score (0) less than subject minimum score (1,150)"
        );
    }

    private void checkAssessmentResource(final String name, final String subject) {
        final List<Assessment> assessments = loadAssessmentsFromResource(name);
        final List<Subject> subjects = subject == null ? new ArrayList<>() : ImmutableList.of(loadSubjectFromResource(subject));
        AssessmentChecker.checkAssessments(messageCollector, assessments, subjects);
    }

    private List<Assessment> loadAssessmentsFromResource(final String name) {
        try (final InputStream is = this.getClass().getResourceAsStream("/" + name)) {
            return assessmentSerializationService.parse(is);
        } catch (final IOException e) {
            return fail("failed to load assessment resource " + name, e);
        }
    }

    private Subject loadSubjectFromResource(final String name) {
        try (final InputStream is = this.getClass().getResourceAsStream("/" + name)) {
            return subjectSerializationService.parseSubject(is);
        } catch (final IOException e) {
            return fail("failed to load subject resource " + name, e);
        }
    }
}
