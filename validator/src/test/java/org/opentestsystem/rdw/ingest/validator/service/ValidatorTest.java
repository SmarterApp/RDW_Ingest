package org.opentestsystem.rdw.ingest.validator.service;

import org.apache.commons.io.FileUtils;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import org.opentestsystem.rdw.ingest.validator.ApplicationConfiguration;

import static com.google.common.collect.ImmutableList.of;
import static org.assertj.core.api.Assertions.assertThat;

/**
 * Test the validator using real files.
 */
public class ValidatorTest {

    @Rule
    public TemporaryFolder testFolder = new TemporaryFolder();

    private Validator validator;
    private MessageCollector messageCollector;

    @Before
    public void createValidator() {
        messageCollector = new MessageCollector();
        validator = ApplicationConfiguration.validator();
    }

    @Test
    public void itShouldValidateELPAC() throws IOException {
        final String subjectFile = populateTestFile("ELPAC_subject.xml");
        final String asmtFile = populateTestFile("ELPAC.2018.csv");

        validator.validate(messageCollector, of(subjectFile), of(asmtFile));
        assertThat(messageCollector.getMessages()).isEmpty();
    }

    @Test
    public void itShouldValidateSB() throws IOException {
        final String elaFile = populateTestFile("ELA_subject.xml");
        final String mathFile = populateTestFile("Math_subject.xml");
        final String asmt2017 = populateTestFile("2017v3.csv");
        final String asmt2018 = populateTestFile("2018v3.csv");

        validator.validate(messageCollector, of(elaFile, mathFile), of(asmt2017, asmt2018));
        // the 2017 file has some duplicate labels, so ignore those
        assertThat(messageCollector.getMessages().stream()
                .filter(m -> !(m.contains("2017") && m.startsWith("Warning: duplicate assessment label")))).isEmpty();
    }

    private String populateTestFile(final String name) throws IOException {
        final File file = testFolder.newFile(name);
        try (final InputStream is = this.getClass().getResourceAsStream("/" + name)) {
            FileUtils.copyToFile(is, file);
        }
        return file.getPath();
    }
}
