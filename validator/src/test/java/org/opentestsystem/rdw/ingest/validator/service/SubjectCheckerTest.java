package org.opentestsystem.rdw.ingest.validator.service;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.List;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectSerializationService;
import org.opentestsystem.rdw.common.model.subject.XmlSubjectSerializationService;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;

/**
 * NOTE: when writing these tests, avoid creating test Subjects that couldn't result when loading
 * from XML, where the XSD is used to validate some basic schema requirements. Otherwise we'll
 * waste time making the validation code proof against stuff that can't happen in real life.
 */
public class SubjectCheckerTest {

    private final SubjectSerializationService subjectSerializationService = new XmlSubjectSerializationService();
    private MessageCollector messageCollector;

    @Before
    public void createMessageCollector() {
        messageCollector = new MessageCollector();
    }

    @Test
    public void itShouldCheckDuplicateCodesAndNames() {
        final List<Subject> subjects = ImmutableList.of(
            Subject.builder().code("GEO").name("Geology").assessmentTypes(Collections.emptyList()).build(),
            Subject.builder().code("GEO").name("Geography").assessmentTypes(Collections.emptyList()).build(),
            Subject.builder().code("ROCKS").name("Geology").assessmentTypes(Collections.emptyList()).build()
        );

        SubjectChecker.checkSubjects(messageCollector, subjects);
        assertThat(messageCollector.getMessages()).contains(
            "Error: duplicate subject code GEO",
            "Warning: duplicate subject name Geology may be confusing for users"
        );
    }

    @Test
    public void itShouldCheckMessageKeys() {
        checkSubjectResource("subject.bad-messages.xml");
        assertThat(messageCollector.getMessages()).contains(
                "Error: subject GEO: message keys must be unique",
                "Error: subject GEO: missing performance-info message for sum"
        );
    }

    @Test
    public void itShouldCheckOverallScoring() {
        checkSubjectResource("subject.minimal.xml");
        assertThat(messageCollector.getMessages()).contains(
                "Error: subject GEO: OverallScoring must have a name",
                "Warning: subject GEO: OverallScoring should have min/maxScore (it improves data validation)"
        );
    }

    @Test
    public void itShouldCheckIABs() {
        checkSubjectResource("subject.bad-iab.xml");
        assertThat(messageCollector.getMessages()).contains(
                "Error: subject GEO: IABs do not support a standard cutoff",
                "Error: subject GEO: IABs must have exactly 3 performance levels",
                "Error: subject GEO: IABs may not have AltScoring",
                "Error: subject GEO: IABs may not have ClaimScoring"
        );
    }

    @Test
    public void itShouldCheckMismatchedScoring() {
        checkSubjectResource("subject.mismatched-scoring.xml");
        assertThat(messageCollector.getMessages()).contains(
                "Error: subject GEO: AltScoring must have a name",
                "Error: subject GEO: AltScores required (at least one assessment type uses them)",
                "Warning: subject GEO: Claims specified but no assessment type uses them"
        );
    }

    @Test
    public void itShouldCheckDuplicateCodesAndOtherScorableIssues() {
        checkSubjectResource("subject.bad-codes.xml");
        assertThat(messageCollector.getMessages()).contains(
                "Error: subject GEO: duplicate alt/claim code R",
                "Error: subject GEO: duplicate target code M1 for claim R",
                "Error: subject GEO: icon does not start with \"fa-\" for R"
        );
    }

    @Test
    public void itShouldValidateELPAC() {
        checkSubjectResource("ELPAC_subject.xml");
        assertThat(messageCollector.getMessages()).isEmpty();
    }

    @Test
    public void itShouldValidateELA() {
        checkSubjectResource("ELA_subject.xml");
        assertThat(messageCollector.getMessages()).isEmpty();
    }

    @Test
    public void itShouldValidateMath() {
        checkSubjectResource("Math_subject.xml");
        assertThat(messageCollector.getMessages()).isEmpty();
    }


    private void checkSubjectResource(final String name) {
        final List<Subject> subjects = ImmutableList.of(
                loadSubjectFromResource(name)
        );
        SubjectChecker.checkSubjects(messageCollector, subjects);
    }

    private Subject loadSubjectFromResource(final String name) {
        try (final InputStream is = this.getClass().getResourceAsStream("/" + name)) {
            return subjectSerializationService.parseSubject(is);
        } catch (final IOException | IllegalArgumentException e) {
            return fail("failed to load subject resource " + name, e);
        }
    }
}
