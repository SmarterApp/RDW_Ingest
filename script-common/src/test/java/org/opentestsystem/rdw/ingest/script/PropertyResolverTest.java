package org.opentestsystem.rdw.ingest.script;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.Arrays;
import org.opentestsystem.rdw.ingest.script.impl.DefaultConfigurationCompiler;

import static java.util.Collections.emptyMap;
import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.ingest.script.ResourceType.SYSTEM_NODE;
import static org.opentestsystem.rdw.ingest.script.ResourceType.USER_NODE;
import static org.opentestsystem.rdw.ingest.script.util.TestUtils.loadStringFromResourceFile;

@RunWith(MockitoJUnitRunner.class)
public class PropertyResolverTest {
    private static final String PIPELINE_NAME = "My Test Pipeline";
    private static final String PIPELINE_VERSION = "1.0";
    private static final String SAFE_SCRIPT_CODE = "return 'transformed input'";
    private static final String MISSING_PROPERTY_SCRIPT_CODE = "cat.equals('cat'); " + SAFE_SCRIPT_CODE;

    private PipelineFactory pipelineFactory;
    private ScriptPipelineConfiguration config = new ScriptPipelineConfiguration();
    private VersionedResource userNode, systemNode;

    @Mock
    ScriptSource scriptSource;

    @Mock
    PropertyResolver propertyResolver;

    @Before
    public void setUp() throws Exception {
        when(propertyResolver.resolveProperty("cat")).thenReturn("cat");

        userNode = new VersionedResource("User Script", "1.0", USER_NODE);
        systemNode = new VersionedResource("System Script", "1.0", SYSTEM_NODE);

        PipelineDefinition pipelineDefinition = PipelineDefinition.builder()
                .name(PIPELINE_NAME)
                .version(PIPELINE_VERSION)
                .rollbackVersion("N/A")
                .nodeDefinitions(Arrays.asList(userNode, systemNode))
                .build();

        when(scriptSource.loadPipelineDefinition(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineDefinition);

        when(scriptSource.loadScriptBaseClass()).thenReturn(
                loadStringFromResourceFile("/scripts/DSLScriptBase.groovy"));

        ScriptCompiler scriptCompiler = new ScriptCompiler(config.groovyClassLoader(scriptSource));
        ConfigurationCompiler configurationCompiler = new DefaultConfigurationCompiler();

        pipelineFactory = config.pipelineFactory(
                scriptSource,
                scriptCompiler,
                configurationCompiler,
                propertyResolver,
                null);
    }

    @Test
    public void itShouldUsePropertyResolverInSystemScript() throws Exception {
        when(scriptSource.loadScript(systemNode)).thenReturn(
                new ScriptInfo(MISSING_PROPERTY_SCRIPT_CODE, emptyMap()));

        when(scriptSource.loadScript(userNode)).thenReturn(
                new ScriptInfo(SAFE_SCRIPT_CODE, emptyMap()));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        PipelineResults result = pipeline.run(null);
        assertThat(result.asString()).isEqualTo("transformed input");
    }

    @Test(expected = RuntimeException.class)
    public void itShouldNotUsePropertyResolverInUserScript() throws Exception {
        when(scriptSource.loadScript(any())).thenReturn(
                new ScriptInfo(MISSING_PROPERTY_SCRIPT_CODE, emptyMap()));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        pipeline.run(null);
    }
}
