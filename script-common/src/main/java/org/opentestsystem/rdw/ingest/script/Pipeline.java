package org.opentestsystem.rdw.ingest.script;

import groovy.lang.Script;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.script.security.SandboxSecurityManager;
import org.opentestsystem.rdw.ingest.script.util.ScriptUtils;

/**
 * A Pipeline is a series of precompiled scripts that run against input in order to
 * transform, filter, and validated it.
 */
public class Pipeline {
    private static final Logger logger = LoggerFactory.getLogger(Pipeline.class);

    private static final int SANDBOX_RETRIES = 2;
    private static final int SANDBOX_THREADS = 2;
    private static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(SANDBOX_THREADS);

    private final PipelineDefinition pipelineDefinition;
    private final List<ScriptDefinition> scriptDefinitions;
    private final SandboxSecurityManager sandboxSecurityManager;

    public Pipeline(final PipelineDefinition pipelineDefinition,
                    final List<ScriptDefinition> scriptDefinitions,
                    final SandboxSecurityManager sandboxSecurityManager) {
        this.pipelineDefinition = pipelineDefinition;
        this.scriptDefinitions = scriptDefinitions;

        if (hasUserNodes()) {
            this.sandboxSecurityManager = sandboxSecurityManager;
            System.setSecurityManager(sandboxSecurityManager);
        } else {
            this.sandboxSecurityManager = null;
        }
    }

    public PipelineDefinition getPipelineDefinition() {
        return pipelineDefinition;
    }

    public PipelineResults run(final Object input)  {

        Object lastValidTransformation = input;

        for (final ScriptDefinition sd : scriptDefinitions) {
            try {
                final PipelineScript script = sd.getInstance(lastValidTransformation);

                final Object results = runScript(script, sd.getType());

                if (results == null) {
                    // (A script always returns the value of its last expression, so this is unlikely to happen.)
                    throw new RuntimeException("Script " + sd.toString() + " returned null results.");
                }

                lastValidTransformation = results;
            } catch (ImportException ie) {
                ie.fillInStackTrace();
                throw ie;
            } catch (Exception e) {
                logger.warn("Pipeline runtime error", e);
                throw new RuntimeException("Runtime error in script: " + sd + ": " + e.getMessage(), e);
            }
        }

        return new PipelineResults(lastValidTransformation);
    }

    private Object runScript(final Script script, final ResourceType type) {
        if (type == ResourceType.SYSTEM_NODE || sandboxSecurityManager == null) {
            return script.run();
        } else {
            return runInSandbox(script, SANDBOX_RETRIES);
        }
    }

    private Object runInSandbox(final Script script, final int retries) {
        final Callable<Object> callable = () -> {
            sandboxSecurityManager.enable();
            return script.run();
        };

        final Future<Object> future = THREAD_POOL.submit(callable);

        try {
            return future.get();
        } catch (InterruptedException e) {
            if (retries > 0) {
                return runInSandbox(script, retries - 1);
            } else {
                throw new RuntimeException("Too many interrupted exceptions", e);
            }
        } catch (ExecutionException e) {
            // Unwrap the cause and rethrow.
            Throwable cause = e.getCause();
            if (cause == null) {
                throw new RuntimeException(e.getMessage(), e);
            }

            // Sometimes the AccessControlException gets wrapped up in an ExceptionInInitializerException
            if (cause instanceof ExceptionInInitializerError) {
                Throwable rootCause = ((ExceptionInInitializerError)cause).getException();
                if (rootCause != null) {
                    cause = rootCause;
                }
            }

            final Optional<Object> lineNumber = getScriptLineNumber(cause);
            final String message = lineNumber.isPresent() ?
                    "User script error at line " + lineNumber.get() + ": " + cause.getMessage() :
                    cause.getMessage();

            throw new RuntimeException(message, cause);
        }
    }

    // Digs out script line number if possible
    private Optional<Object> getScriptLineNumber(final Throwable t) {
        Map<String,Object> map = ScriptUtils.extractScriptInfo(t);

        if (map.get("lineNumber") != null) {
            return Optional.of(map.get("lineNumber"));
        }

        return Optional.empty();
    }

    private boolean hasUserNodes() {
        return scriptDefinitions.stream()
                .anyMatch(sd -> sd.getType() == ResourceType.USER_NODE);
    }
}
