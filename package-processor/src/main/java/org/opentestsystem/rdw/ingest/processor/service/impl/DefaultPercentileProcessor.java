package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.repository.PercentileRepository;
import org.opentestsystem.rdw.ingest.processor.service.PercentileProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;

@Service
class DefaultPercentileProcessor implements PercentileProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultPercentileProcessor.class);
    private final PercentileRepository repository;
    private final PercentileParser parser;

    @Autowired
    public DefaultPercentileProcessor(final PercentileRepository repository, final PercentileParser parser) {
        this.repository = repository;
        this.parser = parser;
    }

    @Override
    public String process(final byte[] payload, final long importId) {

        final DataElementErrorCollector elementErrorCollector = new DataElementErrorCollector();
        final List<Percentile> percentiles = parser.parse(payload, elementErrorCollector);

        // Do not persist any percentiles if there are any errors in the payload.
        // todo: change to exception
        if (!elementErrorCollector.isEmpty()) throw new ImportException(BAD_DATA, elementErrorCollector.toJson());

        final List<Percentile> newPercentiles = new ArrayList<>();
        final List<Percentile> existPercentiles = new ArrayList<>();
        final List<Percentile> overlapPercentiles = new ArrayList<>();

        for (Percentile percentile : percentiles) {
            final Integer existPercentileId = repository.findIdByKey(percentile.getAssessmentId(), percentile.getStartDate(), percentile.getEndDate());
            if (existPercentileId == null) {
                final List<Integer> overlapPercentileIds = repository.findIdsByDateOverlap(percentile.getAssessmentId(), percentile.getStartDate(), percentile.getEndDate());
                if (overlapPercentileIds.size() > 0) {
                    overlapPercentiles.add(percentile);
                } else {
                    newPercentiles.add(percentile);
                }
            } else {
                existPercentiles.add(new Percentile.Builder()
                        .id(existPercentileId)
                        .assessmentId(percentile.getAssessmentId())
                        .startDate(percentile.getStartDate())
                        .endDate(percentile.getEndDate())
                        .count(percentile.getCount())
                        .mean(percentile.getMean())
                        .standardDeviation(percentile.getStandardDeviation())
                        .minScore(percentile.getMinScore())
                        .maxScore(percentile.getMaxScore())
                        .build());
            }
        }

        if (overlapPercentiles.size() == 0) {
            if (newPercentiles.size() > 0) repository.create(newPercentiles, importId);
            if (existPercentiles.size() > 0) repository.update(existPercentiles, importId);
            return "Percentiles created: " + newPercentiles.size() + " updated: " + existPercentiles.size();
        } else {
            return "Percentiles overlapped: " + overlapPercentiles.size();
        }
    }

}