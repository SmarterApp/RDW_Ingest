package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.List;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.ScoreType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectScore;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectScoreRepository;

import static java.sql.Statement.SUCCESS_NO_INFO;

/**
 * JDBC implementation of a SubjectScoreRepository
 */
@Repository
class JdbcSubjectScoreRepository implements SubjectScoreRepository {

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.subject.score.findBySubjectId}")
    private String sqlFindBySubject;

    @Value("${sql.subject.score.findBySubjectIdAsmtTypeIdScoreTypeId}")
    private String sqlFindBySubjectAsmtTypeIdScoreTypeId;

    @Value("${sql.subject.score.insert}")
    private String sqlCreate;

    @Value("${sql.subject.score.update}")
    private String sqlUpdate;

    @Value("${sql.subject.score.delete}")
    private String sqlDelete;

    @Value("${sql.subject.score.isReferenced}")
    private String sqlIsReferenced;

    @Autowired
    public JdbcSubjectScoreRepository(final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public List<WarehouseSubjectScore> findBySubjectId(final int subjectId) {
        return template.query(sqlFindBySubject,
                new MapSqlParameterSource("subject_id", subjectId),
                (row, rowNum) -> mapRow(row));
    }

    @Override
    public List<WarehouseSubjectScore> findBySubjectIdAndAsmtTypeIdAndScoreTypeId(
            final int subjectId, final int asmtTypeId, final int scoreTypeId) {
        return template.query(sqlFindBySubjectAsmtTypeIdScoreTypeId,
                new MapSqlParameterSource()
                    .addValue("subject_id", subjectId)
                    .addValue("asmt_type_id", asmtTypeId)
                    .addValue("score_type_id", scoreTypeId),
                (row, rowNum) -> mapRow(row));
    }

    @Override
    public void create(final int subjectId, final Collection<WarehouseSubjectScore> scores) {
        if (scores.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = scores.stream()
                .map(s -> new MapSqlParameterSource()
                        .addValue("subject_id", subjectId)
                        .addValue("asmt_type_id", s.getAssessmentType().id())
                        .addValue("score_type_id", s.getScoreType().id())
                        .addValue("code", s.getCode())
                        .addValue("display_order", s.getDisplayOrder())
                        .addValue("data_order", s.getDataOrder()))
                .toArray(MapSqlParameterSource[]::new);

        final int[] insertCounts = template.batchUpdate(sqlCreate, batchParameters);

        for (int i = 0; i < insertCounts.length; i++) {
            if (insertCounts[i] != 1 && insertCounts[i] != SUCCESS_NO_INFO) {
                final SqlParameterSource params = batchParameters[i];
                throw new IllegalArgumentException("Unable to create subject score: subject: " + subjectId +
                        ", assessment type: " + params.getValue("asmt_type_id") +
                        ", score type: " + params.getValue("score_type_id") +
                        ", code: " + params.getValue("code"));
            }
        }
    }

    @Override
    public void update(final Collection<WarehouseSubjectScore> scores) {
        if (scores.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = scores.stream()
                .map(s -> new MapSqlParameterSource()
                        .addValue("id", s.getId())
                        .addValue("display_order", s.getDisplayOrder())
                        .addValue("data_order", s.getDataOrder()))
                .toArray(MapSqlParameterSource[]::new);

        final int[] updateCounts = template.batchUpdate(sqlUpdate, batchParameters);

        for (int i = 0; i < updateCounts.length; i++) {
            if (updateCounts[i] != 1 && updateCounts[i] != SUCCESS_NO_INFO) {
                throw new IllegalArgumentException("Unable to update subject score: " + batchParameters[i].getValue("id") +
                        ", display order: " + batchParameters[i].getValue("display_order") +
                        ", data order: " + batchParameters[i].getValue("data_order"));
            }
        }
    }

    @Override
    public void delete(final Collection<Integer> scoreIds) {
        if (scoreIds.isEmpty()) return;

        template.update(sqlDelete, new MapSqlParameterSource("ids", scoreIds));
    }

    @Override
    public Integer isReferenced(final Collection<Integer> scoreIds) {
        if (scoreIds.isEmpty()) return null;

        try {
            return template.queryForObject(sqlIsReferenced, new MapSqlParameterSource("ids", scoreIds), Integer.class);
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }

    private static WarehouseSubjectScore mapRow(final ResultSet row) throws SQLException {
        return WarehouseSubjectScore.builder()
                .id(row.getInt("id"))
                .assessmentType(AssessmentType.valueOf(row.getInt("asmt_type_id")))
                .scoreType(ScoreType.valueOf(row.getInt("score_type_id")))
                .code(row.getString("code"))
                .displayOrder(row.getInt("display_order"))
                .dataOrder(row.getInt("data_order"))
                .build();
    }
}
