package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.subject.Claim;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectScore;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectAssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectScoreRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectService;

import static com.google.common.collect.Lists.newArrayList;

/**
 * Default implementation of a SubjectService.
 * <p>
 * I've started an experiment to encapsulate all the repository activity in this one service.
 * Think ORM for Subjects. So far, i've pulled in the SubjectAssessmentType and SubjectScore
 * handling to see how it plays out.
 * </p>
 */
@Service
class DefaultSubjectService implements SubjectService {

    private final SubjectRepository subjectRepository;
    private final SubjectAssessmentTypeRepository subjectAssessmentTypeRepository;
    private final SubjectScoreRepository subjectScoreRepository;

    @Autowired
    public DefaultSubjectService(final SubjectRepository subjectRepository,
                                 final SubjectAssessmentTypeRepository subjectAssessmentTypeRepository,
                                 final SubjectScoreRepository subjectScoreRepository) {
        this.subjectRepository = subjectRepository;
        this.subjectAssessmentTypeRepository = subjectAssessmentTypeRepository;
        this.subjectScoreRepository = subjectScoreRepository;
    }

    @Override
    public void upsert(final Subject subject, final long importId) {
        final String code = subject.getCode();
        final Integer existingId = subjectRepository.findIdByCode(subject.getCode());
        if (existingId != null) {
            subjectRepository.update(code, importId);
            updateSubjectAssessmentTypes(existingId, subject);
            updateSubjectScores(existingId, subject);
        } else {
            final Integer id = subjectRepository.create(code, importId);
            createSubjectAssessmentTypes(id, subject);
            createSubjectScores(id, subject);
        }
    }

    private void createSubjectAssessmentTypes(final int subjectId, final Subject subject) {
        for (final WarehouseSubjectAssessmentType type : subject.getAssessmentTypes().stream()
                .map(t -> WarehouseSubjectAssessmentType.builder().copy(t).build()).collect(Collectors.toList())) {
            subjectAssessmentTypeRepository.create(subjectId, type);
        }
    }

    void updateSubjectAssessmentTypes(final int subjectId, final Subject subject) {
        // Fetch the existing subject assessment types
        final Map<AssessmentType, WarehouseSubjectAssessmentType> existingTypes = subjectAssessmentTypeRepository
                .findBySubjectId(subjectId).stream()
                .collect(Collectors.toMap(WarehouseSubjectAssessmentType::getAssessmentType, type -> type));

        // Update or insert each submitted subject assessment type
        for (final WarehouseSubjectAssessmentType submitted : subject.getAssessmentTypes().stream()
                .map(t -> WarehouseSubjectAssessmentType.builder().copy(t).build()).collect(Collectors.toList())) {
            final WarehouseSubjectAssessmentType existing = existingTypes.remove(submitted.getAssessmentType());
            if (existing == null) {
                subjectAssessmentTypeRepository.create(subjectId, submitted);
            } else if (!submitted.equals(existing)) {
                if (subjectAssessmentTypeRepository.isReferenced(subjectId, existing.getAssessmentType())) {
                    throw new IllegalArgumentException("Unable to update subject assessment type due to existing assessments for subject: "
                        + subject.getCode() + " assessment type: " + existing.getAssessmentType());
                }
                subjectAssessmentTypeRepository.update(subjectId, submitted);
            }
        }

        // Delete definitions that were not submitted
        for (final WarehouseSubjectAssessmentType deleted : existingTypes.values()) {
            if (subjectAssessmentTypeRepository.isReferenced(subjectId, deleted.getAssessmentType())) {
                throw new IllegalArgumentException("Unable to delete subject assessment type due to existing assessments for subject: " +
                        subject.getCode() + " assessment type: " + deleted.getAssessmentType());
            }
            subjectAssessmentTypeRepository.delete(subjectId, deleted.getAssessmentType());
        }
    }

    private void createSubjectScores(final int subjectId, final Subject subject) {
        subjectScoreRepository.create(subjectId, extractWarehouseSubjectScores(subject));
    }

    void updateSubjectScores(final int subjectId, final Subject subject) {
        final Map<Integer, WarehouseSubjectScore> existingScores = subjectScoreRepository.findBySubjectId(subjectId)
                .stream().collect(Collectors.toMap(DefaultSubjectService::key, s -> s));

        final List<WarehouseSubjectScore> newScores = newArrayList();
        final List<WarehouseSubjectScore> updatedScores = newArrayList();
        final List<Integer> ids = newArrayList();  // collect existing ids that are data-order changed

        final List<WarehouseSubjectScore> submittedScores = extractWarehouseSubjectScores(subject);
        for (final WarehouseSubjectScore submitted : submittedScores) {
            final WarehouseSubjectScore existing = existingScores.remove(key(submitted));
            if (existing == null) {
                newScores.add(submitted);
            } else if (!submitted.getDataOrder().equals(existing.getDataOrder())
                    || !submitted.getDisplayOrder().equals(existing.getDisplayOrder())) {
                updatedScores.add(existing.copy()
                    .dataOrder(submitted.getDataOrder()).displayOrder(submitted.getDisplayOrder()).build());

                if (!submitted.getDataOrder().equals(existing.getDataOrder())) {
                    ids.add(existing.getId());
                }
            }
        }

        // any left-over scores need to be deleted
        final List<Integer> deletedIds = existingScores.values().stream()
                .map(WarehouseSubjectScore::getId).collect(Collectors.toList());

        // check that any deleted or modified (data-order) scores are not referenced before continuing
        ids.addAll(deletedIds);
        if (subjectScoreRepository.isReferenced(ids) != null) {
            throw new IllegalArgumentException("Unable to delete or change existing subject score for subject: " +
                    subjectId + " due to being referenced by an existing assessment");
        }

        if (!deletedIds.isEmpty()) subjectScoreRepository.delete(deletedIds);
        if (!updatedScores.isEmpty()) subjectScoreRepository.update(updatedScores);
        if (!newScores.isEmpty()) subjectScoreRepository.create(subjectId, newScores);
    }

    private static int key(final WarehouseSubjectScore score) {
        // subject score records are unique based on subject + asmt-type + score-type + code
        // we find by subject, so the other three need to be combined for the unique key
        return Objects.hash(score.getAssessmentType(), score.getScoreType(), score.getCode());
    }

    /**
     * Helper to extract the necessary warehouse subject score records from a subject.
     * This is done by combining the subject assessment types with the alt-scores / claims
     * appropriately. If an assessment type specifies claim scoring then combine that assessment
     * type with the scorable claim details. Likewise, if an assessment type specifies alt scoring
     * then combine that assessment type with the alt-score details.
     *
     * @param subject subject to introspect
     * @return list of warehouse subject scores for the subject
     */
    private static List<WarehouseSubjectScore> extractWarehouseSubjectScores(final Subject subject) {
        final List<WarehouseSubjectScore> scores = newArrayList();
        if (subject.getAssessmentTypes() == null) return scores;

        if (subject.getClaims() != null) {
            scores.addAll(cross(
                    subject.getAssessmentTypes().stream()
                            .filter(t -> t.getClaimScoring() != null && t.getClaimScoring().getPerformanceLevels() != null)
                            .map(SubjectAssessmentType::getAssessmentType),
                    subject.getClaims().stream()
                            .filter(Claim::isScorable),
                    (asmtType, claim) -> WarehouseSubjectScore.builder().copy(claim).assessmentType(asmtType).build()));
        }
        if (subject.getAltScores() != null) {
            scores.addAll(cross(
                    subject.getAssessmentTypes().stream()
                            .filter(t -> t.getAltScoring() != null && t.getAltScoring().getPerformanceLevels() != null)
                            .map(SubjectAssessmentType::getAssessmentType),
                    subject.getAltScores().stream(),
                    (asmtType, alt) -> WarehouseSubjectScore.builder().copy(alt).assessmentType(asmtType).build()));
        }
        return scores;
    }

    // not particularly elegant or stream-y but it works ...
    static <A, B, R> List<R> cross(final Stream<A> streamA, final Stream<B> streamB,
                                   final BiFunction<? super A, ? super B, R> function) {

        final List<R> result = newArrayList();

        final List<A> As = streamA.collect(Collectors.toList());
        final List<B> Bs = streamB.collect(Collectors.toList());
        for (final A a : As) {
            for (final B b : Bs) {
                result.add(function.apply(a, b));
            }
        }

        return result;
    }

}
