package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.processor.repository.SubjectTranslationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Collection;
import java.util.Map;

import static com.google.common.collect.Maps.newHashMap;

/**
 * JDBC implementation of a SubjectTranslationRepository
 */
@Repository
class JdbcSubjectTranslationRepository implements SubjectTranslationRepository {

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.subjectTranslation.findBySubject}")
    private String sqlFindBySubject;

    @Value("${sql.subjectTranslation.insert}")
    private String sqlCreate;

    @Value("${sql.subjectTranslation.update}")
    private String sqlUpdate;

    @Value("${sql.subjectTranslation.delete}")
    private String sqlDelete;

    @Autowired
    public JdbcSubjectTranslationRepository(final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public Map<String, String> findBySubject(final String subjectCode) {
        final Map<String, String> translations = newHashMap();
        template.query(sqlFindBySubject,
                new MapSqlParameterSource("subject_code", subjectCode),
                (row) -> {
                    translations.put(row.getString("label_code"), row.getString("label"));
                });
        return translations;
    }

    @Override
    public void create(final String subjectCode, final Map<String, String> messages) {
        if (messages.isEmpty()) return;

        final MapSqlParameterSource[] sources =  messages.entrySet().stream()
                .map(message -> new MapSqlParameterSource("subject_code", subjectCode)
                        .addValue("label_code", message.getKey())
                        .addValue("label", message.getValue()))
                .toArray(MapSqlParameterSource[]::new);

        final int[] insertCounts = template.batchUpdate(sqlCreate, sources);

        for (int i = 0; i < insertCounts.length; i++) {
            if (insertCounts[i] != 1) {
                throw new IllegalArgumentException("Failed to create message for subject: " + subjectCode +
                        " key: " + sources[i].getValue("label_code") +
                        " value: " + sources[i].getValue("label"));
            }
        }
    }

    @Override
    public void update(final String subjectCode, final Map<String, String> messages) {
        if (messages.isEmpty()) return;

        final MapSqlParameterSource[] sources =  messages.entrySet().stream()
                .map(message -> new MapSqlParameterSource("subject_code", subjectCode)
                        .addValue("label_code", message.getKey())
                        .addValue("label", message.getValue()))
                .toArray(MapSqlParameterSource[]::new);

        final int[] updateCounts = template.batchUpdate(sqlUpdate, sources);

        for (int i = 0; i < updateCounts.length; i++) {
            if (updateCounts[i] != 1) {
                throw new IllegalArgumentException("Failed to update message for subject: " + subjectCode +
                        " key: " + sources[i].getValue("label_code") +
                        " value: " + sources[i].getValue("label"));
            }
        }
    }

    @Override
    public void delete(final String subjectCode, final Collection<String> messageKeys) {
        if (messageKeys.isEmpty()) return;

        template.update(sqlDelete,
                new MapSqlParameterSource("subject_code", subjectCode)
                        .addValue("label_codes", messageKeys));
    }
}
