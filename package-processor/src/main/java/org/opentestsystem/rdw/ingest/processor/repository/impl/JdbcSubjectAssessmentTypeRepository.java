package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.ScoreType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentScoring;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectAssessmentTypeRepository;

import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.common.util.JdbcUtil.getNullable;

/**
 * JDBC-backed implementation of a SubjectAssessmentTypeRepository
 */
@Repository
class JdbcSubjectAssessmentTypeRepository implements SubjectAssessmentTypeRepository {

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.subject.assessmentType.findBySubjectId}")
    private String sqlFindBySubjectId;

    @Value("${sql.subject.assessmentType.create}")
    private String sqlCreateAssessmentType;

    @Value("${sql.subject.assessmentType.createScoring}")
    private String sqlCreateAssessmentScoring;

    @Value("${sql.subject.assessmentType.delete}")
    private String sqlDeleteAssessmentType;

    @Value("${sql.subject.assessmentType.isReferenced}")
    private String sqlAssessmentTypeIsReferenced;

    @Autowired
    public JdbcSubjectAssessmentTypeRepository(final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public List<WarehouseSubjectAssessmentType> findBySubjectId(final int subjectId) {
        // query returns multiple rows, one for each asmt scoring
        // so we need builders to hold state across rows
        final Map<AssessmentType, WarehouseSubjectAssessmentType.Builder> builders = newHashMap();

        template.query(sqlFindBySubjectId,
                new MapSqlParameterSource().addValue("subject_id", subjectId),
                rs -> {
                    final AssessmentType asmtType = AssessmentType.valueOf(rs.getInt("asmt_type_id"));
                    final WarehouseSubjectAssessmentType.Builder builder =
                            builders.computeIfAbsent(asmtType, assessmentType -> WarehouseSubjectAssessmentType.builder());
                    builder.assessmentType(AssessmentType.valueOf(rs.getInt("asmt_type_id")))
                           .targetReport(rs.getBoolean("target_report"))
                           .printedReport(rs.getBoolean("printed_report"));
                    final Integer scoreTypeId = getNullable(rs, rs.getInt("score_type_id"));
                    if (scoreTypeId != null) {
                        builder.scoring(WarehouseSubjectAssessmentScoring.builder()
                            .type(ScoreType.valueOf(scoreTypeId))
                            .minScore(getNullable(rs, rs.getDouble("min_score")))
                            .maxScore(getNullable(rs, rs.getDouble("max_score")))
                            .performanceLevelCount(rs.getInt("performance_level_count"))
                            .performanceLevelCutoff(getNullable(rs, rs.getInt("performance_level_standard_cutoff")))
                            .build());
                    }
                });

        return builders.values().stream().map(WarehouseSubjectAssessmentType.Builder::build).collect(Collectors.toList());
    }

    @Override
    public WarehouseSubjectAssessmentType findBySubjectIdAndAsmtTypeId(final int subjectId, final int asmtTypeId) {
        // load them all for the subject, and pull out the matching asmt type
        // TODO - add a specific query for this
        return findBySubjectId(subjectId).stream()
                .filter(t -> t.getAssessmentType().id() == asmtTypeId)
                .findFirst().orElse(null);
    }

    @Override
    public WarehouseSubjectAssessmentType create(final int subjectId, final WarehouseSubjectAssessmentType type) {
        int insertCount = 0;
        try {
            insertCount = template.update(sqlCreateAssessmentType, paramsFor(type).addValue("subject_id", subjectId));
        } catch (final DataIntegrityViolationException e) {
            // let this one fall through so the IAE is thrown
        }
        if (insertCount != 1) {
            throw new IllegalArgumentException("Failed to create WarehouseSubjectAssessmentType for subject: " + subjectId + " assessment type: " + type.getAssessmentType());
        }

        final List<WarehouseSubjectAssessmentScoring> scorings = type.getScorings();
        if (scorings != null && !scorings.isEmpty()) {
            final SqlParameterSource[] params = scorings.stream()
                    .map(s -> paramsFor(s).addValue("subject_id", subjectId).addValue("asmt_type_id", type.getAssessmentType().id()))
                    .toArray(SqlParameterSource[]::new);
            template.batchUpdate(sqlCreateAssessmentScoring, params);
        }

        return type;
    }

    @Override
    public WarehouseSubjectAssessmentType update(final int subjectId, final WarehouseSubjectAssessmentType type) {
        // there are no auto ids in the subject_asmt_type and subject_asmt_scoring tables
        // so we can just delete and insert to avoid any update logic ...
        delete(subjectId, type.getAssessmentType());
        return create(subjectId, type);
    }

    @Override
    public void delete(final int subjectId, final AssessmentType asmtType) {
        template.update(sqlDeleteAssessmentType,
                new MapSqlParameterSource()
                        .addValue("subject_id", subjectId)
                        .addValue("asmt_type_id", asmtType.id())
        );
    }

    @Override
    public boolean isReferenced(final int subjectId, final AssessmentType asmtType) {
        return template.queryForObject(sqlAssessmentTypeIsReferenced,
                new MapSqlParameterSource()
                        .addValue("subject_id", subjectId)
                        .addValue("asmt_type_id", asmtType.id()),
                Boolean.class
        );
    }

    private static MapSqlParameterSource paramsFor(final WarehouseSubjectAssessmentType type) {
        return new MapSqlParameterSource()
                .addValue("asmt_type_id", type.getAssessmentType().id())
                .addValue("target_report", type.isTargetReport())
                .addValue("printed_report", type.isPrintedReport());
    }

    private static MapSqlParameterSource paramsFor(final WarehouseSubjectAssessmentScoring scoring) {
        return new MapSqlParameterSource()
                .addValue("score_type_id", scoring.getType().id())
                .addValue("min_score", scoring.getMinScore())
                .addValue("max_score", scoring.getMaxScore())
                .addValue("performance_level_count", scoring.getPerformanceLevelCount())
                .addValue("performance_level_standard_cutoff", scoring.getPerformanceLevelStandardCutoff());
    }
}
