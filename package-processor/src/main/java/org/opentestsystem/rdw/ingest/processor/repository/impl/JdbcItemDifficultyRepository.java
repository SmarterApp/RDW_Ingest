package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseItemDifficulty;
import org.opentestsystem.rdw.ingest.processor.repository.ItemDifficultyRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

/**
 * JDBC implementation of an ItemDifficultyRepository
 */
@Repository
class JdbcItemDifficultyRepository implements ItemDifficultyRepository {

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.itemDifficulty.findBySubject}")
    private String sqlFindBySubject;

    @Value("${sql.itemDifficulty.insert}")
    private String sqlCreate;

    @Value("${sql.itemDifficulty.delete}")
    private String sqlDelete;

    @Value("${sql.itemDifficulty.hasItems}")
    private String sqlHasItems;

    @Value("${sql.itemDifficulty.update}")
    private String sqlUpdate;

    @Autowired
    public JdbcItemDifficultyRepository(final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public Collection<WarehouseItemDifficulty> findBySubject(final String subjectCode) {
        return template.query(sqlFindBySubject,
                new MapSqlParameterSource("subject_code", subjectCode),
                (row, rowNum) -> WarehouseItemDifficulty.builder()
                        .id(row.getInt("id"))
                        .gradeCode(row.getString("code"))
                        .difficultLowEnd(row.getFloat("difficult_low_end"))
                        .moderateLowEnd(row.getFloat("moderate_low_end"))
                        .build());
    }

    @Override
    public void create(final String subjectCode, final Collection<WarehouseItemDifficulty> difficulties) {
        if (difficulties.isEmpty()) return;

        final List<WarehouseItemDifficulty> difficultyList = ImmutableList.copyOf(difficulties);
        final int[] insertCounts = template.batchUpdate(sqlCreate, difficultyList.stream()
                .map(difficulty -> new MapSqlParameterSource("subject_code", subjectCode)
                        .addValue("grade_code", difficulty.getGradeCode())
                        .addValue("moderate_low_end", difficulty.getModerateLowEnd())
                        .addValue("difficult_low_end", difficulty.getDifficultLowEnd()))
                .collect(Collectors.toList())
                .toArray(new MapSqlParameterSource[0]));

        for (int i = 0; i < insertCounts.length; i++) {
            if (insertCounts[i] != 1) {
                final WarehouseItemDifficulty failed = difficultyList.get(i);
                throw new IllegalArgumentException("Unable to create item difficulty cuts for grade: " + failed.getGradeCode() +
                        " subject: " + subjectCode);
            }
        }
    }

    @Override
    public void delete(final Collection<Integer> difficultyIds) {
        if (difficultyIds.isEmpty()) return;

        template.update(sqlDelete, new MapSqlParameterSource("difficulty_ids", difficultyIds));
    }

    @Override
    public Integer hasItems(final Collection<Integer> targetIds) {
        if (targetIds.isEmpty()) return null;

        try {
            return template.queryForObject(sqlHasItems,
                    new MapSqlParameterSource("difficulty_ids", targetIds),
                    Integer.class);
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }

    @Override
    public void update(final Collection<WarehouseItemDifficulty> difficulties) {
        if (difficulties.isEmpty()) return;

        final List<WarehouseItemDifficulty> difficultyList = ImmutableList.copyOf(difficulties);
        final int[] updateCounts = template.batchUpdate(sqlUpdate, difficultyList.stream()
                .map(difficulty -> new MapSqlParameterSource("id", difficulty.getId())
                        .addValue("moderate_low_end", difficulty.getModerateLowEnd())
                        .addValue("difficult_low_end", difficulty.getDifficultLowEnd()))
                .collect(Collectors.toList())
                .toArray(new MapSqlParameterSource[0]));

        for (int i = 0; i < updateCounts.length; i++) {
            if (updateCounts[i] != 1) {
                final WarehouseItemDifficulty failed = difficultyList.get(i);
                throw new IllegalArgumentException("Unable to update item difficulty cuts for id: " + failed.getId() +
                        " moderate_low_end: " + failed.getModerateLowEnd() +
                        " difficult_low_end: " + failed.getDifficultLowEnd());
            }
        }
    }
}
