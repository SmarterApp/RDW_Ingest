package org.opentestsystem.rdw.ingest.processor.service.impl.validator;

import org.opentestsystem.rdw.common.model.subject.PerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevels;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.common.util.LocationAwareErrorCollector;
import org.opentestsystem.rdw.ingest.processor.service.SubjectValidator;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import static org.opentestsystem.rdw.common.model.AssessmentBoundaries.MaxPerformanceLevels;

/**
 * This validator ensures that subject {@link PerformanceLevels}
 * are sequential and that the performance cutoff, if present, is valid.
 */
@Component
class PerformanceLevelValidator implements SubjectValidator {

    @Override
    public void validate(final LocationAwareErrorCollector context, final Subject subject) {
        for (final SubjectAssessmentType assessmentType : subject.getAssessmentTypes()) {
            context.push("AssessmentType", assessmentType.getCode());
            validatePerformanceLevels(context, assessmentType.getPerformanceLevels());

            if (assessmentType.getClaimScoring() != null) {
                context.push("ClaimScoring");
                validatePerformanceLevels(context, assessmentType.getClaimScoring().getPerformanceLevels());
                context.pop();
            }
            context.pop();
        }
    }

    private void validatePerformanceLevels(final LocationAwareErrorCollector context,
                                                                     final PerformanceLevels performanceLevels) {
        final List<Integer> levels = performanceLevels.getPerformanceLevels().stream()
                .map(PerformanceLevel::getLevel)
                .collect(Collectors.toList());
        Collections.sort(levels);

        if (levels.get(0) != 1) {
            context.failure("Performance levels must start at level 1");
        }

        for (int i=0; i<levels.size(); i++) {
            if (i == 0) continue;
            if (levels.get(i) != (levels.get(i - 1) + 1)) {
                context.failure("Performance levels must be continuous (1, 2, 3, etc)");
                break;
            }
        }

        if (performanceLevels.getStandardCutoff() != null) {
            if (!levels.contains(performanceLevels.getStandardCutoff())) {
                context.failure("Performance level cutoff: " + performanceLevels.getStandardCutoff() + " must reference an existing performance level");
            }
        }

        if (performanceLevels.getPerformanceLevels().size() > MaxPerformanceLevels) {
            context.failure("A maximum of " + MaxPerformanceLevels + " performance levels are supported, but found: " + performanceLevels.getPerformanceLevels().size());
        }
    }
}
