package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.Iterables;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.repository.StudentRepository;
import org.opentestsystem.rdw.utils.DataElementErrorCollector;
import org.opentestsystem.rdw.utils.ParserHelper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.utils.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.utils.ParserHelper.toLocalDateOrNull;

@Service
class DefaultStudentParser implements StudentParser {
    private static final Logger logger = LoggerFactory.getLogger(DefaultStudentParser.class);

    private static final String SSID  = "SSID";
    private static final String LastOrSurname = "LastOrSurname";
    private static final String FirstName = "FirstName";
    private static final String MiddleName = "MiddleName";
    private static final String Gender = "Sex";
    private static final String FirstEntryIntoUSSchool = "FirstEntryDateIntoUSSchool";
    private static final String LepEntryDate = "LimitedEnglishProficiencyEntryDate";
    private static final String LepExitDate = "LEPExitDate";
    private static final String Birthdate = "Birthdate";
    private static final String SchoolId = "ResponsibleSchoolIdentifier";
    private static final String InfoUpdate = "InfoUpdate";

    // TODO: which column does alias name come from?
    private static final String AliasName = "UNKNOWN";

    private final StudentRepository studentRepository;
    private final SchoolRepository schoolRepository;
    private final GenderRepository genderRepository;

    @Autowired
    public DefaultStudentParser(
        final StudentRepository studentRepository,
        final SchoolRepository schoolRepository,
        final GenderRepository genderRepository) {

        this.studentRepository = studentRepository;
        this.schoolRepository = schoolRepository;
        this.genderRepository = genderRepository;
    }

    @Override
    public List<Student> parse(final byte[] studentPayload) {

        try (final Reader reader = new InputStreamReader(new BOMInputStream(new ByteArrayInputStream(studentPayload)), StandardCharsets.UTF_8)) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180
                    .withFirstRecordAsHeader()
                    .withDelimiter('^')
                    .withCommentMarker('#')
                    .parse(reader).iterator();

            if (!recordIterator.hasNext()) throw new ImportException(BAD_DATA, "Empty payload");

            final List<Student> students = new ArrayList<>();

            final DataElementErrorCollector parseErrorCollector = new DataElementErrorCollector();
            final ParserHelper parserHelper = new ParserHelper(parseErrorCollector);

            while (recordIterator.hasNext()) {
                final CSVRecord record = recordIterator.next();
                final long row = record.getRecordNumber();

                if (Iterables.all(record, value -> value == null || value.trim().isEmpty())) continue;

                int errorCount = parseErrorCollector.size();

                // Parse specific fields into Student object. Blank values are interpreted as no update and set to null.
                // However, SSID must not be blank because it how the student to update is identified.
                final Student student = new Student.Builder()
                    .ssid(parserHelper.validate(contextName(SSID, row), record.get(SSID), checkNotBlank.andThen(this::studentExists)))
                    .schoolId(parserHelper.validate(contextName(SchoolId, row), record.get(SchoolId), school -> isBlank(school) ? null : schoolRepository.findIdByNaturalId(school)))
                    // TODO: all code is in place to the following fields, but turned off for now. Uncomment (and fix tests) to turn it back on.
//                    .genderId(parserHelper.validate(contextName(Gender, row), record.get(Gender), gender -> isBlank(gender) ? null : genderRepository.findIdByCode(gender)))
//                    .lastOrSurname(trimToNull(parserHelper.validate(contextName(LastOrSurname, row), record.get(LastOrSurname), 60, false)))
//                    .firstName(trimToNull(parserHelper.validate(contextName(FirstName, row), record.get(FirstName), 60, false)))
//                    .middleName(trimToNull(parserHelper.validate(contextName(MiddleName, row), record.get(MiddleName), 60, false)))
//                    .firstEntryIntoUSSchoolAt(parserHelper.validate(contextName(FirstEntryIntoUSSchool, row), record.get(FirstEntryIntoUSSchool), toLocalDateOrNull))
//                    .lepEntryAt(parserHelper.validate(contextName(LepEntryDate, row), record.get(LepEntryDate), toLocalDateOrNull))
//                    .lepExitAt(parserHelper.validate(contextName(LepExitDate, row), record.get(LepExitDate), toLocalDateOrNull))
//                    .birthday(parserHelper.validate(contextName(Birthdate, row), record.get(Birthdate), toLocalDateOrNull))
                    .infoUpdate(!record.isMapped(InfoUpdate) ? null :
                        toInstant(parserHelper.validate(contextName(InfoUpdate, row), record.get(InfoUpdate), toLocalDateOrNull)))
                    // TODO: add alias name when column is known. New tests and some implementation will also be needed.
                    //   .aliasName(trimToNull(parserHelper.validate(contextName(AliasName, row), record.get(AliasName), 60, false)))
                    .build();

                if (parseErrorCollector.size() == errorCount && hasUpdates(student)) {
                    logger.debug("Adding to update list student with SSID: " + student.getSsid());
                    students.add(student);
                } else if (!hasUpdates(student)) {
                    logger.debug("Skipping row  " +  row  + " with SSID: " +
                        student.getSsid() + ". Nothing to update.");
                } else {
                    logger.debug("Error parsing row " + row + " with SSID: " +
                        student.getSsid() + " will not be updated. (See WARN level log below for details.)");
                }
            }

            // Errors are collected and logged if not empty after parsing all rows for a comprehensive list.
            if (!parseErrorCollector.isEmpty()) {
                logger.warn("Some student records could not be processed:\n" + parseErrorCollector.toJson());
            }

            return students;

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    // Convert to start of day on the given date.
    private Instant toInstant(final LocalDate localDate) {
        if (localDate == null) {
            return null;
        }
        return localDate.atStartOfDay(ZoneId.systemDefault()).toInstant();
    }

    private String studentExists(final String ssid) {
        if (studentRepository.findBySsid(ssid) != null) {
            return ssid;
        }

        throw new IllegalArgumentException("No student found with ssid: " + ssid);
    }

    // Formats field name and row for use in validation error messages.
    private String contextName(final String fieldName, final long row) {
        return "[row:" + row + "], " + fieldName;
    }

    private static boolean hasUpdates(final Student student) {
        return student.getSchoolId() != null ||
            student.getGenderId() != null ||
            student.getLastOrSurname() != null ||
            student.getFirstName() != null ||
            student.getMiddleName() != null ||
            student.getAliasName() != null ||
            student.getFirstEntryIntoUSSchoolAt() != null ||
            student.getLepEntryAt() != null ||
            student.getLepExitAt() != null ||
            student.getBirthday() != null;
    }
}
