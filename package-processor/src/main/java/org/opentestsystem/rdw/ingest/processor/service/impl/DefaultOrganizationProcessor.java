package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.ingest.common.model.District;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.School;
import org.opentestsystem.rdw.ingest.common.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.service.OrganizationProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Map;

import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_DATA;

/**
 * Process a payload with organization information.
 * <p>
 * The payload is expected to be concatenated json response from ART. The required data fields are:<ul>
 *     <li>entityType</li>
 *     <li>entityId</li>
 *     <li>entityName</li>
 *     <li>parentEntityId</li>
 * </ul>
 * The precise structure of the payload isn't critical but might look like this:<pre>
 * { "districts": PAYLOAD-FROM-ART,
 *   "groupsofschools": PAYLOAD-FROM-ART,
 *   "schools": PAYLOAD-FROM-ART
 * }
 * </pre>
 * Where each ART payload is a collection of entities, optionally in a search results wrapper.
 * For example, simple collection of districts:<pre>
[
    {
        "id": "572d7630e4b0ed2c55c37e34",
        "entityId": "DISTRICT9",
        "entityName": "District 9 - Prawn Town",
        "parentEntityId": "CA",
        "nationwideIdentifier": null,
        "entityType": "DISTRICT",
    }, ...
]
 * </pre>
 * And a list of schools wrapped in search results:<pre>
{
    "searchResults": [
        {
            "id": "57325fc6e4b0ed2c55c37e40",
            "entityId": "DS9001",
            "entityName": "District 9 Institution 1",
            "parentEntityId": "DISTRICT9",
            "stateAbbreviation": "CA",
            "nationwideIdentifier": "NCESID001",
            "entityType": "INSTITUTION",
        }, ...
    ],
    "currentPage": 0,
    "returnCount": 1000,
    "pageSize": 1000,
    "totalCount": 1800,
    "nextPageUrl": "?pageSize=1000&currentPage=1"
}
 * </pre>
 * </p>
 */
@Service
class DefaultOrganizationProcessor implements OrganizationProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultOrganizationProcessor.class);

    private final SchoolRepository schoolRepository;

    @Autowired
    public DefaultOrganizationProcessor(final SchoolRepository schoolRepository) {
        this.schoolRepository = schoolRepository;
    }

    @Override
    public void process(final byte[] payload, final long importId) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();

        final OrgTreeParser parser = new OrgTreeParser(new ParserHelper(errorCollector));
        parser.extractDistrictsAndSchools(payload);

        if (!errorCollector.isEmpty()) {
            throw new ImportException(BAD_DATA, errorCollector.toJson());
        }

        for (final School school : parser.getSchools().values()) {
            schoolRepository.upsert(school, importId);
        }
        logger.info("{} schools upserted", parser.getSchools().size());
    }

    /**
     * This parses the json document, extracting pertinent district, group, and institution info.
     * It is as forgiving as possible wrt to the structure: it looks for json objects that have
     * the required type, id, name, and parent id fields. It allows the order of the objects to
     * be flexible (e.g. districts can come after schools).
     */
    static class OrgTreeParser {

        private final ParserHelper parserHelper;
        private final Map<String, District> districts = newHashMap();
        private final Map<String, School> schools = newHashMap();
        private final Map<String, String> groupToDistrict = newHashMap();
        private final Map<String, String> schoolToParent = newHashMap();

        OrgTreeParser(final ParserHelper parserHelper) {
            this.parserHelper = parserHelper;
        }

        Map<String, School> getSchools() {
            return schools;
        }

        void extractDistrictsAndSchools(final byte[] payload) {
            districts.clear();
            schools.clear();
            groupToDistrict.clear();
            schoolToParent.clear();

            final JsonFactory factory = new JsonFactory();
            final ObjectMapper mapper = new ObjectMapper(factory);
            try {
                processNode(mapper.readTree(payload));
                resolveSchoolParents();
                logger.info("parsed {} schools, {} districts", schools.size(), districts.size());
            } catch (final IOException e) {
                throw new IllegalArgumentException("invalid organization payload", e);
            }
        }

        private void processNode(final JsonNode node) {
            if (node.isArray() || (node.isContainerNode() && !node.has("entityType"))) {
                node.forEach(this::processNode);
            } else if (node.isContainerNode() && node.has("entityType")) {
                final String entityId = parserHelper.validate("entityId", node.get("entityId").asText(), 40, false);
                final String entityName = parserHelper.validate("entityName", node.get("entityName").asText(), 100, false);
                if (!entityId.isEmpty() && !entityName.isEmpty()) {
                    final String parentId = node.get("parentEntityId").asText();
                    switch (node.get("entityType").asText().toUpperCase()) {
                        case "DISTRICT":
                            districts.put(entityId, District.builder().naturalId(entityId).name(entityName).stateCode(parentId).build());
                            break;
                        case "GROUPOFINSTITUTIONS":
                            groupToDistrict.put(entityId, parentId);
                            break;
                        case "INSTITUTION":
                            schools.put(entityId, School.builder().naturalId(entityId).name(entityName).build());
                            schoolToParent.put(entityId, parentId);
                            break;
                        default:
                            break;
                    }
                }
            }
        }

        private void resolveSchoolParents() {
            for (final School school : schools.values()) {
                String parentId = schoolToParent.get(school.getNaturalId());
                if (groupToDistrict.containsKey(parentId)) {
                    parentId = groupToDistrict.get(parentId);
                }
                school.setDistrict(parserHelper.validate(school.getNaturalId() + " district", parentId, value -> {
                    if (!districts.containsKey(value)) throw new IllegalArgumentException("unknown district [" + value + "]");
                    return districts.get(value);
                }));
            }
        }
    }
}
