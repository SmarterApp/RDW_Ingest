package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.processor.model.WarehouseTarget;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Collection;

@Repository
class JdbcTargetRepository implements TargetRepository {
    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.target.findIdByNaturalIdAndClaimId}")
    private String sqlFindIdByNaturalIdAndClaimId;

    @Value("${sql.target.findBySubject}")
    private String sqlFindBySubject;

    @Value("${sql.target.insert}")
    private String sqlCreateTarget;

    @Value("${sql.target.delete}")
    private String sqlDeleteTarget;

    @Value("${sql.target.isReferenced}")
    private String sqlTargetIsReferenced;

    @Autowired
    JdbcTargetRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public Integer findIdByNaturalIdAndClaimId(final String naturalId, final int claimId) {
        try {
            return jdbcTemplate.queryForObject(sqlFindIdByNaturalIdAndClaimId,
                    new MapSqlParameterSource()
                            .addValue("naturalId", naturalId)
                            .addValue("claimId", claimId), Integer.class);
        } catch (final EmptyResultDataAccessException ignore) {
            return null;
        }
    }

    @Override
    public Collection<WarehouseTarget> findBySubject(final String subjectCode) {
        return jdbcTemplate.query(sqlFindBySubject,
                new MapSqlParameterSource("subject_code", subjectCode),
                (row, rowNum) -> WarehouseTarget.builder()
                        .id(row.getInt("id"))
                        .claimCode(row.getString("claim_code"))
                        .naturalId(row.getString("natural_id"))
                        .build());
    }

    @Override
    public void create(final String subjectCode, final Collection<WarehouseTarget> targets) {
        if (targets.isEmpty()) return;

        final MapSqlParameterSource[] batchParamters = targets.stream()
                .map(target -> new MapSqlParameterSource("subject_code", subjectCode)
                        .addValue("claim_code", target.getClaimCode())
                        .addValue("natural_id", target.getNaturalId()))
                .toArray(MapSqlParameterSource[]::new);

        final int[] insertCounts = jdbcTemplate.batchUpdate(sqlCreateTarget, batchParamters);

        for (int i = 0; i < insertCounts.length; i++) {
            if (insertCounts[i] != 1)
            throw new IllegalArgumentException("Unable to create target: " + batchParamters[i].getValue("natural_id") +
                    " for claim: " + batchParamters[i].getValue("claim_code") +
                    " subject: " + subjectCode);
        }
    }

    @Override
    public void delete(final Collection<Integer> targetIds) {
        if (targetIds.isEmpty()) return;

        jdbcTemplate.update(sqlDeleteTarget,
                new MapSqlParameterSource("target_ids", targetIds));
    }

    @Override
    public Integer isReferenced(final Collection<Integer> targetIds) {
        if (targetIds.isEmpty()) return null;

        try {
            return jdbcTemplate.queryForObject(sqlTargetIsReferenced,
                    new MapSqlParameterSource("target_ids", targetIds),
                    Integer.class);
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }
}
