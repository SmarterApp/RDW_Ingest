package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.subject.ItemDifficulty;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseItemDifficulty;
import org.opentestsystem.rdw.ingest.processor.repository.ItemDifficultyRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectItemDifficultyService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.ingest.common.util.MathUtils.isCloseFloat;

/**
 * Default implementation of a SubjectItemDifficultyService
 */
@Service
class DefaultSubjectItemDifficultyService implements SubjectItemDifficultyService {

    private final ItemDifficultyRepository repository;

    @Autowired
    public DefaultSubjectItemDifficultyService(final ItemDifficultyRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final Map<String, WarehouseItemDifficulty> existingDifficulties = repository.findBySubject(subject.getCode()).stream()
                .collect(Collectors.toMap(WarehouseItemDifficulty::getGradeCode, difficulty -> difficulty));

        final List<WarehouseItemDifficulty> newDifficulties = newArrayList();
        final List<WarehouseItemDifficulty> updatedDifficulties = newArrayList();
        if (subject.getItemDifficulties() != null) {
            for (final ItemDifficulty submitted : subject.getItemDifficulties()) {
                final WarehouseItemDifficulty existing = existingDifficulties.remove(submitted.getGradeCode());
                if (existing == null) {
                    newDifficulties.add(WarehouseItemDifficulty.builder()
                            .gradeCode(submitted.getGradeCode())
                            .moderateLowEnd(submitted.getModerateLowEnd())
                            .difficultLowEnd(submitted.getDifficultLowEnd())
                            .build());
                } else if (!isCloseFloat(existing.getModerateLowEnd(), submitted.getModerateLowEnd())
                        || !isCloseFloat(existing.getDifficultLowEnd(), submitted.getDifficultLowEnd())) {
                    updatedDifficulties.add(existing.copy()
                            .moderateLowEnd(submitted.getModerateLowEnd())
                            .difficultLowEnd(submitted.getDifficultLowEnd())
                            .build());
                }
            }
            repository.create(subject.getCode(), newDifficulties);
            assertNoReferences(updatedDifficulties, "update");
            repository.update(updatedDifficulties);
        }

        if (existingDifficulties.isEmpty()) return;

        assertNoReferences(existingDifficulties.values(), "delete");
        repository.delete(existingDifficulties.values().stream()
                .map(WarehouseItemDifficulty::getId)
                .collect(Collectors.toList()));
    }

    private void assertNoReferences(final Collection<WarehouseItemDifficulty> difficulties,
                                    final String action) {
        final Map<Integer, WarehouseItemDifficulty> difficultiesById = difficulties.stream()
                .collect(Collectors.toMap(WarehouseItemDifficulty::getId, difficulty -> difficulty));
        final Integer referencedId = repository.isReferenced(difficultiesById.keySet());
        if (referencedId == null) return;

        final WarehouseItemDifficulty referencedDifficulty = difficultiesById.get(referencedId);
        throw new IllegalArgumentException("Unable to " + action + " existing item difficulty cutpoint id: " + referencedId +
                " grade code: " + referencedDifficulty.getGradeCode() +
                " due to existing assessment references");
    }
}
