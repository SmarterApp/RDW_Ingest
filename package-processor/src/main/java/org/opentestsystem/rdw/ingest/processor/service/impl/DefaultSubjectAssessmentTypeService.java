package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectAssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectAssessmentTypeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Default implementation of a SubjectAssessmentTypeService.
 */
@Service
class DefaultSubjectAssessmentTypeService  implements SubjectAssessmentTypeService {

    private final SubjectAssessmentTypeRepository repository;

    @Autowired
    public DefaultSubjectAssessmentTypeService(final SubjectAssessmentTypeRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final String subjectCode = subject.getCode();

        //Fetch the existing definitions
        final Map<String, WarehouseSubjectAssessmentType> existing = repository.findBySubject(subjectCode).stream()
                .collect(Collectors.toMap(
                        WarehouseSubjectAssessmentType::getAssessmentTypeCode,
                        type -> type));

        //Parse the new definitions from the submission
        final Set<WarehouseSubjectAssessmentType> submitted = subject.getAssessmentTypes().stream()
                .map(subjectAssessmentType -> WarehouseSubjectAssessmentType.builder()
                        .subjectCode(subject.getCode())
                        .fromSubjectAssessmentType(subjectAssessmentType)
                        .build())
                .collect(Collectors.toSet());

        //Update or insert each submitted definition
        for (final WarehouseSubjectAssessmentType submittedType : submitted) {
            final String asmtTypeCode = submittedType.getAssessmentTypeCode();
            final WarehouseSubjectAssessmentType existingType = existing.remove(asmtTypeCode);
            if (existingType == null) {
                repository.create(submittedType);
            } else {
                update(existingType, submittedType);
            }
        }

        //Delete definitions that were not submitted
        for (final WarehouseSubjectAssessmentType deleted : existing.values()) {
            delete(deleted);
        }
    }

    /**
     * Update the given subject assessment type definition.
     * NOTE that this only allows updating the performance level counts IFF there are no existing exams
     * for the target subject and assessment type.
     *
     * @param existing  The existing type
     * @param updated   The submitted type
     */
    private void update(final WarehouseSubjectAssessmentType existing, final WarehouseSubjectAssessmentType updated) {
        if (updated.equals(existing)) return;

        if (repository.isReferenced(existing)) {
            if (!Objects.equals(existing.getPerformanceLevelCount(), updated.getPerformanceLevelCount())) {
                throw new IllegalArgumentException("Unable to update subject assessment type performance level counts due to existing assessments for subject: " +
                        existing.getSubjectCode() +
                        " assessment type: " +
                        existing.getAssessmentTypeCode());
            }
            if (!Objects.equals(existing.getClaimScorePerformanceLevelCount(), updated.getClaimScorePerformanceLevelCount())) {
                throw new IllegalArgumentException("Unable to update subject assessment type claim score performance level counts due to existing assessments for subject: " +
                        existing.getSubjectCode() +
                        " assessment type: " +
                        existing.getAssessmentTypeCode());
            }
        }
        repository.update(updated);
    }

    /**
     * Delete the given subject assessment type definition.
     * NOTE that this only allows deleting the definition IFF there are no existing exams
     * for the target subject and assessment type.
     *
     * @param type The type definition to delete
     */
    private void delete(final WarehouseSubjectAssessmentType type) {
        if (repository.isReferenced(type)) {
            throw new IllegalArgumentException("Unable to delete subject assessment type due to existing assessments for subject: " +
                    type.getSubjectCode() +
                    " assessment type: " +
                    type.getAssessmentTypeCode());
        }
        repository.delete(type.getSubjectCode(), type.getAssessmentTypeCode());
    }
}
