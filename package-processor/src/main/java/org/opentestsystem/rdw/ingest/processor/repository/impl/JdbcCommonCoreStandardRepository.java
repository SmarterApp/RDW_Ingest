package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.Iterables;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseStandard;
import org.opentestsystem.rdw.ingest.processor.repository.CommonCoreStandardRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Collection;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;

@Repository
class JdbcCommonCoreStandardRepository implements CommonCoreStandardRepository {
    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.standard.findIdsBySubjectIdAndNaturalIds}")
    private String findIdsBySubjectIdAndNaturalIdsSql;

    @Value("${sql.standard.findBySubject}")
    private String sqlFindBySubject;

    @Value("${sql.standard.insert}")
    private String sqlCreate;

    @Value("${sql.standard.delete}")
    private String sqlDelete;

    @Value("${sql.standard.hasItem}")
    private String sqlHasItem;

    @Autowired
    JdbcCommonCoreStandardRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public List<Integer> findIdsBySubjectIdAndNaturalIds(final Iterable<String> naturalIds, final Integer subjectId) {
        if (Iterables.isEmpty(naturalIds)) return newArrayList();

        return jdbcTemplate.queryForList(findIdsBySubjectIdAndNaturalIdsSql,
                new MapSqlParameterSource()
                        .addValue("naturalIds", naturalIds)
                        .addValue("subjectId", subjectId), Integer.class);

    }

    @Override
    public Collection<WarehouseStandard> findBySubject(final String subjectCode) {
        return jdbcTemplate.query(sqlFindBySubject,
                new MapSqlParameterSource("subject_code", subjectCode),
                (row, rowNum) -> WarehouseStandard.builder()
                        .id(row.getInt("id"))
                        .code(row.getString("natural_id"))
                        .build());
    }

    @Override
    public void create(final String subjectCode, final Collection<String> standards) {
        if (standards.isEmpty()) return;

        final MapSqlParameterSource[] batchParams = standards.stream()
                .map(standard -> new MapSqlParameterSource("subject_code", subjectCode)
                        .addValue("standard_code", standard))
                .toArray(MapSqlParameterSource[]::new);

        final int[] insertCounts = jdbcTemplate.batchUpdate(sqlCreate, batchParams);

        for (int i = 0; i < insertCounts.length; i++) {
            if (insertCounts[i] != 1)
                throw new IllegalArgumentException("Unable to create standard: " + batchParams[i].getValue("standard_code") +
                        " for  subject: " + subjectCode);
        }
    }

    @Override
    public void delete(final Collection<Integer> standardIds) {
        if (standardIds.isEmpty()) return;

        jdbcTemplate.update(sqlDelete, new MapSqlParameterSource("ids", standardIds));
    }

    @Override
    public Integer hasItem(final Collection<Integer> standardIds) {
        if (standardIds.isEmpty()) return null;

        try {
            return jdbcTemplate.queryForObject(sqlHasItem,
                    new MapSqlParameterSource("ids", standardIds),
                    Integer.class);
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }
}
