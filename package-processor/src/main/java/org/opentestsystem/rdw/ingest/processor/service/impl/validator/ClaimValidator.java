package org.opentestsystem.rdw.ingest.processor.service.impl.validator;

import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Set;
import org.opentestsystem.rdw.common.model.subject.Claim;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.Target;
import org.opentestsystem.rdw.ingest.processor.service.SubjectValidator;
import org.opentestsystem.rdw.utils.LocationAwareErrorCollector;

import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.common.model.AssessmentBoundaries.MaxScorableClaims;

/**
 * This validator is responsible for validating {@link Claim} models as well
 * as their child {@link Target} models.
 */
@Component
class ClaimValidator implements SubjectValidator {

    @Override
    public void validate(final LocationAwareErrorCollector context, final Subject subject) {
        if (subject.getClaims() == null) return;

        final Set<String> codes = newHashSet();
        final Set<Integer> displayOrders = newHashSet();
        final Set<Integer> dataOrders = newHashSet();
        int scorableClaimCount = 0;
        for (final Claim claim : subject.getClaims()) {
            final String code = claim.getCode();
            context.push("Claim", code);
            if (!codes.add(code)) {
                context.failure("Duplicate code found: " + code);
                continue;
            }

            if (!claim.isScorable() && !claim.isOrganizational()) {
                context.failure("Claim must be scorable, organizational, or both");
            }

            if (claim.isScorable()) {
                ++scorableClaimCount;

                if (claim.getDisplayOrder() == null) {
                    context.failure("Scorable Claims must have a displayOrder defined");
                } else if (!displayOrders.add(claim.getDisplayOrder())) {
                    context.failure("Duplicate displayOrder found: " + claim.getDisplayOrder());
                }

                if (claim.getDataOrder() == null) {
                    context.failure("Scorable Claims must have a dataOrder defined");
                } else if (!dataOrders.add(claim.getDataOrder())) {
                    context.failure("Duplicate dataOrder found: " + claim.getDataOrder());
                }
            }

            if (!claim.isOrganizational()
                    && claim.getTargets() != null
                    && !claim.getTargets().isEmpty()) {
                context.failure("A non-organizational claim cannot contain targets");
            }

            if (claim.isOrganizational()) {
                validateTargets(context, claim.getTargets());
            }

            context.pop();
        }
        if (scorableClaimCount > MaxScorableClaims) {
            context.push("Claims");
            context.failure("A maximum number of " + MaxScorableClaims + " scorable claims are supported, but found: " + scorableClaimCount);
            context.pop();
        }
    }

    private void validateTargets(final LocationAwareErrorCollector context, final Collection<Target> targets) {
        if (targets == null) return;

        context.push("Targets");
        final Set<String> targetCodes = newHashSet();
        for (final Target target : targets) {
            final String code = target.getCode();
            if (!targetCodes.add(code)) {
                context.failure("Duplicate target code found: " + code);
            }
        }
        context.pop();
    }
}
