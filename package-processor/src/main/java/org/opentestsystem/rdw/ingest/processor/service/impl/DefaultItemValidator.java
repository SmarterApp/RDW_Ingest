package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.assessment.Item;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseAssessmentItem;
import org.opentestsystem.rdw.ingest.processor.repository.ClaimRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CommonCoreStandardRepository;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.MathPracticeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;
import org.opentestsystem.rdw.utils.DataElementError;
import org.opentestsystem.rdw.utils.DataElementErrorCollector;
import org.opentestsystem.rdw.utils.ParserHelper;

import static com.google.common.collect.Sets.newHashSet;
import static java.util.Collections.emptyList;
import static org.opentestsystem.rdw.utils.ParserHelper.checkNotBlank;

@Service
class DefaultItemValidator implements ItemValidator {
    private static final Logger logger = LoggerFactory.getLogger(DefaultItemValidator.class);

    private final ClaimRepository claimRepository;
    private final TargetRepository targetRepository;
    private final DepthOfKnowledgeRepository depthOfKnowledgeRepository;
    private final MathPracticeRepository mathPracticeRepository;
    private final CommonCoreStandardRepository commonCoreStandardRepository;

    @Autowired
    public DefaultItemValidator(final ClaimRepository claimRepository,
                                final TargetRepository targetRepository,
                                final DepthOfKnowledgeRepository depthOfKnowledgeRepository,
                                final MathPracticeRepository mathPracticeRepository,
                                final CommonCoreStandardRepository commonCoreStandardRepository) {
        this.claimRepository = claimRepository;
        this.targetRepository = targetRepository;
        this.depthOfKnowledgeRepository = depthOfKnowledgeRepository;
        this.mathPracticeRepository = mathPracticeRepository;
        this.commonCoreStandardRepository = commonCoreStandardRepository;
    }

    public List<WarehouseAssessmentItem> validate(final List<Item> items, final DataElementErrorCollector batchErrorCollector, final String prefix, final int subjectId) {
        return items.stream()
                .map(item -> validate(item, batchErrorCollector, prefix + "item id [" + item.getFullKey() + "], ", subjectId))
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    private WarehouseAssessmentItem validate(final Item item, final DataElementErrorCollector batchErrorCollector, final String prefix, final int subjectId) {
        // accumulate local errors separately
        final ParserHelper parserHelper = new ParserHelper();

        final ClaimTarget primaryClaimTarget = validateClaimTarget(subjectId, item.getClaimContentTarget(), parserHelper, prefix + "ClaimContentTarget");

        final WarehouseAssessmentItem.Builder builder = WarehouseAssessmentItem.builder()
                .naturalId(parserHelper.validate(prefix + "FullKey", item.getFullKey(), 40, true))
                .claimId(primaryClaimTarget.getClaimId())
                .targetId(primaryClaimTarget.getTargetId())
                .difficulty(parserHelper.validate(prefix + "avg_b", item.getAvg_b(), new CheckNotNull<>()))
                .dokId(parserHelper.validate(prefix + "DOK", item.getDok(), ((Function<Integer, Integer>)
                        (dok -> depthOfKnowledgeRepository.findIdByLevelAndSubject(dok, subjectId)))
                        .andThen(new CheckNotNull<>())))
                .position(item.getPosition())
                .maxPoints(parserHelper.validate(prefix + "MaxPoints", item.getMaxPoints(),
                        new CheckNotNull<Integer>().andThen(Integer::doubleValue)))
                .mathPractice(validateMathPractice(item.getMathPractice(), parserHelper, prefix))
                .allowCalculator(item.getAllowCalculator())
                .commonCoreStandards(validateCommonCoreStandards(item, subjectId, parserHelper, prefix))
                .otherTargets(validateOtherTargets(subjectId, item.getSecondaryClaimContentTarget(), parserHelper, prefix + "SecondaryClaimContentTarget"))
                .active(item.getActive())
                .fieldTest(item.getFieldTest())
                .optionsCount(parserHelper.validate(prefix + "NumberOfAnswerOptions", item.getNumberOfAnswerOptions(),
                        new CheckNotNull<>()))
                .type(item.getType())
                .performanceTaskWritingType(parserHelper.validate(prefix + "PtWritingType", item.getPtWritingType(), 16, false))
                .answerKey(validateAnswerKey(item, parserHelper, prefix));

        if (parserHelper.getElementErrorCollector().isEmpty()) {
            return builder.build();
        } else {
            batchErrorCollector.addAll(parserHelper.getElementErrorCollector());
            return null;
        }
    }

    private ClaimTarget validateClaimTarget(final int subjectId, final String claimTarget, final ParserHelper parserHelper, final String field) {
        final String value = claimTarget == null ? "" : claimTarget.trim();
        final int claimSeparatorIndex = value.isEmpty() ? -1 : value.indexOf("|");

        if (claimSeparatorIndex < 1) {
            parserHelper.addError(new DataElementError(field, value, "invalid value"));
            return new ClaimTarget(null, null);
        }

        final String claim = value.substring(0, claimSeparatorIndex).trim();
        final Integer claimId = parserHelper.validate(field, claim, checkNotBlank.andThen(c -> claimRepository.findIdByCode(subjectId, c)));
        if (claimId == null) {
            logger.info("Claim not found for '{}'", claim);
            parserHelper.addError(new DataElementError(field, value, "claim not found"));
            return new ClaimTarget(null, null);
        }

        final String target = value.substring(claimSeparatorIndex + 1).trim();
        final Integer targetId = parserHelper.validate(field, target, checkNotBlank.andThen(t -> targetRepository.findIdByNaturalIdAndClaimId(t, claimId)));
        if (targetId == null) {
            logger.info("Target not found for '{}'", target);
            parserHelper.addError(new DataElementError(field, value, "target not found"));
        }

        return new ClaimTarget(claimId, targetId);
    }

    private Collection<Integer> validateOtherTargets(final int subjectId, final String value, final ParserHelper parserHelper, final String field) {
        final Set<Integer> targetIds = newHashSet();

        if (value == null) return targetIds;

        for (final String split : value.split(";")) {
            final ClaimTarget claimTarget = validateClaimTarget(subjectId, split, parserHelper, field);
            if (claimTarget.getTargetId() != null) targetIds.add(claimTarget.getTargetId());
        }

        return targetIds;
    }

    private List<Integer> validateCommonCoreStandards(final Item item, final int subjectId, final ParserHelper parserHelper, final String prefix) {
        if (item.getCommonCore() == null && item.getSecondaryCommonCore() == null) return emptyList();

        final Set<String> parsedValues = newHashSet();
        if (item.getCommonCore() != null) {
            parsedValues.addAll(Arrays.stream(item.getCommonCore().split(";"))
                    .map(String::trim).map(s -> s.replace("\t", "")).collect(Collectors.toSet()));
        }
        if (item.getSecondaryCommonCore() != null) {
            parsedValues.addAll(Arrays.stream(item.getSecondaryCommonCore().split(";"))
                    .map(String::trim).map(s -> s.replace("\t", "")).collect(Collectors.toSet()));
        }

        final List<Integer> ids = commonCoreStandardRepository.findIdsBySubjectIdAndNaturalIds(parsedValues, subjectId);
        if (ids.size() == parsedValues.size()) return ids;

        logger.info("Common core standard not found for '{}'", item.getCommonCore());
        parserHelper.addError(new DataElementError(prefix + "CommonCoreStandards", item.getCommonCore(),
                "unable to find all common core standards for an item and subject id [" + subjectId + "]"));
        return emptyList();
    }

    private Integer validateMathPractice(final Integer value, final ParserHelper parserHelper, final String prefix) {
        if (value == null) return null;
        return parserHelper.validate(prefix + "MathPractice", value,
                ((Function<Integer, Integer>)mathPracticeRepository::findByPractice).andThen(new CheckNotNull<>()));
    }

    private String validateAnswerKey(final Item item, final ParserHelper parserHelper, final String prefix) {
        if (!"MS".equalsIgnoreCase(item.getType()) && !"MC".equalsIgnoreCase(item.getType())) return item.getAnswerKey();
        return parserHelper.validate(prefix + "AnswerKey", item.getAnswerKey(), checkNotBlank);
    }

    private static class ClaimTarget {
        private final Integer claimId;
        private final Integer targetId;

        ClaimTarget(final Integer claimId, final Integer targetId) {
            this.claimId = claimId;
            this.targetId = targetId;
        }

        Integer getClaimId() {
            return claimId;
        }

        Integer getTargetId() {
            return targetId;
        }
    }
}
