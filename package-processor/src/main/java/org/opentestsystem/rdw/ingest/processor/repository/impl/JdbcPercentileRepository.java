package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.model.PercentileScore;
import org.opentestsystem.rdw.ingest.processor.repository.PercentileRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;

@Repository
class JdbcPercentileRepository implements PercentileRepository {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.percentile.create}")
    private String sqlPercentileCreate;

    @Value("${sql.percentile.update}")
    private String sqlPercentileUpdate;

    @Value("${sql.percentile.findIdByKey}")
    private String sqlPercentileFindIdByKey;

    @Value("${sql.percentile.findIdsByDateOverlap}")
    private String findIdsByDateOverlap;

    @Value("${sql.percentile.percentileScore.create}")
    private String sqlPercentileScoreCreate;

    @Value("${sql.percentile.percentileScore.insert}")
    private String sqlPercentileScoreInsert;

    @Value("${sql.percentile.percentileScore.delete}")
    private String sqlPercentileScoreDelete;


    @Autowired
    public JdbcPercentileRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }


    @Transactional
    @Override
    public void save(final Collection<Percentile> percentiles, final long importId) {

        final List<Percentile> newPercentiles = percentiles.stream().filter(p -> p.getId() == null).collect(Collectors.toList());
        final List<Percentile> existPercentiles = percentiles.stream().filter(p -> p.getId() != null).collect(Collectors.toList());

        if (newPercentiles.size() > 0) create(newPercentiles, importId);
        if (existPercentiles.size() > 0) update(existPercentiles, importId);
    }

    @Transactional
    @Override
    public void create(final Collection<Percentile> percentiles, final long importId) {

        final List<MapSqlParameterSource> createPercentileParams = newArrayList();
        final List<MapSqlParameterSource> createPercentileScoreParams = newArrayList();

        for (final Percentile percentile : percentiles) {
            // Collect params for Percentile to insert
            createPercentileParams.add(new MapSqlParameterSource()
                    .addValue("asmt_id", percentile.getAssessmentId())
                    .addValue("start_date", percentile.getStartDate())
                    .addValue("end_date", percentile.getEndDate())
                    .addValue("count", percentile.getCount())
                    .addValue("mean", percentile.getMean())
                    .addValue("standard_deviation", percentile.getStandardDeviation())
                    .addValue("min_score", percentile.getMinScore())
                    .addValue("max_score", percentile.getMaxScore())
                    .addValue("import_id", importId)
                    .addValue("update_import_id", importId));

            // Collect params to create children of new Percentile with unknown id
            for (final PercentileScore percentileScore : percentile.getPercentileScores()) {
                createPercentileScoreParams.add(new MapSqlParameterSource()
                        .addValue("asmt_id", percentile.getAssessmentId())
                        .addValue("start_date", percentile.getStartDate())
                        .addValue("end_date", percentile.getEndDate())
                        .addValue("percentile_rank", percentileScore.getPercentileRank())
                        .addValue("score", percentileScore.getScore())
                        .addValue("min_inclusive", percentileScore.getMinInclusive())
                        .addValue("max_exclusive", percentileScore.getMaxExclusive()));
            }
        }
        jdbcTemplate.batchUpdate(sqlPercentileCreate, createPercentileParams.toArray(new MapSqlParameterSource[createPercentileParams.size()]));
        jdbcTemplate.batchUpdate(sqlPercentileScoreCreate, createPercentileScoreParams.toArray(new MapSqlParameterSource[createPercentileScoreParams.size()]));
    }

    @Transactional
    @Override
    public void update(final Collection<Percentile> percentiles, final long importId) {

        final List<MapSqlParameterSource> updatePercentileParams = newArrayList();
        final List<MapSqlParameterSource> deletePercentileScoreParams = newArrayList();
        final List<MapSqlParameterSource> insertPercentileScoreParams = newArrayList();

        for (final Percentile percentile : percentiles) {
            // Collect params for Percentile to update
            updatePercentileParams.add(new MapSqlParameterSource()
                    .addValue("id", percentile.getId())
                    .addValue("count", percentile.getCount())
                    .addValue("mean", percentile.getMean())
                    .addValue("standard_deviation", percentile.getStandardDeviation())
                    .addValue("min_score", percentile.getMinScore())
                    .addValue("max_score", percentile.getMaxScore())
                    .addValue("update_import_id", importId));

            // Collect params to children of Percentile to delete
            deletePercentileScoreParams.add(new MapSqlParameterSource().addValue("percentile_id", percentile.getId()));

            // Collect params to insert replacement children of Percentile with known id
            for (final PercentileScore percentileScore : percentile.getPercentileScores()) {
                insertPercentileScoreParams.add(new MapSqlParameterSource()
                        .addValue("percentile_id", percentile.getId())
                        .addValue("percentile_rank", percentileScore.getPercentileRank())
                        .addValue("score", percentileScore.getScore())
                        .addValue("min_inclusive", percentileScore.getMinInclusive())
                        .addValue("max_exclusive", percentileScore.getMaxExclusive()));
            }
        }
        jdbcTemplate.batchUpdate(sqlPercentileUpdate, updatePercentileParams.toArray(new MapSqlParameterSource[updatePercentileParams.size()]));
        jdbcTemplate.batchUpdate(sqlPercentileScoreDelete, deletePercentileScoreParams.toArray(new MapSqlParameterSource[deletePercentileScoreParams.size()]));
        jdbcTemplate.batchUpdate(sqlPercentileScoreInsert, insertPercentileScoreParams.toArray(new MapSqlParameterSource[insertPercentileScoreParams.size()]));
    }

    @Override
    public Integer findIdByKey(final Integer assessmentId, final LocalDate startDate, final LocalDate endDate) {

        try {
            return jdbcTemplate.queryForObject(sqlPercentileFindIdByKey,
                    new MapSqlParameterSource()
                            .addValue("asmt_id", assessmentId)
                            .addValue("start_date", startDate.toString())
                            .addValue("end_date", endDate.toString()),
                    Integer.class);
        } catch (final EmptyResultDataAccessException ignore) {
            return null;
        }
    }

    @Override
    public List<Integer> findIdsByDateOverlap(final Integer assessmentId, final LocalDate startDate, final LocalDate endDate) {

        return jdbcTemplate.queryForList(findIdsByDateOverlap,
                new MapSqlParameterSource()
                        .addValue("asmt_id", assessmentId)
                        .addValue("start_date", startDate.toString())
                        .addValue("end_date", endDate.toString()),
                Integer.class);
    }

}