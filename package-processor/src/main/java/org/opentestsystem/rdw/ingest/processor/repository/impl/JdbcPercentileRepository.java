package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.model.PercentileScore;
import org.opentestsystem.rdw.ingest.processor.repository.PercentileRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.Collection;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;

@Repository
class JdbcPercentileRepository implements PercentileRepository {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.percentile.create}")
    private String sqlPercentileCreate;

    @Value("${sql.percentile.findIdByKey}")
    private String sqlPercentileFindIdByKey;

    @Value("${sql.percentile.findIdsByDateOverlap}")
    private String findIdsByDateOverlap;

    @Value("${sql.percentile.percentileScore.create}")
    private String sqlPercentileScoreCreate;

    @Autowired
    public JdbcPercentileRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Transactional
    @Override
    public void create(final Collection<Percentile> percentiles, final long importId) {

        final List<MapSqlParameterSource> percentileBatchParams = newArrayList();
        final List<MapSqlParameterSource> percentileScoreBatchParams = newArrayList();

        for (final Percentile percentile : percentiles) {
            percentileBatchParams.add(new MapSqlParameterSource()
                    .addValue("asmt_id", percentile.getAssessmentId())
                    .addValue("start_date", percentile.getStartDate())
                    .addValue("end_date", percentile.getEndDate())
                    .addValue("count", percentile.getCount())
                    .addValue("mean", percentile.getMean())
                    .addValue("standard_deviation", percentile.getStandardDeviation())
                    .addValue("min_score", percentile.getMinScore())
                    .addValue("max_score", percentile.getMaxScore())
                    .addValue("import_id", importId)
                    .addValue("update_import_id", importId));

            for (final PercentileScore percentileScore : percentile.getPercentileScores()) {
                percentileScoreBatchParams.add(new MapSqlParameterSource()
                        .addValue("asmt_id", percentile.getAssessmentId())
                        .addValue("start_date", percentile.getStartDate())
                        .addValue("end_date", percentile.getEndDate())
                        .addValue("percentile_rank", percentileScore.getPercentileRank())
                        .addValue("score", percentileScore.getScore())
                        .addValue("min_inclusive", percentileScore.getMinInclusive())
                        .addValue("max_exclusive", percentileScore.getMaxExclusive()));
            }
        }
        jdbcTemplate.batchUpdate(sqlPercentileCreate, percentileBatchParams.toArray(new MapSqlParameterSource[percentileBatchParams.size()]));
        jdbcTemplate.batchUpdate(sqlPercentileScoreCreate, percentileScoreBatchParams.toArray(new MapSqlParameterSource[percentileScoreBatchParams.size()]));
    }

    @Override
    public Integer findIdByKey(Integer assessmentId, LocalDate startDate, LocalDate endDate) {

        //SELECT id FROM percentile WHERE asmt_id=:asmt_id AND start_date=:start_date AND end_date=:end_date

        String date = startDate.toString();

        try {
            return jdbcTemplate.queryForObject(sqlPercentileFindIdByKey,
                    new MapSqlParameterSource()
                            .addValue("asmt_id", assessmentId)
                            .addValue("start_date", startDate.toString())
                            .addValue("end_date", endDate.toString()),
                    Integer.class);
        } catch (final EmptyResultDataAccessException ignore) {
            return null;
        }
    }

    @Override
    public List<Integer> findIdsByDateOverlap(Integer assessmentId, LocalDate startDate, LocalDate endDate) {

        return jdbcTemplate.queryForList(findIdsByDateOverlap,
                new MapSqlParameterSource()
                        .addValue("asmt_id", assessmentId)
                        .addValue("start_date", startDate.toString())
                        .addValue("end_date", endDate.toString()),
                Integer.class);
    }

}