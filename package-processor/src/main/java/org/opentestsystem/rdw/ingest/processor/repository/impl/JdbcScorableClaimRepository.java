package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.processor.model.WarehouseScorableClaim;
import org.opentestsystem.rdw.ingest.processor.repository.ScorableClaimRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Collection;

/**
 * JDBC implementation of a ScorableClaimRepository
 */
@Repository
class JdbcScorableClaimRepository implements ScorableClaimRepository {

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.scorableClaim.findBySubject}")
    private String sqlFindBySubject;

    @Value("${sql.scorableClaim.insert}")
    private String sqlCreate;

    @Value("${sql.scorableClaim.update}")
    private String sqlUpdate;

    @Value("${sql.scorableClaim.delete}")
    private String sqlDelete;

    @Value("${sql.scorableClaim.isReferenced}")
    private String sqlIsReferenced;

    @Autowired
    public JdbcScorableClaimRepository(final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public Collection<WarehouseScorableClaim> findBySubject(final String subjectCode) {
        return template.query(sqlFindBySubject,
                new MapSqlParameterSource("subject_code", subjectCode),
                (row, rowNum) -> WarehouseScorableClaim.builder()
                        .id(row.getInt("id"))
                        .code(row.getString("code"))
                        .displayOrder(row.getInt("display_order"))
                        .asmtTypeCode(row.getString("asmt_type_code"))
                        .dataOrder(row.getInt("data_order"))
                        .build());
    }

    @Override
    public void create(final String subjectCode, final Collection<WarehouseScorableClaim> claims) {
        if (claims.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = claims.stream()
                .map(claim -> new MapSqlParameterSource("subject_code", subjectCode)
                        .addValue("claim_code", claim.getCode())
                        .addValue("display_order", claim.getDisplayOrder())
                        .addValue("asmt_type_code", claim.getAsmtTypeCode())
                        .addValue("data_order", claim.getDataOrder()))
                .toArray(MapSqlParameterSource[]::new);

        final int[] insertCounts = template.batchUpdate(sqlCreate, batchParameters);

        for (int i = 0; i < insertCounts.length; i++) {
            if (insertCounts[i] != 1)
                throw new IllegalArgumentException("Unable to create scorable claim: " + batchParameters[i].getValue("claim_code") +
                        " assessment type: " + batchParameters[i].getValue("asmt_type_code") +
                        " for  subject: " + subjectCode);
        }
    }

    @Override
    public void update(final Collection<WarehouseScorableClaim> claims) {
        if (claims.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = claims.stream()
                .map(claim -> new MapSqlParameterSource("id", claim.getId())
                        .addValue("display_order", claim.getDisplayOrder())
                        .addValue("data_order", claim.getDataOrder()))
                .toArray(MapSqlParameterSource[]::new);

        final int[] updateCounts = template.batchUpdate(sqlUpdate, batchParameters);

        for (int i = 0; i < updateCounts.length; i++) {
            if (updateCounts[i] != 1)
                throw new IllegalArgumentException("Unable to update scorable claim: " + batchParameters[i].getValue("id") +
                        " display order: " + batchParameters[i].getValue("display_order"));
        }
    }

    @Override
    public void delete(final Collection<Integer> claimIds) {
        if (claimIds.isEmpty()) return;

        template.update(sqlDelete, new MapSqlParameterSource("ids", claimIds));
    }

    @Override
    public Integer isReferenced(final Collection<Integer> claimIds) {
        if (claimIds.isEmpty()) return null;

        try {
            return template.queryForObject(sqlIsReferenced,
                    new MapSqlParameterSource("ids", claimIds),
                    Integer.class);
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }
}
