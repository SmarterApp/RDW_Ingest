package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseScorableClaim;
import org.opentestsystem.rdw.ingest.processor.repository.ScorableClaimRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

/**
 * JDBC implementation of a ScorableClaimRepository
 */
@Repository
class JdbcScorableClaimRepository implements ScorableClaimRepository {

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.scorableClaim.findBySubject}")
    private String sqlFindBySubject;

    @Value("${sql.scorableClaim.insert}")
    private String sqlCreate;

    @Value("${sql.scorableClaim.update}")
    private String sqlUpdate;

    @Value("${sql.scorableClaim.delete}")
    private String sqlDelete;

    @Value("${sql.scorableClaim.hasAssessment}")
    private String sqlHasAssessment;

    @Autowired
    public JdbcScorableClaimRepository(final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Override
    public Collection<WarehouseScorableClaim> findBySubject(final String subjectCode) {
        return template.query(sqlFindBySubject,
                new MapSqlParameterSource("subject_code", subjectCode),
                (row, rowNum) -> WarehouseScorableClaim.builder()
                        .id(row.getInt("id"))
                        .code(row.getString("code"))
                        .displayOrder(row.getInt("display_order"))
                        .build());
    }

    @Override
    public void create(final String subjectCode, final Collection<WarehouseScorableClaim> claims) {
        if (claims.isEmpty()) return;

        final List<WarehouseScorableClaim> claimsList = ImmutableList.copyOf(claims);
        final int[] insertCounts = template.batchUpdate(sqlCreate, claimsList.stream().map(claim ->
            new MapSqlParameterSource("subject_code", subjectCode)
                    .addValue("claim_code", claim.getCode())
                    .addValue("display_order", claim.getDisplayOrder()))
            .collect(Collectors.toList())
            .toArray(new MapSqlParameterSource[0]));

        for (int i = 0; i < insertCounts.length; i++) {
            if (insertCounts[i] != 1)
                throw new IllegalArgumentException("Unable to create scorable claim: " + claimsList.get(i).getCode() +
                        " for  subject: " + subjectCode);
        }
    }

    @Override
    public void update(final Collection<WarehouseScorableClaim> claims) {
        if (claims.isEmpty()) return;

        final List<WarehouseScorableClaim> claimsList = ImmutableList.copyOf(claims);
        final int[] updateCounts = template.batchUpdate(sqlUpdate, claimsList.stream().map(claim ->
                new MapSqlParameterSource("id", claim.getId())
                        .addValue("display_order", claim.getDisplayOrder()))
                .collect(Collectors.toList())
                .toArray(new MapSqlParameterSource[0]));

        for (int i = 0; i < updateCounts.length; i++) {
            if (updateCounts[i] != 1)
                throw new IllegalArgumentException("Unable to update scorable claim: " + claimsList.get(i).getId() +
                        " code: " + claimsList.get(i).getCode() +
                        " display order: " + claimsList.get(i).getDisplayOrder());
        }
    }

    @Override
    public void delete(final Collection<Integer> claimIds) {
        if (claimIds.isEmpty()) return;

        template.update(sqlDelete, new MapSqlParameterSource("ids", claimIds));
    }

    @Override
    public Integer hasAssessment(final Collection<Integer> claimIds) {
        if (claimIds.isEmpty()) return null;

        try {
            return template.queryForObject(sqlHasAssessment,
                    new MapSqlParameterSource("ids", claimIds),
                    Integer.class);
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }
}
