package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import com.google.common.collect.Iterables;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.ScoreType;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.common.util.Precondition;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Assessment.Builder;
import org.opentestsystem.rdw.ingest.processor.model.AssessmentScore;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentScoring;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectAssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectScoreRepository;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDouble;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toGrade;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLong;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toYear;

@Service
class DefaultAssessmentParser implements AssessmentParser {

    private final GradeRepository gradeRepository;
    private final AssessmentTypeRepository typeRepository;
    private final SubjectRepository subjectRepository;
    private final SubjectAssessmentTypeRepository subjectAssessmentTypeRepository;
    private final SubjectScoreRepository subjectScoreRepository;
    private final ItemParser itemParser;

    @Autowired
    public DefaultAssessmentParser(final GradeRepository gradeRepository,
                                   final ItemParser itemParser,
                                   final SubjectRepository subjectRepository,
                                   final AssessmentTypeRepository assessmentTypeRepository,
                                   final SubjectAssessmentTypeRepository subjectAssessmentTypeRepository,
                                   final SubjectScoreRepository subjectScoreRepository) {
        this.gradeRepository = gradeRepository;
        this.typeRepository = assessmentTypeRepository;
        this.subjectRepository = subjectRepository;
        this.subjectAssessmentTypeRepository = subjectAssessmentTypeRepository;
        this.subjectScoreRepository = subjectScoreRepository;
        this.itemParser = itemParser;
    }

    public List<Assessment> parse(final byte[] assessmentPackage, final DataElementErrorCollector elementErrorCollector) {
        // at this point we need a Reader so assume UTF-8 payload
        try (final Reader reader = new InputStreamReader(new BOMInputStream(new ByteArrayInputStream(assessmentPackage)), StandardCharsets.UTF_8)) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180
                    .withFirstRecordAsHeader()
                    .withCommentMarker('#')
                    .parse(reader).iterator();

            final List<Assessment> assessments = newArrayList();
            if (!recordIterator.hasNext()) return assessments;

            final AssessmentParserHelper helper = new AssessmentParserHelper();
            helper.newAssessmentRecord(recordIterator.next());
            while (recordIterator.hasNext()) {
                final CSVRecord nextRecord = recordIterator.next();
                if (helper.isSkippable(nextRecord)) continue;

                if (!helper.sameAssessment(nextRecord)) {
                    assessments.add(helper.safeBuild(elementErrorCollector));
                    helper.newAssessmentRecord(nextRecord);
                } else {
                    helper.addItem(nextRecord);
                }
            }
            assessments.add(helper.safeBuild(elementErrorCollector));

            // if there are any errors in the collector then the assessments may contain nulls, don't return it
            return elementErrorCollector.isEmpty() ? assessments : newArrayList();

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private class AssessmentParserHelper {
        private final String AssessmentSubject = "AssessmentSubject";
        private final String AssessmentId = "AssessmentId";
        private final String AssessmentName = "AssessmentName";
        private final String AssessmentLabel = "AssessmentLabel";
        private final String AssessmentVersion = "AssessmentVersion";
        private final String AcademicYear = "AcademicYear";
        private final String AssessmentGrade = "AssessmentGrade";
        private final String AssessmentSubtype = "AssessmentSubtype";

        private final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        private final ParserHelper parserHelper = new ParserHelper(errorCollector);
        private String asmtNaturalId;
        private Integer asmtSubjectId;
        private Integer asmtTypeId;
        private Assessment.Builder asmtBuilder;
        private String logMsgPrefix;

        private void newAssessmentRecord(final CSVRecord record) {
            // collect errors separately for each assessment
            errorCollector.reset();
            parse(record);
            addItem(record);
        }

        private void parse(final CSVRecord record) {
            asmtNaturalId = parserHelper.validate(AssessmentId, record.get(AssessmentId), 250, true);
            logMsgPrefix = "[" + asmtNaturalId + "], ";
            asmtSubjectId = parserHelper.validate(logMsgPrefix + AssessmentSubject, record.get(AssessmentSubject), checkNotBlank.andThen(subjectRepository::findIdByCode).andThen(new CheckNotNull<>()));
            asmtTypeId = parserHelper.validate(logMsgPrefix + AssessmentSubtype, record.get(AssessmentSubtype), toTypeCode.andThen(typeRepository::findIdByCode).andThen(new CheckNotNull<>()));

            if (asmtSubjectId == null || asmtTypeId == null) return;

            asmtBuilder = new Builder()
                    .subjectId(asmtSubjectId)
                    .naturalId(asmtNaturalId)
                    .typeId(asmtTypeId)
                    .name(parserHelper.validate(logMsgPrefix + AssessmentName, record.get(AssessmentName), 250, true))
                    .schoolYear(parserHelper.validate(logMsgPrefix + AcademicYear, toSchoolYear(record.get(AcademicYear)), toLong.andThen(toYear)))
                    .label(parserHelper.validate(logMsgPrefix + AssessmentLabel, record.get(AssessmentLabel), 255, true))
                    .version(parserHelper.validate(logMsgPrefix + AssessmentVersion, record.get(AssessmentVersion), 30, false))
                    .gradeId(parserHelper.validate(logMsgPrefix + AssessmentGrade, record.get(AssessmentGrade), toGrade.andThen(gradeRepository::findIdByCode)));

            if (IAB.id() == asmtTypeId) {
                parseIABScores(record, asmtBuilder);
            } else {
                parseNonIABScores(record, asmtBuilder);
            }
        }

        /**
         * SBAC IABs do not play by the same rules as ICA/Summatives
         * It is expected that there are 4 cut-points provided.
         * The first and last are used to get the min/max score and the the second one (between levels 2 and 3) is
         * used for the per-student performance level calculation.
         */
        private void parseIABScores(final CSVRecord record, final Builder asmtBuilder) {
            final List<String> scoreHeaders = discoverOverallScoreHeaders(record);
            if (scoreHeaders == null || scoreHeaders.size() != 5) {
                errorCollector.add(new DataElementError(logMsgPrefix + "ScaledLow1", "n/a", "Missing or mismatched IAB score columns"));
                return;
            }

            asmtBuilder.score(AssessmentScore.builder()
                    .minScore(toScore(scoreHeaders.get(0), record))
                    .cutPoint1(toScoreOptionalForIAB(scoreHeaders.get(1), record))
                    .cutPoint2(toScore(scoreHeaders.get(2), record))
                    .cutPoint3(toScoreOptionalForIAB(scoreHeaders.get(3), record))
                    .maxScore(toScore(scoreHeaders.get(4), record))
                    .build());
        }

        /**
         * For ICA/Summatives:
         * - the max's scale score header must match to the {@link WarehouseSubjectAssessmentScoring#getPerformanceLevelCount()}.
         * - all cut points up to the {@link WarehouseSubjectAssessmentScoring#getPerformanceLevelCount()} must be not null
         * - that is true for both overall and alt scorings
         */
        private void parseNonIABScores(final CSVRecord record, final Builder asmtBuilder) {
            final WarehouseSubjectAssessmentType assessmentType = subjectAssessmentTypeRepository.findBySubjectIdAndAsmtTypeId(asmtSubjectId, asmtTypeId);
            if (assessmentType == null) {
                errorCollector.add(new DataElementError(logMsgPrefix + "AssessmentType", "n/a", "Missing subject assessment type definition"));
                return;
            }
            final WarehouseSubjectAssessmentScoring overallScoring = assessmentType.getScoring(ScoreType.OVERALL);
            if (overallScoring == null) {
                errorCollector.add(new DataElementError(logMsgPrefix + "AssessmentScoring", "Overall", "Missing subject assessment overall scoring definition"));
                return;
            }
            final AssessmentScore overallScore = parseScoring(record, overallScoring, null, discoverOverallScoreHeaders(record));
            if (overallScore != null) {
                asmtBuilder.score(overallScore);
            }

            // If subject allows for alt scoring, parse that assessment score data.
            // First check that the subject expects ALT scoring.
            final WarehouseSubjectAssessmentScoring altScoring = assessmentType.getScoring(ScoreType.ALT);
            if (altScoring == null) {
                return;
            }
            // Then use the subject alt score metadata to determine how many ALT scorings to expect
            // (all we need from the scorings is the id, thus the mapped stream)
            int altHeaderIndex = 0;
            for (final Integer subjectScoreId : subjectScoreRepository
                    .findBySubjectIdAndAsmtTypeIdAndScoreTypeId(asmtSubjectId, asmtTypeId, ScoreType.ALT.id())
                    .stream().map(WarehouseSubjectScore::getId).collect(Collectors.toList())) {
                final AssessmentScore altScore = parseScoring(record, altScoring, subjectScoreId, discoverAltScoreHeaders(record, ++altHeaderIndex));
                if (altScore != null) {
                    asmtBuilder.score(altScore);
                }
            }
        }

        private AssessmentScore parseScoring(final CSVRecord record,
                                             final WarehouseSubjectAssessmentScoring scoring,
                                             final Integer subjectScoreId,
                                             final List<String> scoreHeaders) {
            if (scoreHeaders == null) {
                // if we get here, we expect the score columns to exist so it's an error if they don't
                errorCollector.add(new DataElementError(logMsgPrefix + scoring.getType(), "n/a", "Missing score columns"));
                return null;
            }

            final int performanceLevelCount = scoring.getPerformanceLevelCount();
            if (performanceLevelCount != scoreHeaders.size() - 1) {
                errorCollector.add(new DataElementError(logMsgPrefix + scoring.getType().toString(), "n/a",
                        "Number of score columns (" + (scoreHeaders.size()-1) +
                        ") does not match expected level count (" + performanceLevelCount + ")"));
                return null;
            }

            final AssessmentScore.Builder builder = AssessmentScore.builder()
                    .subjectScoreId(subjectScoreId)
                    .minScore(toScore(scoreHeaders.get(0), record))
                    .maxScore(toScore(scoreHeaders.get(performanceLevelCount), record));
            for (int i = 1; i < performanceLevelCount; ++i) {
                final String header = scoreHeaders.get(i);
                final Double score = toScore(header, record);
                if (scoring.getMinScore() != null && score < scoring.getMinScore()) {
                    errorCollector.add(new DataElementError(logMsgPrefix + header, ""+score, "Assessment cutpoint less than subject min score"));
                } else if (scoring.getMaxScore() != null && score > scoring.getMaxScore()) {
                    errorCollector.add(new DataElementError(logMsgPrefix + header, ""+score, "Assessment cutpoint greater than subject max score"));
                }
                builder.cutPoint(i, score);
            }
            return builder.build();
        }

        private void addItem(final CSVRecord record) {
            if (asmtSubjectId == null) return;

            final Item item = itemParser.parse(record, errorCollector, asmtNaturalId, asmtSubjectId);
            if (item != null) {
                asmtBuilder.item(item);
            }
        }

        private boolean isSkippable(final CSVRecord record) {
            return Iterables.all(record, value -> value == null || value.trim().isEmpty());
        }

        private boolean sameAssessment(final CSVRecord record) {
            return record.get(AssessmentId).trim().equals(asmtNaturalId);
        }

        private Assessment safeBuild(final DataElementErrorCollector elementErrorCollector) {
            if (errorCollector.isEmpty()) return asmtBuilder.build();

            elementErrorCollector.addAll(errorCollector);
            return null;
        }

        private Double toScore(final String scoreColHeader, final CSVRecord record) {
            return parserHelper.validate(logMsgPrefix + scoreColHeader, record.get(scoreColHeader), toDouble);
        }

        private Double toScoreOptionalForIAB(final String scoreColHeader, final CSVRecord record) {
            final String rawValue = record.get(scoreColHeader);
            if (asmtTypeId != null && IAB.id() == asmtTypeId && Strings.emptyToNull(rawValue) == null) return null;
            return parserHelper.validate(logMsgPrefix + scoreColHeader, rawValue, toDouble);
        }

        /**
         * This helper inspects the headers and returns the columns to use to get the cut-points
         * and min/max scores. This will be an ordered list like: <pre>
         * ScaledLow1, ScaledLow2, ScaledLow3, ScaledLow4, ScaledHigh4
         * </pre>
         *
         * @param record record
         * @return list of headers
         */
        private List<String> discoverOverallScoreHeaders(final CSVRecord record) {
            if (hasValue(record, "ScaledLow1") || hasValue(record, "OverallLow1")) {
                return collectScoreHeaders(record, hasValue(record, "ScaledLow1") ? "Scaled" : "Overall");
            }
            return null;
        }

        /**
         * This helper inspects the headers and returns the columns to use to get the cut-points
         * and min/max scores for a particular ALT scoring. Result will be like: <pre>
         * Alt1Low1, Alt1Low2, Alt1High2
         * </pre>
         * @param record record
         * @param alt which ALT to look for, e.g. 1. Corresponds to data-order defined for alt score
         * @return list of headers
         */
        private List<String> discoverAltScoreHeaders(final CSVRecord record, final int alt) {
            final String prefix = "Alt" + alt;
            if (hasValue(record, prefix+"Low1")) {
                return collectScoreHeaders(record, prefix);
            } else {
                return null;
            }
        }

        private List<String> collectScoreHeaders(final CSVRecord record, final String prefix) {
            final List<String> headers = newArrayList();
            for (int i = 1; i <= 6; ++i) {
                final String header = prefix + "Low" + i;
                if (!hasValue(record, header)) break;
                headers.add(header);
            }
            headers.add(prefix + "High" + headers.size());
            return headers;
        }

        private boolean hasValue(final CSVRecord record, final String name) {
            try {
                return record.isSet(name) && StringUtils.hasText(record.get(name));
            } catch (final IllegalArgumentException ignored) {
                return false;
            }
        }
    }

    private static final Function<String, String> toTypeCode = value -> {
        Precondition.checkNotBlank(value);
        if ("summative".equalsIgnoreCase(value)) return "sum";
        return value.toLowerCase();
    };

    static String toSchoolYear(final String value) {
        Precondition.checkNotBlank(value);
        // if the value has a hyphen then split and return the last value, e.g. 2016-2017
        // otherwise just return the value ...
        final String[] split = value.split("-");
        return split.length == 0 ? value : split[split.length - 1];
    }
}
