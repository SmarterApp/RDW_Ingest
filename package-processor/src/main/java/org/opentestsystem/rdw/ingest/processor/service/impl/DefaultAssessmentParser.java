package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.ScoreType;
import org.opentestsystem.rdw.common.model.assessment.Assessment;
import org.opentestsystem.rdw.common.model.assessment.AssessmentSerializationService;
import org.opentestsystem.rdw.common.model.assessment.Scoring;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseAssessment;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseAssessmentScoring;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectAssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectScoreRepository;

import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toGrade;

@Service
class DefaultAssessmentParser implements AssessmentParser {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAssessmentParser.class);

    private final AssessmentSerializationService assessmentSerializationService;
    private final GradeRepository gradeRepository;
    private final AssessmentTypeRepository typeRepository;
    private final SubjectRepository subjectRepository;
    private final SubjectAssessmentTypeRepository subjectAssessmentTypeRepository;
    private final SubjectScoreRepository subjectScoreRepository;
    private final ItemValidator itemValidator;

    @Autowired
    public DefaultAssessmentParser(final AssessmentSerializationService assessmentSerializationService,
                                   final GradeRepository gradeRepository,
                                   final ItemValidator itemValidator,
                                   final SubjectRepository subjectRepository,
                                   final AssessmentTypeRepository assessmentTypeRepository,
                                   final SubjectAssessmentTypeRepository subjectAssessmentTypeRepository,
                                   final SubjectScoreRepository subjectScoreRepository) {
        this.assessmentSerializationService = assessmentSerializationService;
        this.gradeRepository = gradeRepository;
        this.typeRepository = assessmentTypeRepository;
        this.subjectRepository = subjectRepository;
        this.subjectAssessmentTypeRepository = subjectAssessmentTypeRepository;
        this.subjectScoreRepository = subjectScoreRepository;
        this.itemValidator = itemValidator;
    }

    public List<WarehouseAssessment> parse(final byte[] assessmentPackage, final DataElementErrorCollector errorCollector) {

        try (final InputStream is = new ByteArrayInputStream(assessmentPackage)) {
            return assessmentSerializationService.parse(is).stream()
                    .map(a -> validate(a, errorCollector))
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());

        } catch (final IllegalArgumentException e) {
            logger.info("Invalid Assessment package: {}", e.getMessage());
            throw new ImportException(BAD_DATA, e.getMessage());
        } catch (final IOException e) {
            logger.warn("Unable to read Assessment package", e);
            throw new ImportException(BAD_FORMAT, "Unable to read Assessment package: " + e.getMessage());
        }
    }

    /**
     * Helper method to validate an assessment and convert it to the repository data model. The
     * serialization service validates that required fields are set, etc. This method further
     * validates that referenced objects exist, that field lengths fit in the database schema, etc.
     * <p>
     * If there are validation errors, it adds them to the error collector and returns null.
     * (Otherwise, there are no errors and it returns a newly constructed assessment.)
     * </p>
     *
     * @param assessment assessment
     * @param batchErrorCollector overall error collector
     * @return converted assessment, null if there were validation errors
     */
    private WarehouseAssessment validate(final Assessment assessment, final DataElementErrorCollector batchErrorCollector) {
        // accumulate local errors separately
        final ParserHelper parserHelper = new ParserHelper();
        final DataElementErrorCollector errorCollector = parserHelper.getElementErrorCollector();

        final WarehouseAssessment.Builder builder = WarehouseAssessment.builder();

        final String naturalId = parserHelper.validate("AssessmentId", assessment.getId(), 250, true);
        final String prefix = "[" + naturalId + "], ";

        final int subjectId = parserHelper.validate(prefix + "AssessmentSubject", assessment.getSubject(),
                ((Function<String, Integer>) subjectRepository::findIdByCode).andThen(new CheckNotNull<>()));
        final int typeId = parserHelper.validate(prefix + "AssessmentType", assessment.getType().code(),
                ((Function<String, Integer>) typeRepository::findIdByCode).andThen(new CheckNotNull<>()));

        final WarehouseSubjectAssessmentType type = parserHelper.validate(prefix + "SubjectAssessment", "n/a",
                ignored -> subjectAssessmentTypeRepository.findBySubjectIdAndAsmtTypeId(subjectId, typeId));

        builder.naturalId(naturalId)
                .subjectId(subjectId)
                .typeId(typeId)
                .name(parserHelper.validate(prefix + "AssessmentName", assessment.getName(), 250, true))
                .label(parserHelper.validate(prefix + "AssessmentLabel", assessment.getLabel(), 250, true))
                .schoolYear(assessment.getSchoolYear())
                .gradeId(parserHelper.validate(prefix + "AssessmentGrade", assessment.getGrade(), toGrade.andThen(gradeRepository::findIdByCode)))
                .version(parserHelper.validate(prefix + "AssessmentVersion", assessment.getVersion(), 30, false))
        ;

        // validate scoring
        // IAB has hard-coded cut-point level rules
        // ICA/Summative requires the subject assessment type metadata to validate
        if (IAB.id() == typeId) {
            builder.score(validateScoring(assessment.getOverallScoring(), 4, null, errorCollector, prefix));
        } else if (type != null) {
            // for Summatives and ICA, copy the overall and (optional) alt scorings
            // validating the expected level counts, and cut-points within min/max
            builder.score(validateScoring(assessment.getOverallScoring(),
                type.getScoring(ScoreType.OVERALL).getPerformanceLevelCount(), null, errorCollector, prefix));
            if (type.getScoring(ScoreType.ALT) != null) {
                // Use the subject alt score metadata to determine how many ALT scorings to expect
                // (all we need from the scorings is the id, thus the mapped stream)
                final List<Scoring> altScorings = assessment.getAltScorings();
                final List<Integer> altScoreIds = subjectScoreRepository
                        .findBySubjectIdAndAsmtTypeIdAndScoreTypeId(subjectId, typeId, ScoreType.ALT.id())
                        .stream().map(WarehouseSubjectScore::getId).collect(Collectors.toList());
                if (altScorings.size() != altScoreIds.size()) {
                    errorCollector.add(new DataElementError(prefix + "AltScores", ""+altScorings.size(),
                            "Does not match expected number of alt scorings (" + altScoreIds.size() + ")"));
                } else {
                    for (int a = 0; a < altScorings.size(); ++a) {
                        builder.score(validateScoring(altScorings.get(a),
                                                      type.getScoring(ScoreType.ALT).getPerformanceLevelCount(),
                                                      altScoreIds.get(a),
                                                      errorCollector,
                                                      prefix));
                    }
                }
            }
        }

        builder.items(itemValidator.validate(assessment.getItems(), errorCollector, prefix, subjectId));

        if (errorCollector.isEmpty()) {
            return builder.build();
        } else {
            batchErrorCollector.addAll(errorCollector);
            return null;
        }
    }

    private static WarehouseAssessmentScoring validateScoring(final Scoring scoring,
                                                              final int expectedLevelCount,
                                                              final Integer subjectScoreId,
                                                              final DataElementErrorCollector errorCollector,
                                                              final String prefix) {
        final List<Scoring.LevelRange> levels = scoring.getLevelRanges();

        if (levels.size() != expectedLevelCount) {
            errorCollector.add(new DataElementError(prefix + "Scores", ""+levels.size(),
                    "Does not match expected level count (" + expectedLevelCount + ")"));
        }

        final WarehouseAssessmentScoring.Builder builder = WarehouseAssessmentScoring.builder()
                .subjectScoreId(subjectScoreId)
                .minScore(scoring.getMinScore())
                .maxScore(scoring.getMaxScore());
        final double minScore = scoring.getMinScore() != null ? scoring.getMinScore() : Double.MIN_VALUE;
        final double maxScore = scoring.getMaxScore() != null ? scoring.getMaxScore() : Double.MAX_VALUE;
        for (int s = 1; s < levels.size(); ++s) {
            final double cutPoint = levels.get(s).getLow();
            if (cutPoint < minScore) {
                errorCollector.add(new DataElementError(prefix + "Cutpoint" + s, ""+cutPoint, "Cutpoint less than subject min score"));
            } else if (cutPoint > maxScore) {
                errorCollector.add(new DataElementError(prefix + "Cutpoint" + s, ""+cutPoint, "Cutpoint greater than subject max score"));
            }
            builder.cutPoint(s, levels.get(s).getLow());
        }
        return builder.build();
    }
}
