package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import com.google.common.collect.Iterables;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.config.SbacScoreConfiguration;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.common.util.Precondition;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Assessment.Builder;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.common.model.AssessmentType.IAB;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toGrade;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLong;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toYear;
import static org.springframework.util.StringUtils.hasText;


@Service
class DefaultAssessmentParser implements AssessmentParser {

    private final SbacScoreConfiguration scoreConfiguration;
    private final GradeRepository gradeRepository;
    private final AssessmentTypeRepository typeRepository;
    private final SubjectRepository subjectRepository;
    private final ItemParser itemParser;

    @Autowired
    public DefaultAssessmentParser(final SbacScoreConfiguration scoreConfiguration,
                                   final GradeRepository gradeRepository,
                                   final ItemParser itemParser,
                                   final SubjectRepository subjectRepository,
                                   final AssessmentTypeRepository assessmentTypeRepository) {
        this.scoreConfiguration = scoreConfiguration;
        this.gradeRepository = gradeRepository;
        this.typeRepository = assessmentTypeRepository;
        this.subjectRepository = subjectRepository;
        this.itemParser = itemParser;
    }

    public List<Assessment> parse(final byte[] assessmentPackage, final DataElementErrorCollector elementErrorCollector) {
        // at this point we need a Reader so assume UTF-8 payload
        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(assessmentPackage), Charset.forName("utf8"))) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180
                    .withFirstRecordAsHeader()
                    .withCommentMarker('#')
                    .parse(reader).iterator();

            final List<Assessment> assessments = newArrayList();
            if (!recordIterator.hasNext()) return assessments;

            final AssessmentParserHelper assessmentParserHelper = new AssessmentParserHelper();

            assessmentParserHelper.newAssessmentRecord(recordIterator.next());
            while (recordIterator.hasNext()) {
                final CSVRecord nextRecord = recordIterator.next();
                if (assessmentParserHelper.isSkippable(nextRecord)) {
                    continue;
                }
                if (!assessmentParserHelper.sameAssessment(nextRecord)) {
                    assessments.add(assessmentParserHelper.safeBuild(elementErrorCollector));
                    assessmentParserHelper.newAssessmentRecord(nextRecord);
                } else {
                    assessmentParserHelper.addItem(nextRecord);
                }
            }
            assessments.add(assessmentParserHelper.safeBuild(elementErrorCollector));

            // if there are any errors in the collector then the assessments may contain nulls, don't return it
            return elementErrorCollector.isEmpty() ? assessments : newArrayList();

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private class AssessmentParserHelper {
        private final String AssessmentSubject = "AssessmentSubject";
        private final String AssessmentName = "AssessmentName";
        private final String AssessmentLabel = "AssessmentLabel";
        private final String AssessmentVersion = "AssessmentVersion";
        private final String AcademicYear = "AcademicYear";
        private final String AssessmentGrade = "AssessmentGrade";
        private final String AssessmentSubtype = "AssessmentSubtype";
        private final String ScaledLow1 = "ScaledLow1";
        private final String ScaledHigh1 = "ScaledHigh1";
        private final String ScaledHigh2 = "ScaledHigh2";
        private final String ScaledHigh3 = "ScaledHigh3";
        private final String ScaledHigh4 = "ScaledHigh4";
        private final String AssessmentId = "AssessmentId";

        private final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper(errorCollector);
        private String asmtNaturalId;
        private Integer asmtSubjectId;
        private Integer asmtTypeId;
        private Assessment.Builder asmtBuilder;
        private String logMsgPrefix;

        void newAssessmentRecord(final CSVRecord record) {
            // collect errors separately for each assessment
            errorCollector.reset();
            parse(record);
            addItem(record);
        }

        void parse(final CSVRecord record) {
            asmtNaturalId = parserHelper.validate(AssessmentId, record.get(AssessmentId), 250, true);
            logMsgPrefix = "[" + asmtNaturalId + "], ";
            asmtSubjectId = parserHelper.validate(logMsgPrefix + AssessmentSubject, record.get(AssessmentSubject), checkNotBlank.andThen(subjectRepository::findIdByCode).andThen(new CheckNotNull<>()));
            asmtTypeId = parserHelper.validate(logMsgPrefix + AssessmentSubtype, record.get(AssessmentSubtype), toTypeCode.andThen(typeRepository::findIdByCode).andThen(new CheckNotNull<>()));

            asmtBuilder = new Builder()
                    .subjectId(asmtSubjectId)
                    .naturalId(asmtNaturalId)
                    .typeId(asmtTypeId)
                    .name(parserHelper.validate(logMsgPrefix + AssessmentName, record.get(AssessmentName), 250, true))
                    .schoolYear(parserHelper.validate(logMsgPrefix + AcademicYear, toSchoolYear(record.get(AcademicYear)), toLong.andThen(toYear)))
                    .label(parserHelper.validate(logMsgPrefix + AssessmentLabel, record.get(AssessmentLabel), 255, true))
                    .version(parserHelper.validate(logMsgPrefix + AssessmentVersion, record.get(AssessmentVersion), 30, false))
                    .gradeId(parserHelper.validate(logMsgPrefix + AssessmentGrade, record.get(AssessmentGrade), toGrade.andThen(gradeRepository::findIdByCode).andThen(new CheckNotNull<>())))
                    .minScore(parserHelper.validate(logMsgPrefix + ScaledLow1, record.get(ScaledLow1), this::toScore))
                    .maxScore(parserHelper.validate(logMsgPrefix + ScaledHigh4, record.get(ScaledHigh4), this::toScore))
                    .cutPoint1(optionalForIAB(logMsgPrefix + ScaledHigh1, record.get(ScaledHigh1)))
                    .cutPoint2(parserHelper.validate(logMsgPrefix + ScaledHigh2, record.get(ScaledHigh2), this::toScore))
                    .cutPoint3(optionalForIAB(logMsgPrefix + ScaledHigh3, record.get(ScaledHigh3)));
        }

        void addItem(final CSVRecord record) {
            if (asmtSubjectId != null) asmtBuilder.item(itemParser.parse(record, errorCollector, asmtNaturalId, asmtSubjectId));
        }

        boolean isSkippable(final CSVRecord record) {
            return Iterables.all(record, value -> value == null || value.trim().isEmpty());
        }

        boolean sameAssessment(final CSVRecord record) {
            return record.get(AssessmentId).trim().equals(asmtNaturalId);
        }

        Assessment safeBuild(final DataElementErrorCollector elementErrorCollector) {
            if (errorCollector.isEmpty()) return asmtBuilder.build();

            elementErrorCollector.addAll(errorCollector);
            return null;
        }

        // could put this in ParserHelper but it is pretty specialized
        private Double optionalForIAB(final String name, final String rawValue) {
            if (asmtTypeId != null && IAB.id() == asmtTypeId && Strings.emptyToNull(rawValue) == null) return null;
            return parserHelper.validate(name, rawValue, this::toScore);
        }

        private Double toScore(final String value) {
            if (hasText(value)) {
                final Double score = Double.parseDouble(value);
                if (score >= scoreConfiguration.getScaleScore().getMin() && score <= scoreConfiguration.getScaleScore().getMax()) return score;
            }
            throw new IllegalArgumentException("invalid value, must be " + scoreConfiguration.getScaleScore().getMin() + " - " + scoreConfiguration.getScaleScore().getMax());

        }
    }

    private static final Function<String, String> toTypeCode = value -> {
        Precondition.checkNotBlank(value);
        if ("summative".equalsIgnoreCase(value)) return "sum";
        return value.toLowerCase();
    };

    private static String toSchoolYear(final String value) {
        Precondition.checkNotBlank(value);
        final String[] split = value.split("-");
        return split.length == 0 ? value : split[split.length - 1]; //nothing to split, so return the value
        //able to split (e.g. 2016-2017), return last value
    }
}