package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.ingest.processor.service.AssessmentParser;
import org.opentestsystem.rdw.ingest.processor.service.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.utils.ParserHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * AssessmentParserImpl - parses and validates assessment parameters from package
 */
@Service
public class DefaultAssessmentParser implements AssessmentParser {
    private final GradeRepository gradeRepository;
    private final SubjectRepository subjectRepository;
    private final AssessmentTypeRepository typeRepository;

    private final String ASSESSMENT_ID = "AssessmentId";
    private final String ASSESSMENT_NAME = "AssessmentName";
    private final String ASSESSMENT_LABEL = "AssessmentLabel";
    private final String ASSESSMENT_VERSION = "AssessmentVersion";
    private final String ACADEMIC_YEAR = "AcademicYear";
    private final String ASSESSMENT_GRADE = "AssessmentGrade";
    private final String ASSESSMENT_SUBJECT = "AssessmentSubject";
    private final String ASSESSMENT_TYPE = "AssessmentSubtype";
    private final String CUTPOINT_LOW = "ScaledHigh1";
    private final String CUTPOINT_MIDDLE = "ScaledHigh2";
    private final String CUTPOINT_HIGH = "ScaledHigh3";
    private final String MIN_SCORE = "ScaledLow1";
    private final String MAX_SCORE = "ScaledHigh4";


    @Autowired
    public DefaultAssessmentParser(final GradeRepository gradeRepository,
                                   final SubjectRepository subjectRepository,
                                   final AssessmentTypeRepository assessmentTypeRepository) {
        this.gradeRepository = gradeRepository;
        this.subjectRepository = subjectRepository;
        this.typeRepository = assessmentTypeRepository;
    }

    //This assumes that the column names actually exist. If they don't then an exception will be thrown.

    /**
     * Parse function to validate and extract an {@link Assessment}. Any errors found are gathered in a central error collector.
     *
     * @param record         the {@link CSVRecord} to parse
     * @param errorCollector error collector
     * @return {@link Assessment} if successfully validated and parsed, null otherwise
     */
    public Assessment parse(final CSVRecord record, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);
        Assessment.Builder assessmentBuilder = new Assessment.Builder();
        assessmentBuilder
                .naturalId(parserHelper.basicValidation(ASSESSMENT_ID, record.get(ASSESSMENT_ID).trim(),
                        Strings::emptyToNull))
                .name(parserHelper.basicValidation(ASSESSMENT_NAME, record.get(ASSESSMENT_NAME).trim(),
                        Strings::emptyToNull))
                .schoolYear(parserHelper.basicValidation(ACADEMIC_YEAR, toSchoolYear(record.get(ACADEMIC_YEAR).trim()),
                        Ints::tryParse))
                .label(parserHelper.basicValidation(ASSESSMENT_LABEL, record.get(ASSESSMENT_LABEL).trim(),
                        Strings::emptyToNull))
                .version(parserHelper.basicValidation(ASSESSMENT_VERSION, record.get(ASSESSMENT_VERSION).trim(),
                        Strings::emptyToNull));

        //Lookup grade code, subject code, and type code from database. If they are there, then add parameter and finish building
        //Otherwise, invalidate the parse.
        assessmentBuilder
                .gradeId(parserHelper.repositoryValidation(ASSESSMENT_GRADE, record.get(ASSESSMENT_GRADE).trim(),
                        this::toGradeCodeOrNull, gradeRepository::findIdByCode))
                .subjectId(parserHelper.repositoryValidation(ASSESSMENT_SUBJECT, record.get(ASSESSMENT_SUBJECT).trim(),
                        Strings::emptyToNull, subjectRepository::findIdByName))
                .typeId(parserHelper.repositoryValidation(ASSESSMENT_TYPE, record.get(ASSESSMENT_TYPE).trim(),
                        this::toTypeCodeOrNull, typeRepository::findIdByCode));

        assessmentBuilder.cutPoints(parserHelper.basicValidation(CUTPOINT_LOW, record.get(CUTPOINT_LOW).trim(), this::toScaleScore),
                parserHelper.basicValidation(CUTPOINT_MIDDLE, record.get(CUTPOINT_MIDDLE).trim(), this::toScaleScore),
                parserHelper.basicValidation(CUTPOINT_HIGH, record.get(CUTPOINT_HIGH).trim(), this::toScaleScore));

        assessmentBuilder.minScore(parserHelper.basicValidation(MIN_SCORE, record.get(MIN_SCORE).trim(), this::toScaleScore));
        assessmentBuilder.maxScore(parserHelper.basicValidation(MAX_SCORE, record.get(MAX_SCORE).trim(), this::toScaleScore));

        return errorCollector.isEmpty() ? assessmentBuilder.build() : null;
    }

    //Not sure if this is OBE (overcome by events) or not, but in case the tabulator isn't outputting the right
    //data, this should help convert it to what the database expects.
    private String toTypeCodeOrNull(final String value) throws IllegalArgumentException {
        if (value.length() == 0)
            return null;  //returning null helps to avoid hitting the database for checking an empty string
        if ("summative".equalsIgnoreCase(value)) return "sum";
        return value.toLowerCase();
    }

    private String toGradeCodeOrNull(final String value) {
        if (value.length() == 0)
            return null; //returning null helps to avoid hitting the database for checking an empty string
        return value.length() == 1 ? "0" + value : value; //Grade codes need to be two characters. e.g. KG, PK, 01, 02, 11, 12..
    }

    private String toSchoolYear(final String value) {
        String[] split = value.split("-");
        return split.length == 0 ? value : split[split.length - 1]; //nothing to split, so return the value
        //able to split (e.g. 2016-2017), return last value
    }

    private double toScaleScore(final String value) {
        final Double scaleScore = Doubles.tryParse(value);
        return scaleScore == null ? 0.0 : scaleScore;
    }

}