package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Assessment.Builder;
import org.opentestsystem.rdw.ingest.processor.model.AssessmentType;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.List;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.processor.service.impl.DefaultAssessmentParser.AssessmentParserHelper.AssessmentId;


@Service
class DefaultAssessmentParser implements AssessmentParser {

    private final GradeRepository gradeRepository;
    private final AssessmentTypeRepository typeRepository;
    private final SubjectRepository subjectRepository;
    private final ItemParser itemParser;

    @Autowired
    public DefaultAssessmentParser(final GradeRepository gradeRepository,
                                   final ItemParser itemParser,
                                   final SubjectRepository subjectRepository,
                                   final AssessmentTypeRepository assessmentTypeRepository) {
        this.gradeRepository = gradeRepository;
        this.typeRepository = assessmentTypeRepository;
        this.subjectRepository = subjectRepository;
        this.itemParser = itemParser;
    }

    public List<Assessment> parse(final byte[] assessmentPackage, final DataElementErrorCollector elementErrorCollector) {
        // at this point we need a Reader so assume UTF-8 payload
        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(assessmentPackage), Charset.forName("utf8"))) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(reader).iterator();
            if (!recordIterator.hasNext()) throw new ImportException(BAD_DATA, "no assessment package records");

            final AssessmentParserHelper assessmentParserHelper = new AssessmentParserHelper(itemParser, gradeRepository, subjectRepository, typeRepository);
            final List<Assessment> assessments = newArrayList();

            assessmentParserHelper.newAssessmentRecord(recordIterator.next());
            while (recordIterator.hasNext()) {
                final CSVRecord nextRecord = recordIterator.next();

                if (!nextRecord.get(AssessmentId).trim().equals(assessmentParserHelper.getAsmtNaturalId())) {
                    assessments.add(assessmentParserHelper.safeBuild(elementErrorCollector));
                    assessmentParserHelper.newAssessmentRecord(nextRecord);
                } else {
                    assessmentParserHelper.addItem(nextRecord);
                }
            }
            assessments.add(assessmentParserHelper.safeBuild(elementErrorCollector));

            if (!elementErrorCollector.isEmpty()) return newArrayList();

            return assessments;

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    static class AssessmentParserHelper {
        final static String AssessmentSubject = "AssessmentSubject";
        final static String AssessmentName = "AssessmentName";
        final static String AssessmentLabel = "AssessmentLabel";
        final static String AssessmentVersion = "AssessmentVersion";
        final static String AcademicYear = "AcademicYear";
        final static String AssessmentGrade = "AssessmentGrade";
        final static String AssessmentSubtype = "AssessmentSubtype";
        final static String ScaledLow1 = "ScaledLow1";
        final static String ScaledHigh1 = "ScaledHigh1";
        final static String ScaledHigh2 = "ScaledHigh2";
        final static String ScaledHigh3 = "ScaledHigh3";
        final static String ScaledHigh4 = "ScaledHigh4";
        final static String AssessmentId = "AssessmentId";

        private final GradeRepository gradeRepository;
        private final AssessmentTypeRepository typeRepository;
        private final ItemParser itemParser;
        private final SubjectRepository subjectRepository;

        private DataElementErrorCollector elementErrorCollector;
        private String asmtNaturalId;
        private Integer asmtSubject;
        private Assessment.Builder asmtBuilder;

        public AssessmentParserHelper(final ItemParser itemParser,
                                      final GradeRepository gradeRepository,
                                      final SubjectRepository subjectRepository,
                                      final AssessmentTypeRepository assessmentTypeRepository) {
            this.gradeRepository = gradeRepository;
            this.typeRepository = assessmentTypeRepository;
            this.itemParser = itemParser;
            this.subjectRepository = subjectRepository;
        }

        public void newAssessmentRecord(final CSVRecord record) {
            elementErrorCollector = new DataElementErrorCollector();
            parse(record);
            addItem(record);
        }

        public void parse(final CSVRecord record) {
            final ParserHelper parserHelper = new ParserHelper(elementErrorCollector);
            asmtNaturalId = parserHelper.basicValidation(AssessmentId, record.get(AssessmentId), Strings::emptyToNull);
            asmtSubject = parserHelper.repositoryValidation(AssessmentSubject, record.get(AssessmentSubject), Strings::emptyToNull, subjectRepository::findIdByCode);
            asmtBuilder = new Builder()
                    .subjectId(asmtSubject)
                    .naturalId(asmtNaturalId)
                    .typeId(parserHelper.repositoryValidation(AssessmentSubtype, record.get(AssessmentSubtype), AssessmentParserHelper::toTypeCodeOrNull, typeRepository::findIdByCode))
                    .name(parserHelper.basicValidation(AssessmentName, record.get(AssessmentName), Strings::emptyToNull))
                    .schoolYear(parserHelper.basicValidation(AcademicYear, toSchoolYear(record.get(AcademicYear)), Ints::tryParse))
                    .label(parserHelper.basicValidation(AssessmentLabel, record.get(AssessmentLabel), Strings::emptyToNull))
                    .version(parserHelper.basicValidation(AssessmentVersion, record.get(AssessmentVersion), Strings::emptyToNull))
                    .gradeId(parserHelper.repositoryValidation(AssessmentGrade, record.get(AssessmentGrade), AssessmentParserHelper::toGradeCodeOrNull, gradeRepository::findIdByCode))
                    .minScore(parserHelper.basicValidation(ScaledLow1, record.get(ScaledLow1), AssessmentParserHelper::toScaleScore))
                    .maxScore(parserHelper.basicValidation(ScaledHigh4, record.get(ScaledHigh4), AssessmentParserHelper::toScaleScore))
                    .cutPoint1(parserHelper.basicValidation(ScaledHigh1, record.get(ScaledHigh1), AssessmentParserHelper::toScaleScore))
                    .cutPoint2(parserHelper.basicValidation(ScaledHigh2, record.get(ScaledHigh2), AssessmentParserHelper::toScaleScore))
                    .cutPoint3(parserHelper.basicValidation(ScaledHigh3, record.get(ScaledHigh3), AssessmentParserHelper::toScaleScore));
        }

        public void addItem(final CSVRecord record) {
            if (asmtSubject != null) asmtBuilder.item(itemParser.parse(record, elementErrorCollector, asmtSubject));
        }

        public String getAsmtNaturalId() {
            return asmtNaturalId;
        }

        public Assessment safeBuild(final DataElementErrorCollector elementErrorCollector) {
            elementErrorCollector.addAll(this.elementErrorCollector);
            return elementErrorCollector.isEmpty() ? asmtBuilder.build() : null;
        }

        static String toTypeCodeOrNull(final String value) throws IllegalArgumentException {
            if (isNullOrEmpty(value)) return null;
            if ("summative".equalsIgnoreCase(value)) return "sum";
            return value.toLowerCase();
        }

        static String toGradeCodeOrNull(final String value) {
            if (isNullOrEmpty(value)) return null; //returning null helps to avoid hitting the database for checking an empty string
            return value.length() == 1 ? "0" + value : value; //Grade codes need to be two characters. e.g. KG, PK, 01, 02, 11, 12..
        }

        static String toSchoolYear(final String value) {
            String[] split = value.split("-");
            return split.length == 0 ? value : split[split.length - 1]; //nothing to split, so return the value
            //able to split (e.g. 2016-2017), return last value
        }

        static double toScaleScore(final String value) {
            final Double scaleScore = Doubles.tryParse(value);
            return scaleScore == null ? 0.0 : scaleScore;
        }
    }
}