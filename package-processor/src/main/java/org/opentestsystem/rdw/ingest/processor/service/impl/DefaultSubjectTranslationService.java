package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Joiner;
import com.google.common.collect.Queues;
import org.opentestsystem.rdw.common.model.subject.DepthOfKnowledge;
import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevels;
import org.opentestsystem.rdw.common.model.subject.ReportAssessmentType;
import org.opentestsystem.rdw.common.model.subject.ReportClaim;
import org.opentestsystem.rdw.common.model.subject.ReportGrade;
import org.opentestsystem.rdw.common.model.subject.ReportPerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.Standard;
import org.opentestsystem.rdw.common.model.subject.SubScoring;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.common.model.subject.Target;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectTranslationRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectTranslationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.apache.http.util.TextUtils.isBlank;

/**
 * Default implementation of a SubjectTranslationService
 */
@Service
class DefaultSubjectTranslationService implements SubjectTranslationService {

    private final SubjectTranslationRepository repository;

    @Autowired
    public DefaultSubjectTranslationService(final SubjectTranslationRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final String subjectCode = subject.getCode();

        final MessageContext context = new MessageContext(repository.findBySubject(subjectCode));
        context.push("subject").push(subjectCode);
        context.setMessage("name", subject.getName());

        appendAssessmentTypes(context, subject.getAssessmentTypes());
        appendDepthsOfKnowledge(context, subject.getDepthsOfKnowledge());
        appendReportGrades(context, subject.getReportGrades());
        appendClaims(context, subject.getClaims());
        appendStandards(context, subject.getStandards());

        repository.create(subjectCode, context.getNewMessages());
        repository.update(subjectCode, context.getUpdatedMessages());
        repository.delete(subjectCode, context.getStaleMessageKeys());
    }

    private void appendAssessmentTypes(final MessageContext context, final List<SubjectAssessmentType> assessmentTypes) {
        for (final SubjectAssessmentType assessmentType : assessmentTypes) {
            context.push("asmt-type").push(assessmentType.getCode());
            appendPerformanceLevels(context, assessmentType.getPerformanceLevels());

            final SubScoring subScoring = assessmentType.getSubScoring();
            if (subScoring != null) {
                context.push("sub-score");
                appendPerformanceLevels(context, subScoring.getPerformanceLevels());
                context.pop();
            }

            context.pop().pop();
        }
    }

    private void appendPerformanceLevels(final MessageContext context, final PerformanceLevels performanceLevels) {
        if (performanceLevels == null) return;

        context.push("level");
        for (final PerformanceLevel performanceLevel : performanceLevels.getPerformanceLevels()) {
            context.push(String.valueOf(performanceLevel.getLevel()));
            context.setMessage("name", performanceLevel.getName());
            context.setMessage("color", performanceLevel.getColor());
            context.pop();
        }
        context.pop();
    }

    private void appendDepthsOfKnowledge(final MessageContext context, final List<DepthOfKnowledge> depths) {
        context.push("dok");

        for (final DepthOfKnowledge depth : depths) {
            context.push(String.valueOf(depth.getLevel()));
            context.setMessage("name", depth.getName());
            context.pop();
        }

        context.pop();
    }

    private void appendReportGrades(final MessageContext context, final List<ReportGrade> reportGrades) {
        context.push("report-grade");
        for (final ReportGrade grade : reportGrades) {
            context.push(grade.getCode());

            for (final ReportAssessmentType type : grade.getReportAssessmentTypes()) {
                context.push("asmt-type").push(type.getCode());

                context.push("overall");
                context.setMessage("title", type.getOverallAchievementMessage());
                appendReportPerformanceLevels(context, type.getReportPerformanceLevels());
                context.pop();

                context.push("claim");
                context.setMessage("title", type.getClaimAchievementMessage());
                for (final ReportClaim claim : type.getReportClaims()) {
                    context.push(claim.getCode());
                    appendReportPerformanceLevels(context, claim.getPerformanceLevels());
                    context.pop();
                }
                context.pop().pop().pop();
            }

            context.pop();
        }
        context.pop();
    }

    private void appendReportPerformanceLevels(final MessageContext context, final Collection<ReportPerformanceLevel> levels) {
        context.push("level");
        for (final ReportPerformanceLevel level : levels) {
            context.setMessage(String.valueOf(level.getLevel()), level.getDescription());
        }
        context.pop();
    }

    private void appendClaims(final MessageContext context, final Collection<ItemClaim> claims) {
        context.push("claim");

        for (final ItemClaim claim : claims) {
            context.push(claim.getCode());
            context.setMessage("name", claim.getName());
            context.setMessage("icon", claim.getIcon());
            context.setMessage("description", claim.getDescription());

            appendTargets(context, claim.getTargets());
            context.pop();
        }

        context.pop();
    }

    private void appendTargets(final MessageContext context, final List<Target> targets) {
        if (targets == null || targets.isEmpty()) return;

        context.push("target");
        for (final Target target : targets) {
            context.push(target.getCode());
            context.setMessage("name", target.getName());
            context.setMessage("description", target.getDescription());
            context.pop();
        }
        context.pop();
    }

    private void appendStandards(final MessageContext context, final List<Standard> standards) {
        if (standards == null || standards.isEmpty()) return;

        context.push("standard");
        for (final Standard standard : standards) {
            context.push(standard.getCode());
            context.setMessage("description", standard.getDescription());
            context.pop();
        }
        context.pop();
    }

    private static class MessageContext {
        private static final Joiner PathJoiner = Joiner.on(".");

        private final Map<String, String> newMessages = newHashMap();
        private final Map<String, String> updatedMessages = newHashMap();
        private final Deque<String> location = Queues.newArrayDeque();
        private final Map<String, String> existingMessages;

        MessageContext(final Map<String, String> existingMessages) {
            this.existingMessages = existingMessages;
        }

        Map<String, String> getNewMessages() {
            return newMessages;
        }

        Map<String, String> getUpdatedMessages() {
            return updatedMessages;
        }

        Set<String> getStaleMessageKeys() {
            return existingMessages.keySet();
        }

        MessageContext push(final String path) {
            location.push(path);
            return this;
        }

        MessageContext pop() {
            location.pop();
            return this;
        }

        void setMessage(final String lastPath, final String message) {
            if (isBlank(message)) return;

            final String messageKey = getMessageKey(lastPath);
            final String existingMessage = existingMessages.remove(messageKey);
            if (existingMessage == null) {
                newMessages.put(messageKey, message);
            } else if (!message.equals(existingMessage)) {
                updatedMessages.put(messageKey, message);
            }
        }

        private String getMessageKey(final String lastPath) {
            final List<String> paths = newArrayList(location.descendingIterator());
            paths.add(lastPath);
            return PathJoiner.join(paths);
        }
    }
}
