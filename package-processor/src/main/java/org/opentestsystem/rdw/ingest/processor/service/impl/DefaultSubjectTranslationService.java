package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Joiner;
import com.google.common.collect.Queues;
import org.opentestsystem.rdw.common.model.subject.ReportAltScore;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.opentestsystem.rdw.common.model.subject.AltScoring;
import org.opentestsystem.rdw.common.model.subject.Claim;
import org.opentestsystem.rdw.common.model.subject.ClaimScoring;
import org.opentestsystem.rdw.common.model.subject.DepthOfKnowledge;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevels;
import org.opentestsystem.rdw.common.model.subject.ReportAssessmentType;
import org.opentestsystem.rdw.common.model.subject.ReportClaim;
import org.opentestsystem.rdw.common.model.subject.ReportGrade;
import org.opentestsystem.rdw.common.model.subject.ReportPerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.Scorable;
import org.opentestsystem.rdw.common.model.subject.Standard;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.common.model.subject.SubjectMessage;
import org.opentestsystem.rdw.common.model.subject.Target;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectTranslationRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectTranslationService;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.apache.commons.lang3.StringUtils.isBlank;

/**
 * Default implementation of a SubjectTranslationService
 */
@Service
class DefaultSubjectTranslationService implements SubjectTranslationService {

    private final SubjectTranslationRepository repository;

    @Autowired
    public DefaultSubjectTranslationService(final SubjectTranslationRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final String subjectCode = subject.getCode();

        final MessageContext context = new MessageContext(repository.findBySubject(subjectCode));
        context.push("subject").push(subjectCode);
        context.setMessage("name", subject.getName());

        appendMessages(context, subject.getSubjectMessages());
        appendAssessmentTypes(context, subject.getAssessmentTypes());
        appendDepthsOfKnowledge(context, subject.getDepthsOfKnowledge());
        appendReportGrades(context, subject.getReportGrades());
        appendScoreDetails(context, "alt", subject.getAltScores());
        appendScoreDetails(context, "claim", subject.getClaims());
        appendStandards(context, subject.getStandards());

        repository.create(subjectCode, context.getNewMessages());
        repository.update(subjectCode, context.getUpdatedMessages());
        repository.delete(subjectCode, context.getStaleMessageKeys());
    }

    private void appendMessages(final MessageContext context, final List<SubjectMessage> messages) {
        for (final SubjectMessage message : messages) {
            context.setMessage(message.getKey(), message.getValue());
        }
    }

    private void appendAssessmentTypes(final MessageContext context, final List<SubjectAssessmentType> assessmentTypes) {
        for (final SubjectAssessmentType assessmentType : assessmentTypes) {
            context.push("asmt-type").push(assessmentType.getCode());
            context.setMessage("name", assessmentType.getName());
            context.setMessage("long-name", isBlank(assessmentType.getLongName()) ? assessmentType.getName() : assessmentType.getLongName());
            appendPerformanceLevels(context, assessmentType.getOverallScoring().getPerformanceLevels());

            final AltScoring altScoring = assessmentType.getAltScoring();
            if (altScoring != null) {
                context.push("alt-score");
                context.setMessage("name", altScoring.getName());
                appendPerformanceLevels(context, altScoring.getPerformanceLevels());
                context.pop();
            }
            final ClaimScoring claimScoring = assessmentType.getClaimScoring();
            if (claimScoring != null) {
                context.push("claim-score");
                context.setMessage("name", claimScoring.getName());
                appendPerformanceLevels(context, claimScoring.getPerformanceLevels());
                context.pop();
            }

            context.pop().pop();
        }
    }

    private void appendPerformanceLevels(final MessageContext context, final PerformanceLevels performanceLevels) {
        if (performanceLevels == null) return;

        context.push("level");
        for (final PerformanceLevel performanceLevel : performanceLevels.getPerformanceLevels()) {
            context.push(String.valueOf(performanceLevel.getLevel()));
            context.setMessage("name", performanceLevel.getName());
            context.setMessage("short-name", isBlank(performanceLevel.getShortName()) ? performanceLevel.getName() : performanceLevel.getShortName());
            context.setMessage("suffix", performanceLevel.getSuffix() == null ? "" : performanceLevel.getSuffix());
            context.setMessage("color", performanceLevel.getColor());

            context.pop();
        }
        context.pop();
    }

    private void appendDepthsOfKnowledge(final MessageContext context, final List<DepthOfKnowledge> depths) {
        if (depths == null || depths.isEmpty()) return;

        context.push("dok");

        for (final DepthOfKnowledge depth : depths) {
            context.push(String.valueOf(depth.getLevel()));
            context.setMessage("name", depth.getName());
            context.pop();
        }

        context.pop();
    }

    private void appendReportGrades(final MessageContext context, final List<ReportGrade> reportGrades) {
        if (reportGrades == null || reportGrades.isEmpty()) return;

        context.push("report-grade");
        for (final ReportGrade grade : reportGrades) {
            context.push(grade.getCode());

            for (final ReportAssessmentType type : grade.getReportAssessmentTypes()) {
                context.push("asmt-type").push(type.getCode());

                context.push("overall");
                context.setMessage("title", type.getOverallAchievementMessage());
                appendReportPerformanceLevels(context, type.getReportPerformanceLevels());
                context.pop();

                context.push("claim");
                context.setMessage("title", type.getClaimAchievementMessage());
                appendReportClaims(context, type.getReportClaims());
                context.pop();

                context.push("alt-score");
                context.setMessage("title", type.getAltScoreAchievementMessage());
                appendReportAltScores(context, type.getReportAltScores());
                context.pop();

                context.pop().pop();
            }

            context.pop();
        }
        context.pop();
    }

    private void appendReportPerformanceLevels(final MessageContext context, final Collection<ReportPerformanceLevel> levels) {
        if (levels == null || levels.isEmpty()) return;

        context.push("level");
        for (final ReportPerformanceLevel level : levels) {
            context.setMessage(String.valueOf(level.getLevel()), level.getDescription());
        }
        context.pop();
    }

    private void appendReportClaims(final MessageContext context, final Collection<ReportClaim> claims) {
        if (claims == null || claims.isEmpty()) return;

        for (final ReportClaim claim : claims) {
            context.push(claim.getCode());
            appendReportPerformanceLevels(context, claim.getPerformanceLevels());
            context.pop();
        }
    }

    private void appendReportAltScores(final MessageContext context, final Collection<ReportAltScore> altScores) {
        if (altScores == null || altScores.isEmpty()) return;

        for (final ReportAltScore altScore : altScores) {
            context.push(altScore.getCode());
            appendReportPerformanceLevels(context, altScore.getPerformanceLevels());
            context.pop();
        }
    }

    private void appendScoreDetails(final MessageContext context, final String scope, final Collection<? extends Scorable> scorables) {
        if (scorables == null || scorables.isEmpty()) return;

        context.push(scope);

        for (final Scorable scorable : scorables) {
            context.push(scorable.getCode());
            context.setMessage("name", scorable.getName());
            context.setMessage("icon", scorable.getIcon());
            context.setMessage("description", scorable.getDescription());

            // TODO - clean this up
            if (scorable instanceof Claim) {
                appendTargets(context, ((Claim)scorable).getTargets());
            }
            context.pop();
        }

        context.pop();
    }

    private void appendTargets(final MessageContext context, final List<Target> targets) {
        if (targets == null || targets.isEmpty()) return;

        context.push("target");
        for (final Target target : targets) {
            context.push(target.getCode());
            context.setMessage("name", target.getName());
            context.setMessage("description", target.getDescription());
            context.pop();
        }
        context.pop();
    }

    private void appendStandards(final MessageContext context, final List<Standard> standards) {
        if (standards == null || standards.isEmpty()) return;

        context.push("standard");
        for (final Standard standard : standards) {
            context.push(standard.getCode());
            context.setMessage("description", standard.getDescription());
            context.pop();
        }
        context.pop();
    }

    private static class MessageContext {
        private static final Joiner PathJoiner = Joiner.on(".");

        private final Map<String, String> newMessages = newHashMap();
        private final Map<String, String> updatedMessages = newHashMap();
        private final Deque<String> location = Queues.newArrayDeque();
        private final Map<String, String> existingMessages;

        MessageContext(final Map<String, String> existingMessages) {
            this.existingMessages = existingMessages;
        }

        Map<String, String> getNewMessages() {
            return newMessages;
        }

        Map<String, String> getUpdatedMessages() {
            return updatedMessages;
        }

        Set<String> getStaleMessageKeys() {
            return existingMessages.keySet();
        }

        MessageContext push(final String path) {
            location.push(path);
            return this;
        }

        MessageContext pop() {
            location.pop();
            return this;
        }

        void setMessage(final String lastPath, final String message) {
            if (null == message) return;

            final String messageKey = getMessageKey(lastPath);
            final String trimmedMessage = StringUtils.trimWhitespace(message);
            final String existingMessage = existingMessages.remove(messageKey);
            if (existingMessage == null) {
                newMessages.put(messageKey, trimmedMessage);
            } else if (!trimmedMessage.equals(existingMessage)) {
                updatedMessages.put(messageKey, trimmedMessage);
            }
        }

        private String getMessageKey(final String lastPath) {
            final List<String> paths = newArrayList(location.descendingIterator());
            paths.add(lastPath);
            return PathJoiner.join(paths);
        }
    }
}
