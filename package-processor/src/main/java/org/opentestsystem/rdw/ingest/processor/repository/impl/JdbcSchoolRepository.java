package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.common.model.District;
import org.opentestsystem.rdw.ingest.common.model.DistrictGroup;
import org.opentestsystem.rdw.ingest.common.model.Organization;
import org.opentestsystem.rdw.ingest.common.model.School;
import org.opentestsystem.rdw.ingest.common.model.SchoolGroup;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;

@Repository
public class JdbcSchoolRepository implements SchoolRepository {
    private static final Logger logger = LoggerFactory.getLogger(JdbcSchoolRepository.class);

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.district.findAll}")
    private String sqlDistrictFindAll;
    @Value("${sql.district.insert}")
    private String sqlDistrictInsert;
    @Value("${sql.district.update}")
    private String sqlDistrictUpdate;

    @Value("${sql.districtGroup.findAll}")
    private String sqlDistrictGroupFindAll;
    @Value("${sql.districtGroup.insert}")
    private String sqlDistrictGroupInsert;
    @Value("${sql.districtGroup.update}")
    private String sqlDistrictGroupUpdate;

    @Value("${sql.school.findAll}")
    private String sqlSchoolFindAll;
    @Value("${sql.school.insert}")
    private String sqlSchoolInsert;
    @Value("${sql.school.update}")
    private String sqlSchoolUpdate;

    @Value("${sql.schoolGroup.findAll}")
    private String sqlSchoolGroupFindAll;
    @Value("${sql.schoolGroup.insert}")
    private String sqlSchoolGroupInsert;
    @Value("${sql.schoolGroup.update}")
    private String sqlSchoolGroupUpdate;

    @Value("${sql.school.findIdByNaturalId}")
    private String sqlFindIdByNaturalId;

    @Autowired
    JdbcSchoolRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void upsert(final Collection<School> schools, final long importId) {
        // this assumes that the parent organizations are coalesced;
        // if not then a school's parent will not get its dbid set

        // collect various organizations involved in hierarchy of these schools
        final Set<DistrictGroup> districtGroups = newHashSet();
        final Set<District> districts = newHashSet();
        final Set<SchoolGroup> schoolGroups = newHashSet();
        for (final School school : schools) {
            Organization parent = school.getParent();
            while (parent != null) {
                switch (parent.getType()) {
                    case DistrictGroup:
                        districtGroups.add((DistrictGroup)parent);
                        break;
                    case District:
                        districts.add((District)parent);
                        break;
                    case SchoolGroup:
                        schoolGroups.add((SchoolGroup)parent);
                        break;
                    case School:
                        break;
                }
                parent = parent.getParent();
            }
        }

        // upsert organizations
        upsertOrganizations(districtGroups, DistrictGroup.builder(), sqlDistrictGroupFindAll, sqlDistrictGroupUpdate, sqlDistrictGroupInsert);
        upsertOrganizations(districts, District.builder(), sqlDistrictFindAll, sqlDistrictUpdate, sqlDistrictInsert);
        upsertOrganizations(schoolGroups, SchoolGroup.builder(), sqlSchoolGroupFindAll, sqlSchoolGroupUpdate, sqlSchoolGroupInsert);

        upsertSchools(schools, importId);
    }

    @Override
    public Integer findIdByNaturalId(String naturalId) {
        try {
            return jdbcTemplate.queryForObject(sqlFindIdByNaturalId,
                new MapSqlParameterSource().addValue("natural_id", naturalId), Integer.class);
        } catch (final EmptyResultDataAccessException ignore) {
            throw new IllegalArgumentException("unknown natural school id [" + naturalId + "]");
        }
    }

    // upsert organizations as necessary; set dbid after insert, update, or no-op
    private void upsertOrganizations(final Collection<? extends Organization> orgs,
                                     final Organization.Builder builder,
                                     final String sqlFindAll,
                                     final String sqlUpdate,
                                     final String sqlInsert) {
        if (orgs == null || orgs.isEmpty()) return;

        // get existing records
        final Map<String, Organization> existing = findAllOrganizations(builder, sqlFindAll).stream()
                .collect(Collectors.toMap(Organization::getNaturalId, Function.identity()));

        // grind through, figuring out which ones are new, changed, identical
        final List<Organization> toUpdate = newArrayList();
        final List<Organization> toInsert = newArrayList();
        for (final Organization org : orgs) {
            final Organization exist = existing.get(org.getNaturalId());
            if (exist == null) {
                toInsert.add(org);
                org.setFlag(true);
            } else {
                // set id and flag if anything is different
                org.setId(exist.getId());
                org.setFlag(!safeEquals(exist.getName(), org.getName())
                         || !safeEquals(exist.getExternalId(), org.getExternalId()));

                // collect if update is needed
                if (org.getFlag()) {
                    toUpdate.add(org);
                }
            }
        }

        final int unchanged = orgs.size() - toUpdate.size() - toInsert.size();
        if (unchanged > 0) {
            logger.debug("Skipping {} unchanged organizations", unchanged);
        }

        if (!toUpdate.isEmpty()) {
            logger.debug("Updating {} organizations", toUpdate.size());

            for (final Organization org : toUpdate) {
                final SqlParameterSource parameterSource = new MapSqlParameterSource()
                        .addValue("id", org.getId())
                        .addValue("name", org.getName())
                        .addValue("external_id", org.getExternalId());
                jdbcTemplate.update(sqlUpdate, parameterSource);
            }
        }

        if (!toInsert.isEmpty()) {
            logger.debug("Inserting {} organizations", toInsert.size());

            final KeyHolder keyHolder = new GeneratedKeyHolder();
            for (final Organization org : toInsert) {
                final SqlParameterSource parameterSource = new MapSqlParameterSource()
                        .addValue("natural_id", org.getNaturalId())
                        .addValue("name", org.getName())
                        .addValue("external_id", org.getExternalId());
                jdbcTemplate.update(sqlInsert, parameterSource, keyHolder);
                org.setId(keyHolder.getKey().longValue());
            }
        }
    }

    private List<Organization> findAllOrganizations(final Organization.Builder builder, final String sqlFindAll) {
        try {
            return jdbcTemplate.query(sqlFindAll, (rs, rowNum) -> builder
                    .id(rs.getLong("id"))
                    .naturalId(rs.getString("natural_id"))
                    .name(rs.getString("name"))
                    .externalId(rs.getString("external_id"))
                    .build());
        } catch (final EmptyResultDataAccessException ignored) {
            return newArrayList();
        }
    }

    private void upsertSchools(final Collection<School> schools, final long importId) {
        // at this point, all the orgs (other than schools) have been upserted and their ids are set
        // also, the flag in each org is set true if that org needed to be updated/inserted
        if (schools == null || schools.isEmpty()) return;

        // get existing records
        final Map<String, DbSchool> existing = findAllDbSchools().stream()
                .collect(Collectors.toMap(DbSchool::getNaturalId, Function.identity()));

        // grind through, figuring out which ones are new, changed, identical
        final List<School> toUpdate = newArrayList();
        final List<School> toInsert = newArrayList();
        for (final School school : schools) {
            final DbSchool exist = existing.get(school.getNaturalId());
            if (exist == null) {
                toInsert.add(school);
                school.setFlag(true);
            } else {
                // set id and flag if anything is different
                school.setId(exist.getId());
                school.setFlag(!safeEquals(exist.getName(), school.getName())
                            || !safeEquals(exist.getExternalId(), school.getExternalId())
                            || !equalsAncestorId(exist.getDistrictId(), school.findAncestor(Organization.Type.District))
                            || !equalsAncestorId(exist.getDistrictGroupId(), school.findAncestor(Organization.Type.DistrictGroup))
                            || !equalsAncestorId(exist.getSchoolGroupId(), school.findAncestor(Organization.Type.SchoolGroup)));

                // if school or any ancestor is flagged, then update the school
                if (anyFlagged(school)) {
                    toUpdate.add(school);
                }
            }
        }

        final int unchanged = schools.size() - toUpdate.size() - toInsert.size();
        if (unchanged > 0) {
            logger.debug("Skipping {} unchanged schools", unchanged);
        }

        if (!toUpdate.isEmpty()) {
            logger.debug("Updating {} schools", toUpdate.size());

            for (final School school : toUpdate) {
                final SqlParameterSource parameterSource = new MapSqlParameterSource()
                        .addValue("id", school.getId())
                        .addValue("name", school.getName())
                        .addValue("external_id", school.getExternalId())
                        .addValue("district_id", school.findAncestorId(Organization.Type.District))
                        .addValue("district_group_id", school.findAncestorId(Organization.Type.DistrictGroup))
                        .addValue("school_group_id", school.findAncestorId(Organization.Type.SchoolGroup))
                        .addValue("update_import_id", importId);
                jdbcTemplate.update(sqlSchoolUpdate, parameterSource);
            }
        }

        if (!toInsert.isEmpty()) {
            logger.debug("Inserting {} schools", toInsert.size());

            final KeyHolder keyHolder = new GeneratedKeyHolder();
            for (final School school : toInsert) {
                final SqlParameterSource parameterSource = new MapSqlParameterSource()
                        .addValue("natural_id", school.getNaturalId())
                        .addValue("name", school.getName())
                        .addValue("external_id", school.getExternalId())
                        .addValue("district_id", school.findAncestorId(Organization.Type.District))
                        .addValue("district_group_id", school.findAncestorId(Organization.Type.DistrictGroup))
                        .addValue("school_group_id", school.findAncestorId(Organization.Type.SchoolGroup))
                        .addValue("import_id", importId);
                jdbcTemplate.update(sqlSchoolInsert, parameterSource, keyHolder);
                school.setId(keyHolder.getKey().longValue());
            }
        }
    }

    private List<DbSchool> findAllDbSchools() {
        try {
            return jdbcTemplate.query(sqlSchoolFindAll, (rs, rowNum) -> new DbSchool(
                    rs.getLong("id"),
                    rs.getLong("district_id"),
                    orNull(rs, rs.getLong("district_group_id")),
                    orNull(rs, rs.getLong("school_group_id")),
                    rs.getString("natural_id"),
                    rs.getString("name"),
                    rs.getString("external_id")));
        } catch (final EmptyResultDataAccessException ignored) {
            return newArrayList();
        }
    }

    private <T> T orNull(final ResultSet rs, final T value) throws SQLException {
        return rs.wasNull() ? null : value;
    }

    private boolean equalsAncestorId(final Long expectedId, final Organization ancestor) {
        if (expectedId == null) {
            return ancestor == null;
        } else {
            return ancestor != null && expectedId.equals(ancestor.getId());
        }
    }

    private boolean anyFlagged(Organization org) {
        while (org != null) {
            if (org.getFlag()) return true;
            org = org.getParent();
        }
        return false;
    }

    private boolean safeEquals(final Object o1, final Object o2) {
        if (o1 == o2) return true;
        if (o1 == null || o2 == null) return false;
        return o1.equals(o2);
    }


    private static class DbSchool {
        private final Long id;
        private final Long districtId;
        private final Long districtGroupId;
        private final Long schoolGroupId;
        private final String naturalId;
        private final String name;
        private final String externalId;

        public DbSchool(final Long id, final Long districtId, final Long districtGroupId, final Long schoolGroupId, final String naturalId, final String name, final String externalId) {
            this.id = id;
            this.districtId = districtId;
            this.districtGroupId = districtGroupId;
            this.schoolGroupId = schoolGroupId;
            this.naturalId = naturalId;
            this.name = name;
            this.externalId = externalId;
        }

        public Long getId() {
            return id;
        }

        public Long getDistrictId() {
            return districtId;
        }

        public Long getDistrictGroupId() {
            return districtGroupId;
        }

        public Long getSchoolGroupId() {
            return schoolGroupId;
        }

        public String getNaturalId() {
            return naturalId;
        }

        public String getName() {
            return name;
        }

        public String getExternalId() {
            return externalId;
        }
    }
}
