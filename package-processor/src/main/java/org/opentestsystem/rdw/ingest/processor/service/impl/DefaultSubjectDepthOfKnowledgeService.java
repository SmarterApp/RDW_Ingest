package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.subject.DepthOfKnowledge;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseDepthOfKnowledge;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectDepthOfKnowledgeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;

/**
 * Default implementation of a SubjectDepthOfKnowledgeService
 */
@Service
class DefaultSubjectDepthOfKnowledgeService implements SubjectDepthOfKnowledgeService {

    private final DepthOfKnowledgeRepository repository;

    @Autowired
    public DefaultSubjectDepthOfKnowledgeService(final DepthOfKnowledgeRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final String subjectCode = subject.getCode();
        final Map<Integer, WarehouseDepthOfKnowledge> existingDepths = repository.findBySubject(subjectCode).stream()
                .collect(Collectors.toMap(
                        WarehouseDepthOfKnowledge::getLevel,
                        dok -> dok
                ));

        final List<WarehouseDepthOfKnowledge> newDepths = newArrayList();
        final List<WarehouseDepthOfKnowledge> updatedDepths = newArrayList();
        for (final DepthOfKnowledge submitted : subject.getDepthsOfKnowledge()) {
            final WarehouseDepthOfKnowledge existing = existingDepths.remove(submitted.getLevel());
            if (existing == null) {
                newDepths.add(WarehouseDepthOfKnowledge.builder()
                        .reference(submitted.getReference())
                        .level(submitted.getLevel())
                        .build());
            } else if (!existing.getReference().equals(submitted.getReference())) {
                updatedDepths.add(existing.copy().reference(submitted.getReference()).build());
            }
        }
        repository.create(subjectCode, newDepths);
        repository.update(updatedDepths);

        final Map<Integer, WarehouseDepthOfKnowledge> deletedDepthsById = existingDepths.values().stream()
                .collect(Collectors.toMap(
                        WarehouseDepthOfKnowledge::getId,
                        dok -> dok
                ));
        final Integer referencedId = repository.hasItems(deletedDepthsById.keySet());
        if (referencedId != null) {
            final WarehouseDepthOfKnowledge referencedDepth = deletedDepthsById.get(referencedId);
            throw new IllegalArgumentException("Unable to delete Depth of Knowledge id: " + referencedId +
                    " subject: " + subjectCode +
                    " level: " + referencedDepth.getLevel() +
                    " because it is referenced by an assessment item");
        }

        repository.delete(deletedDepthsById.keySet());
    }
}
