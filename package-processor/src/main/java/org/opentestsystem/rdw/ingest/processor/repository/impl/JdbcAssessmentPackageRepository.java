package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.AssessmentScore;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.common.util.JdbcUtil.getNullable;

@Repository
class JdbcAssessmentPackageRepository implements AssessmentPackageRepository {

    private final NamedParameterJdbcTemplate template;

    @Value("${sql.assessment.findOneByNaturalId}")
    private String sqlFindOneByNaturalId;

    @Value("${sql.assessment.create}")
    private String sqlAssessmentCreate;

    @Value("${sql.assessment.update}")
    private String sqlAssessmentUpdate;

    @Value("${sql.assessment.assessmentScore.findAll}")
    private String sqlAssessmentScoreFind;

    @Value("${sql.assessment.assessmentScore.create}")
    private String sqlAssessmentScoreCreate;

    @Value("${sql.assessment.assessmentScore.delete}")
    private String sqlAssessmentScoreDelete;

    @Value("${sql.assessment.item.findAll}")
    private String sqlItemFindAllForAssessment;

    @Value("${sql.assessment.item.create}")
    private String sqlItemCreate;

    @Value("${sql.assessment.item.update}")
    private String sqlItemUpdate;

    @Value("${sql.assessment.item.updateDifficultyCode}")
    private String sqlUpdateDifficultyCode;

    @Value("${sql.assessment.item.commonCoreStandard.findAll}")
    private String sqlItemCommonCoreStandard;

    @Value("${sql.assessment.item.commonCoreStandard.create}")
    private String sqlItemCommonCoreStandardCreate;

    @Value("${sql.assessment.item.commonCoreStandard.delete}")
    private String sqlItemCommonCoreStandardDelete;

    @Value("${sql.assessment.item.otherTarget.findAll}")
    private String sqlItemOtherTarget;

    @Value("${sql.assessment.item.otherTarget.create}")
    private String sqlItemOtherTargetCreate;

    @Value("${sql.assessment.item.otherTarget.delete}")
    private String sqlItemOtherTargetDelete;

    @Autowired
    public JdbcAssessmentPackageRepository(final NamedParameterJdbcTemplate template) {
        this.template = template;
    }

    @Transactional
    @Override
    public void create(final Collection<Assessment> assessments, final long importId) {
        if (assessments.isEmpty()) return;

        final List<String> assessmentNaturalIds = newArrayList();
        final List<MapSqlParameterSource> asmtBatchParams = newArrayList();
        final List<MapSqlParameterSource> scoreBatchParams = newArrayList();
        final List<MapSqlParameterSource> itemBatchParams = newArrayList();
        final List<MapSqlParameterSource> itemCommonCoreBatchParams = newArrayList();
        final List<MapSqlParameterSource> otherTargetBatchParams = newArrayList();

        for (final Assessment assessment : assessments) {
            assessmentNaturalIds.add(assessment.getNaturalId());
            asmtBatchParams.add(newAssessmentParameterSource(assessment, importId));
            scoreBatchParams.addAll(newScoreParam(assessment));

            for (final Item item : assessment.getItems()) {
                itemBatchParams.add(newItemParam(item, assessment.getNaturalId()));
                addItemBatchParam(item, assessment.getNaturalId(), itemCommonCoreBatchParams, otherTargetBatchParams);
            }
        }
        template.batchUpdate(sqlAssessmentCreate, asmtBatchParams.toArray(new MapSqlParameterSource[0]));
        if (!scoreBatchParams.isEmpty()) template.batchUpdate(sqlAssessmentScoreCreate, scoreBatchParams.toArray(new MapSqlParameterSource[0]));
        if (!itemBatchParams.isEmpty()) template.batchUpdate(sqlItemCreate, itemBatchParams.toArray(new MapSqlParameterSource[0]));
        if (!itemCommonCoreBatchParams.isEmpty()) template.batchUpdate(sqlItemCommonCoreStandardCreate, itemCommonCoreBatchParams.toArray(new MapSqlParameterSource[0]));
        if (!otherTargetBatchParams.isEmpty()) template.batchUpdate(sqlItemOtherTargetCreate, otherTargetBatchParams.toArray(new MapSqlParameterSource[0]));
        if (!assessmentNaturalIds.isEmpty()) template.update(sqlUpdateDifficultyCode, new MapSqlParameterSource("asmt_natural_ids", assessmentNaturalIds));
    }

    @Transactional
    @Override
    public void update(final Collection<Assessment> assessments, final long importId) {
        if (assessments.isEmpty()) return;

        final List<String> assessmentNaturalIds = newArrayList();
        final List<Integer> updateItemIds = newArrayList();
        final List<MapSqlParameterSource> asmtBatchParams = newArrayList();
        final List<MapSqlParameterSource> scoreBatchParams = newArrayList();
        final List<MapSqlParameterSource> newItemBatchParams = newArrayList();
        final List<MapSqlParameterSource> updateItemBatchParams = newArrayList();
        final List<MapSqlParameterSource> itemCommonCoreBatchParams = newArrayList();
        final List<MapSqlParameterSource> otherTargetBatchParams = newArrayList();

        for (final Assessment assessment : assessments) {
            assessmentNaturalIds.add(assessment.getNaturalId());
            asmtBatchParams.add(updateAssessmentParameterSource(assessment, importId));

            // asmt scores don't have referenced ids so to update,
            // just delete and create instead of worrying about update logic
            scoreBatchParams.addAll(newScoreParam(assessment));

            // recall for items that we don't allow them to be deleted, only added and updated
            for (final Item item : assessment.getItems()) {
                if (item.getId() == null) {
                    newItemBatchParams.add(newItemParam(item, assessment.getNaturalId()));
                } else {
                    updateItemBatchParams.add(updateItemParam(item));
                    updateItemIds.add(item.getId());
                }
                addItemBatchParam(item, assessment.getNaturalId(), itemCommonCoreBatchParams, otherTargetBatchParams);
            }
        }

        if (!newItemBatchParams.isEmpty()) template.batchUpdate(sqlItemCreate, newItemBatchParams.toArray(new MapSqlParameterSource[0]));
        if (!updateItemBatchParams.isEmpty()) template.batchUpdate(sqlItemUpdate, updateItemBatchParams.toArray(new MapSqlParameterSource[0]));

        if (!updateItemIds.isEmpty()) template.update(sqlItemCommonCoreStandardDelete, new MapSqlParameterSource("item_ids", updateItemIds));
        if (!itemCommonCoreBatchParams.isEmpty()) template.batchUpdate(sqlItemCommonCoreStandardCreate, itemCommonCoreBatchParams.toArray(new MapSqlParameterSource[0]));

        if (!updateItemIds.isEmpty()) template.update(sqlItemOtherTargetDelete, new MapSqlParameterSource("item_ids", updateItemIds));
        if (!otherTargetBatchParams.isEmpty()) template.batchUpdate(sqlItemOtherTargetCreate, otherTargetBatchParams.toArray(new MapSqlParameterSource[0]));

        template.update(sqlAssessmentScoreDelete, new MapSqlParameterSource("asmtIds", assessmentNaturalIds));
        if (!scoreBatchParams.isEmpty()) template.batchUpdate(sqlAssessmentScoreCreate, scoreBatchParams.toArray(new MapSqlParameterSource[0]));

        template.batchUpdate(sqlAssessmentUpdate, asmtBatchParams.toArray(new MapSqlParameterSource[0]));

        if (!assessmentNaturalIds.isEmpty()) template.update(sqlUpdateDifficultyCode, new MapSqlParameterSource("asmt_natural_ids", assessmentNaturalIds));
    }

    @Transactional(readOnly = true)
    @Override
    public Assessment findOneByNaturalId(final String naturalId) {
        final List<Assessment.Builder> assessmentList = template.query(sqlFindOneByNaturalId,
                new MapSqlParameterSource("natural_id", naturalId), AssessmentRowMapper);
        if (assessmentList.isEmpty()) return null;

        final Assessment.Builder builder = assessmentList.get(0);
        final int asmtId = builder.build().getId();
        return builder.scores(findScores(asmtId))
                .items(findItems(asmtId))
                .build();
    }

    private void addItemBatchParam(final Item item, final String asmtNaturalId, final List<MapSqlParameterSource> itemCommonCoreBatchParams, final List<MapSqlParameterSource> otherTargetBatchParams) {
        for (final Integer commonCore : item.getCommonCoreStandards()) {
            itemCommonCoreBatchParams.add(new MapSqlParameterSource()
                    .addValue("item_natural_id", item.getNaturalId())
                    .addValue("asmtId", asmtNaturalId)
                    .addValue("common_core_standard_id", commonCore));
        }

        for (final Integer otherTarget : item.getOtherTargets()) {
            otherTargetBatchParams.add(new MapSqlParameterSource()
                    .addValue("item_natural_id", item.getNaturalId())
                    .addValue("asmtId", asmtNaturalId)
                    .addValue("target_id", otherTarget));
        }
    }

    private List<AssessmentScore> findScores(final Integer assessmentId) {
        return template.query(sqlAssessmentScoreFind, new MapSqlParameterSource("asmt_id", assessmentId), AssessmentScoreRowMapper);
    }

    private List<Item> findItems(final Integer assessmentId) {
        final Map<Integer, List<Integer>> commonCoreStandards = findCommonCoreStandards(assessmentId);
        final Map<Integer, List<Integer>> otherTargets = findOtherTargets(assessmentId);
        final List<Item.Builder> itemBuilders = template.query(sqlItemFindAllForAssessment,
                new MapSqlParameterSource("asmt_id", assessmentId),
                ItemRowMapper);
        final List<Item> items = newArrayList();
        for (final Item.Builder builder : itemBuilders) {
            builder.commonCoreStandards(commonCoreStandards.get(builder.getId()));
            builder.otherTargets(otherTargets.get(builder.getId()));
            items.add(builder.build());
        }
        return items;
    }

    private Map<Integer, List<Integer>> findCommonCoreStandards(final Integer assessmentId) {
        return template.query(
                sqlItemCommonCoreStandard,
                new MapSqlParameterSource("asmt_id", assessmentId),
                results -> {
                    final Map<Integer, List<Integer>> idsByItemIds = newHashMap();
                    while (results.next()) {
                        final int itemId = results.getInt("item_id");
                        if (idsByItemIds.containsKey(itemId)) idsByItemIds.get(itemId).add(results.getInt("common_core_standard_id"));
                        else idsByItemIds.put(itemId, newArrayList(results.getInt("common_core_standard_id")));

                    }
                    return idsByItemIds;
                });
    }

    private Map<Integer, List<Integer>> findOtherTargets(final Integer assessmentId) {
        return template.query(
                sqlItemOtherTarget,
                new MapSqlParameterSource("asmt_id", assessmentId),
                results -> {
                    final Map<Integer, List<Integer>> idsByItemIds = newHashMap();
                    while (results.next()) {
                        final int itemId = results.getInt("item_id");
                        if (idsByItemIds.containsKey(itemId)) idsByItemIds.get(itemId).add(results.getInt("target_id"));
                        else idsByItemIds.put(itemId, newArrayList(results.getInt("target_id")));

                    }
                    return idsByItemIds;
                });
    }

    private static final RowMapper<Assessment.Builder> AssessmentRowMapper = (rs, rowNum) -> Assessment.builder()
            .id(rs.getInt("id"))
            .naturalId(rs.getString("natural_id"))
            .gradeId(rs.getInt("grade_Id"))
            .typeId(rs.getInt("type_id"))
            .subjectId(rs.getInt("subject_id"))
            .subjectId(rs.getInt("subject_id"))
            .schoolYear(rs.getInt("school_year"))
            .name(rs.getString("name"))
            .label(rs.getString("label"))
            .version(rs.getString("version"));

    private static final RowMapper<AssessmentScore> AssessmentScoreRowMapper = (rs, rowNum) -> AssessmentScore.builder()
            .subjectScoreId(getNullable(rs, rs.getInt("subject_score_id")))
            .cutPoint1(getNullable(rs, rs.getDouble("cut_point_1")))
            .cutPoint2(getNullable(rs, rs.getDouble("cut_point_2")))
            .cutPoint3(getNullable(rs, rs.getDouble("cut_point_3")))
            .cutPoint4(getNullable(rs, rs.getDouble("cut_point_4")))
            .cutPoint5(getNullable(rs, rs.getDouble("cut_point_5")))
            .minScore(rs.getDouble("min_score"))
            .maxScore(rs.getDouble("max_score"))
            .build();

    private static final RowMapper<Item.Builder> ItemRowMapper = (rs, rowNum) -> Item.builder()
            .id(rs.getInt("id"))
            .naturalId(rs.getString("natural_id"))
            .claimId(rs.getInt("claim_id"))
            .targetId(rs.getInt("target_id"))
            .mathPractice(getNullable(rs, rs.getInt("math_practice")))
            .allowCalculator(getNullable(rs, rs.getBoolean("allow_calc")))
            .difficulty(rs.getDouble("difficulty"))
            .dokId(rs.getInt("dok_id"))
            .position(getNullable(rs, rs.getInt("position")))
            .maxPoints(rs.getDouble("max_points"))
            .fieldTest(getNullable(rs, rs.getBoolean("field_test")))
            .active(getNullable(rs, rs.getBoolean("active")))
            .type(rs.getString("type"))
            .optionsCount(getNullable(rs, rs.getInt("options_count")))
            .answerKey(rs.getString("answer_key"))
            .performanceTaskWritingType(rs.getString("performance_task_writing_type"));

    private MapSqlParameterSource newAssessmentParameterSource(final Assessment assessment, final long importId) {
        if (assessment.getId() != null) throw new IllegalArgumentException("call update for an assessment with id");

        final MapSqlParameterSource parameterSource = assessmentParameterSource(assessment, importId);
        parameterSource
                .addValue("naturalId", assessment.getNaturalId())
                .addValue("gradeId", assessment.getGradeId())
                .addValue("typeId", assessment.getTypeId())
                .addValue("subjectId", assessment.getSubjectId())
                .addValue("import_id", importId);
        return parameterSource;
    }

    private MapSqlParameterSource updateAssessmentParameterSource(final Assessment assessment, final long importId) {
        if (assessment.getId() == null) throw new IllegalArgumentException("missing assessment id for update");
        return assessmentParameterSource(assessment, importId).addValue("id", assessment.getId());
    }

    private MapSqlParameterSource assessmentParameterSource(final Assessment assessment, final long importId) {
        return new MapSqlParameterSource()
                .addValue("schoolYear", assessment.getSchoolYear())
                .addValue("name", assessment.getName())
                .addValue("label", assessment.getLabel())
                .addValue("version", assessment.getVersion())
                .addValue("update_import_id", importId);
    }

    private List<MapSqlParameterSource> newScoreParam(final Assessment assessment) {
        return assessment.getScores().stream()
                .map(s -> scoreParam(s).addValue("asmtId", assessment.getNaturalId()))
                .collect(Collectors.toList());
    }

    private MapSqlParameterSource scoreParam(final AssessmentScore assessmentScore) {
        return new MapSqlParameterSource()
                .addValue("subjectScoreId", assessmentScore.getSubjectScoreId())
                .addValue("minScore", assessmentScore.getMinScore())
                .addValue("maxScore", assessmentScore.getMaxScore())
                .addValue("cutPoint1", assessmentScore.getCutPoint1())
                .addValue("cutPoint2", assessmentScore.getCutPoint2())
                .addValue("cutPoint3", assessmentScore.getCutPoint3())
                .addValue("cutPoint4", assessmentScore.getCutPoint4())
                .addValue("cutPoint5", assessmentScore.getCutPoint5());
    }

    private MapSqlParameterSource newItemParam(final Item item, final String asmtNaturalId) {
        return itemParam(item)
                .addValue("itemId", item.getNaturalId())
                .addValue("asmtId", asmtNaturalId);
    }

    private MapSqlParameterSource updateItemParam(final Item item) {
        return itemParam(item).addValue("id", item.getId());
    }

    private MapSqlParameterSource itemParam(final Item item) {
        return new MapSqlParameterSource()
                .addValue("claimId", item.getClaimId())
                .addValue("targetId", item.getTargetId())
                .addValue("dokId", item.getDokId())
                .addValue("position", item.getPosition())
                .addValue("difficulty", item.getDifficulty())
                .addValue("maxPoints", item.getMaxPoints())
                .addValue("mathPractice", item.getMathPractice())
                .addValue("allowCalc", item.getAllowCalculator())
                .addValue("fieldTest", item.getFieldTest())
                .addValue("active", item.getActive())
                .addValue("type", item.getType())
                .addValue("optionsCount", item.getOptionsCount())
                .addValue("answerKey", item.getAnswerKey())
                .addValue("performance_task_writing_type", item.getPerformanceTaskWritingType());
    }
}
