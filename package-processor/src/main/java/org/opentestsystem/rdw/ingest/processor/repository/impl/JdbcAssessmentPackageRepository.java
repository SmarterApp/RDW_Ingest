package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.common.util.JdbcUtil.getNullable;

@Repository
class JdbcAssessmentPackageRepository implements AssessmentPackageRepository {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.assessment.findOneByNaturalId}")
    private String sqlFindOneByNaturalId;

    @Value("${sql.assessment.create}")
    private String sqlAssessmentCreate;

    @Value("${sql.assessment.update}")
    private String sqlAssessmentUpdate;

    @Value("${sql.assessment.assessmentScore.create}")
    private String sqlAssessmentScoreCreate;

    @Value("${sql.assessment.assessmentScore.update}")
    private String sqlAssessmentScoreUpdate;

    @Value("${sql.assessment.item.findAll}")
    private String sqlItemFindAllForAssessment;

    @Value("${sql.assessment.item.create}")
    private String sqlItemCreate;

    @Value("${sql.assessment.item.update}")
    private String sqlItemUpdate;

    @Value("${sql.assessment.item.updateDifficultyCode}")
    private String sqlUpdateDifficultyCode;

    @Value("${sql.assessment.item.commonCoreStandard.findAll}")
    private String sqlItemCommonCoreStandard;

    @Value("${sql.assessment.item.commonCoreStandard.create}")
    private String sqlItemCommonCoreStandardCreate;

    @Value("${sql.assessment.item.commonCoreStandard.delete}")
    private String sqlItemCommonCoreStandardDelete;

    @Value("${sql.assessment.item.otherTarget.findAll}")
    private String sqlItemOtherTarget;

    @Value("${sql.assessment.item.otherTarget.create}")
    private String sqlItemOtherTargetCreate;

    @Value("${sql.assessment.item.otherTarget.delete}")
    private String sqlItemOtherTargetDelete;

    @Autowired
    public JdbcAssessmentPackageRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Transactional
    @Override
    public void create(final Collection<Assessment> assessments, final long importId) {
        if (assessments.isEmpty()) return;

        final List<String> assessmentNaturalIds = newArrayList();
        final List<MapSqlParameterSource> asmtBatchParams = newArrayList();
        final List<MapSqlParameterSource> scoreBatchParams = newArrayList();
        final List<MapSqlParameterSource> itemBatchParams = newArrayList();
        final List<MapSqlParameterSource> itemCommonCoreBatchParams = newArrayList();
        final List<MapSqlParameterSource> otherTargetBatchParams = newArrayList();

        for (final Assessment assessment : assessments) {
            assessmentNaturalIds.add(assessment.getNaturalId());
            asmtBatchParams.add(newAssessmentParameterSource(assessment, importId));
            scoreBatchParams.add(newScoreParam(assessment));

            for (final Item item : assessment.getItems()) {
                itemBatchParams.add(newItemParam(item, assessment.getNaturalId()));
                addItemBatchParam(item, assessment.getNaturalId(), itemCommonCoreBatchParams, otherTargetBatchParams);
            }
        }
        jdbcTemplate.batchUpdate(sqlAssessmentCreate, asmtBatchParams.toArray(new MapSqlParameterSource[asmtBatchParams.size()]));
        if (!scoreBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlAssessmentScoreCreate, scoreBatchParams.toArray(new MapSqlParameterSource[scoreBatchParams.size()]));
        if (!itemBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlItemCreate, itemBatchParams.toArray(new MapSqlParameterSource[itemBatchParams.size()]));
        if (!itemCommonCoreBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlItemCommonCoreStandardCreate, itemCommonCoreBatchParams.toArray(new MapSqlParameterSource[itemCommonCoreBatchParams.size()]));
        if (!otherTargetBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlItemOtherTargetCreate, otherTargetBatchParams.toArray(new MapSqlParameterSource[otherTargetBatchParams.size()]));
        if (!assessmentNaturalIds.isEmpty()) jdbcTemplate.update(sqlUpdateDifficultyCode, new MapSqlParameterSource("asmt_natural_ids", assessmentNaturalIds));
    }

    @Transactional
    @Override
    public void update(final Collection<Assessment> assessments, final long importId) {
        if (assessments.isEmpty()) return;

        final List<String> assessmentNaturalIds = newArrayList();
        final List<Integer> updateItemIds = newArrayList();
        final List<MapSqlParameterSource> asmtBatchParams = newArrayList();
        final List<MapSqlParameterSource> scoreBatchParams = newArrayList();
        final List<MapSqlParameterSource> newItemBatchParams = newArrayList();
        final List<MapSqlParameterSource> updateItemBatchParams = newArrayList();
        final List<MapSqlParameterSource> itemCommonCoreBatchParams = newArrayList();
        final List<MapSqlParameterSource> otherTargetBatchParams = newArrayList();

        for (final Assessment assessment : assessments) {
            assessmentNaturalIds.add(assessment.getNaturalId());
            asmtBatchParams.add(updateAssessmentParameterSource(assessment, importId));
            scoreBatchParams.add(updateScoreParam(assessment));

            for (final Item item : assessment.getItems()) {
                if (item.getId() == null) {
                    newItemBatchParams.add(newItemParam(item, assessment.getNaturalId()));
                } else {
                    updateItemBatchParams.add(updateItemParam(item));
                    updateItemIds.add(item.getId());
                }
                addItemBatchParam(item, assessment.getNaturalId(), itemCommonCoreBatchParams, otherTargetBatchParams);
            }
        }

        if (!newItemBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlItemCreate, newItemBatchParams.toArray(new MapSqlParameterSource[newItemBatchParams.size()]));
        if (!updateItemBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlItemUpdate, updateItemBatchParams.toArray(new MapSqlParameterSource[updateItemBatchParams.size()]));

        if (!updateItemIds.isEmpty()) jdbcTemplate.update(sqlItemCommonCoreStandardDelete, new MapSqlParameterSource("item_ids", updateItemIds));
        if (!itemCommonCoreBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlItemCommonCoreStandardCreate, itemCommonCoreBatchParams.toArray(new MapSqlParameterSource[itemCommonCoreBatchParams.size()]));

        if (!updateItemIds.isEmpty()) jdbcTemplate.update(sqlItemOtherTargetDelete, new MapSqlParameterSource("item_ids", updateItemIds));
        if (!otherTargetBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlItemOtherTargetCreate, otherTargetBatchParams.toArray(new MapSqlParameterSource[otherTargetBatchParams.size()]));

        if (!scoreBatchParams.isEmpty()) jdbcTemplate.batchUpdate(sqlAssessmentScoreUpdate, scoreBatchParams.toArray(new MapSqlParameterSource[scoreBatchParams.size()]));
        jdbcTemplate.batchUpdate(sqlAssessmentUpdate, asmtBatchParams.toArray(new MapSqlParameterSource[asmtBatchParams.size()]));

        if (!assessmentNaturalIds.isEmpty()) jdbcTemplate.update(sqlUpdateDifficultyCode, new MapSqlParameterSource("asmt_natural_ids", assessmentNaturalIds));
    }

    @Transactional(readOnly = true)
    @Override
    public Assessment findOneByNaturalId(final String id) {

        final List<Assessment.Builder> assessmentList = jdbcTemplate.query(sqlFindOneByNaturalId, new MapSqlParameterSource("natural_id", id), new AssessmentRowMapper());
        if (!assessmentList.isEmpty()) {
            final int asmtId = assessmentList.get(0).build().getId();
            return assessmentList
                    .get(0)
                    .items(findItems(asmtId))
                    .build();
        }
        return null;
    }

    private void addItemBatchParam(final Item item, final String asmtNaturalId, final List<MapSqlParameterSource> itemCommonCoreBatchParams, final List<MapSqlParameterSource> otherTargetBatchParams) {
        for (final Integer commonCore : item.getCommonCoreStandards()) {
            itemCommonCoreBatchParams.add(new MapSqlParameterSource()
                    .addValue("item_natural_id", item.getNaturalId())
                    .addValue("asmtId", asmtNaturalId)
                    .addValue("common_core_standard_id", commonCore));
        }

        for (final Integer otherTarget : item.getOtherTargets()) {
            otherTargetBatchParams.add(new MapSqlParameterSource()
                    .addValue("item_natural_id", item.getNaturalId())
                    .addValue("asmtId", asmtNaturalId)
                    .addValue("target_id", otherTarget));
        }
    }

    private List<Item> findItems(final Integer assessmentId) {
        final Map<Integer, List<Integer>> commonCoreStandards = findCommonCoreStandards(assessmentId);
        final Map<Integer, List<Integer>> otherTargets = findOtherTargets(assessmentId);
        final List<Item.Builder> itemBuilders = jdbcTemplate.query(sqlItemFindAllForAssessment, new MapSqlParameterSource("asmt_id", assessmentId), new ItemRowMapper());
        final List<Item> items = newArrayList();
        for (final Item.Builder builder : itemBuilders) {
            builder.commonCoreStandards(commonCoreStandards.get(builder.getId()));
            builder.otherTargets(otherTargets.get(builder.getId()));
            items.add(builder.build());
        }
        return items;
    }

    private Map<Integer, List<Integer>> findCommonCoreStandards(final Integer assessmentId) {
        return jdbcTemplate.query(
                sqlItemCommonCoreStandard,
                new MapSqlParameterSource("asmt_id", assessmentId),
                results -> {
                    final Map<Integer, List<Integer>> idsByItemIds = newHashMap();
                    while (results.next()) {
                        final int itemId = results.getInt("item_id");
                        if (idsByItemIds.containsKey(itemId)) idsByItemIds.get(itemId).add(results.getInt("common_core_standard_id"));
                        else idsByItemIds.put(itemId, newArrayList(results.getInt("common_core_standard_id")));

                    }
                    return idsByItemIds;
                });
    }

    private Map<Integer, List<Integer>> findOtherTargets(final Integer assessmentId) {
        return jdbcTemplate.query(
                sqlItemOtherTarget,
                new MapSqlParameterSource("asmt_id", assessmentId),
                results -> {
                    final Map<Integer, List<Integer>> idsByItemIds = newHashMap();
                    while (results.next()) {
                        final int itemId = results.getInt("item_id");
                        if (idsByItemIds.containsKey(itemId)) idsByItemIds.get(itemId).add(results.getInt("target_id"));
                        else idsByItemIds.put(itemId, newArrayList(results.getInt("target_id")));

                    }
                    return idsByItemIds;
                });
    }

    private static class ItemRowMapper implements RowMapper<Item.Builder> {
        @Override
        public Item.Builder mapRow(final ResultSet rs, final int rowNum) throws SQLException {
            return Item.builder()
                    .id(rs.getInt("id"))
                    .naturalId(rs.getString("natural_id"))
                    .claimId(rs.getInt("claim_id"))
                    .targetId(rs.getInt("target_id"))
                    .mathPractice(getNullable(rs, rs.getInt("math_practice")))
                    .allowCalculator(getNullable(rs, rs.getBoolean("allow_calc")))
                    .difficulty(rs.getDouble("difficulty"))
                    .dokId(rs.getInt("dok_id"))
                    .position(getNullable(rs, rs.getInt("position")))
                    .maxPoints(rs.getDouble("max_points"))
                    .fieldTest(getNullable(rs, rs.getBoolean("field_test")))
                    .active(getNullable(rs, rs.getBoolean("active")))
                    .type(rs.getString("type"))
                    .optionsCount(getNullable(rs, rs.getInt("options_count")))
                    .answerKey(rs.getString("answer_key"));
        }
    }

    private static class AssessmentRowMapper implements RowMapper<Assessment.Builder> {
        @Override
        public Assessment.Builder mapRow(final ResultSet rs, final int rowNum) throws SQLException {
            return Assessment.builder()
                    .id(rs.getInt("id"))
                    .naturalId(rs.getString("natural_id"))
                    .gradeId(rs.getInt("grade_Id"))
                    .typeId(rs.getInt("type_id"))
                    .subjectId(rs.getInt("subject_id"))
                    .subjectId(rs.getInt("subject_id"))
                    .schoolYear(rs.getInt("school_year"))
                    .name(rs.getString("name"))
                    .label(rs.getString("label"))
                    .version(rs.getString("version"))
                    .cutPoint1(getNullable(rs, rs.getDouble("cut_point_1")))
                    .cutPoint2(rs.getDouble("cut_point_2"))
                    .cutPoint3(getNullable(rs, rs.getDouble("cut_point_3")))
                    .minScore(rs.getDouble("min_score"))
                    .maxScore(rs.getDouble("max_score"));
        }
    }

    private MapSqlParameterSource newAssessmentParameterSource(final Assessment assessment, final long importId) {
        if (assessment.getId() != null) throw new IllegalArgumentException("call update for an assessment with id");

        final MapSqlParameterSource parameterSource = assessmentParameterSource(assessment, importId);
        parameterSource
                .addValue("naturalId", assessment.getNaturalId())
                .addValue("gradeId", assessment.getGradeId())
                .addValue("typeId", assessment.getTypeId())
                .addValue("subjectId", assessment.getSubjectId())
                .addValue("import_id", importId);
        return parameterSource;
    }

    private MapSqlParameterSource updateAssessmentParameterSource(final Assessment assessment, final long importId) {
        if (assessment.getId() == null) throw new IllegalArgumentException("missing assessment id for update");
        return assessmentParameterSource(assessment, importId).addValue("id", assessment.getId());
    }

    private MapSqlParameterSource assessmentParameterSource(final Assessment assessment, final long importId) {
        return new MapSqlParameterSource()
                .addValue("schoolYear", assessment.getSchoolYear())
                .addValue("name", assessment.getName())
                .addValue("label", assessment.getLabel())
                .addValue("version", assessment.getVersion())
                .addValue("update_import_id", importId);
    }

    private MapSqlParameterSource newScoreParam(final Assessment assessment) {
        return scoreParam(assessment).addValue("asmtId", assessment.getNaturalId());
    }

    private MapSqlParameterSource updateScoreParam(final Assessment assessment) {
        return scoreParam(assessment).addValue("asmt_id", assessment.getId());
    }

    private MapSqlParameterSource scoreParam(final Assessment assessment) {
        return new MapSqlParameterSource()
                .addValue("minScore", assessment.getMinScore())
                .addValue("maxScore", assessment.getMaxScore())
                .addValue("cutPoint1", assessment.getCutPoint1())
                .addValue("cutPoint2", assessment.getCutPoint2())
                .addValue("cutPoint3", assessment.getCutPoint3());
    }

    private MapSqlParameterSource newItemParam(final Item item, final String asmtNaturalId) {
        return itemParam(item)
                .addValue("itemId", item.getNaturalId())
                .addValue("asmtId", asmtNaturalId);
    }

    private MapSqlParameterSource updateItemParam(final Item item) {
        return itemParam(item).addValue("id", item.getId());
    }

    private MapSqlParameterSource itemParam(final Item item) {
        return new MapSqlParameterSource()
                .addValue("claimId", item.getClaimId())
                .addValue("targetId", item.getTargetId())
                .addValue("dokId", item.getDokId())
                .addValue("position", item.getPosition())
                .addValue("difficulty", item.getDifficulty())
                .addValue("maxPoints", item.getMaxPoints())
                .addValue("mathPractice", item.getMathPractice())
                .addValue("allowCalc", item.getAllowCalculator())
                .addValue("fieldTest", item.getFieldTest())
                .addValue("active", item.getActive())
                .addValue("type", item.getType())
                .addValue("optionsCount", item.getOptionsCount())
                .addValue("answerKey", item.getAnswerKey());
    }
}