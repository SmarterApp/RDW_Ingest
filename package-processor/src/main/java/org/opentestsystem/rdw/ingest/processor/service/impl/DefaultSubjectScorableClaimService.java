package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Ordering;
import org.opentestsystem.rdw.common.model.subject.CodedEntity;
import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseScorableClaim;
import org.opentestsystem.rdw.ingest.processor.repository.ScorableClaimRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectScorableClaimService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.AbstractMap;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;
import static org.springframework.util.CollectionUtils.isEmpty;

/**
 * Default implementation of a SubjectScorableClaimService
 */
@Service
class DefaultSubjectScorableClaimService implements SubjectScorableClaimService {
    private static final Ordering<ItemClaim> SbacELAOrdering = Ordering.explicit(ImmutableList.of(
            "SOCK_R", "SOCK_LS", "2-W", "4-CR"
    )).onResultOf(CodedEntity::getCode);
    private static final Ordering<ItemClaim> SbacMathOrdering = Ordering.explicit(ImmutableList.of(
            "1", "SOCK_2", "3"
    )).onResultOf(CodedEntity::getCode);
    private static final Ordering<ItemClaim> DefaultOrdering = Ordering.natural()
            .onResultOf(CodedEntity::getCode);

    private final ScorableClaimRepository repository;

    @Autowired
    public DefaultSubjectScorableClaimService(final ScorableClaimRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final String subjectCode = subject.getCode();
        final Map<Map.Entry<String, String>, WarehouseScorableClaim> existingByCode = repository.findBySubject(subjectCode).stream()
                .collect(Collectors.toMap(
                        this::getKey,
                        claim -> claim
                ));

        final Set<String> scorableAsmtTypeCodes = newHashSet();
        for (final SubjectAssessmentType assessmentType : subject.getAssessmentTypes()) {
            if (assessmentType.getClaimScoring() == null
                    || assessmentType.getClaimScoring().getPerformanceLevels() == null
                    || isEmpty(assessmentType.getClaimScoring().getPerformanceLevels().getPerformanceLevels())) {
                continue;
            }
            scorableAsmtTypeCodes.add(assessmentType.getCode());
        }

        final List<WarehouseScorableClaim> newClaims = newArrayList();
        final List<WarehouseScorableClaim> dataOrderUpdatedClaims = newArrayList();
        final List<WarehouseScorableClaim> updatedClaims = newArrayList();
        final List<ItemClaim> sourceClaims = subject.getClaims().stream()
                .filter(ItemClaim::isScorable)
                .collect(Collectors.toList());

        //Sort the item claims to determine "data order"
        //The data order MUST NOT be changed once assessments have been bound to the claims
        if ("Math".equals(subjectCode)) {
            sourceClaims.sort(SbacMathOrdering);
        } else if ("ELA".equals(subjectCode)) {
            sourceClaims.sort(SbacELAOrdering);
        } else {
            sourceClaims.sort(DefaultOrdering);
        }

        for (int dataOrder = 1; dataOrder <= sourceClaims.size(); dataOrder++) {
            final ItemClaim claim = sourceClaims.get(dataOrder - 1);

            for (final String asmtTypeCode : scorableAsmtTypeCodes) {
                final WarehouseScorableClaim existing = existingByCode.remove(getKey(claim, asmtTypeCode));
                if (existing == null) {
                    newClaims.add(WarehouseScorableClaim.builder()
                            .code(claim.getCode())
                            .displayOrder(claim.getDisplayOrder())
                            .asmtTypeCode(asmtTypeCode)
                            .dataOrder(dataOrder)
                            .build());
                } else if (!existing.getDataOrder().equals(dataOrder) ||
                        !existing.getDisplayOrder().equals(claim.getDisplayOrder())) {
                    final WarehouseScorableClaim updated = existing.copy()
                            .dataOrder(dataOrder)
                            .displayOrder(claim.getDisplayOrder())
                            .build();
                    updatedClaims.add(updated);

                    if (!updated.getDataOrder().equals(existing.getDataOrder())) {
                        dataOrderUpdatedClaims.add(updated);
                    }
                }
            }
        }
        repository.create(subjectCode, newClaims);

        final WarehouseScorableClaim referencedDataOrderClaim = getReferenced(dataOrderUpdatedClaims);
        if (referencedDataOrderClaim != null) {
            throw new IllegalArgumentException("Unable to update data order on existing scorable claim: " + referencedDataOrderClaim.getId() +
                    " code: " + referencedDataOrderClaim.getCode() +
                    " due to being referenced by an existing assessment. " +
                    " This is likely a result of adding/removing/recoding scorable claims once assessments have been ingested.");
        }
        repository.update(updatedClaims);

        if (existingByCode.isEmpty()) return;

        final WarehouseScorableClaim referencedDeletedClaim = getReferenced(existingByCode.values());
        if (referencedDeletedClaim != null) {
            throw new IllegalArgumentException("Unable to delete existing scorable claim: " + referencedDeletedClaim.getId() +
                    " code: " + referencedDeletedClaim.getCode() +
                    " due to being referenced by an existing assessment");
        }
        repository.delete(existingByCode.values().stream()
                .map(WarehouseScorableClaim::getId)
                .collect(Collectors.toSet()));
    }

    private Map.Entry<String, String> getKey(final WarehouseScorableClaim claim) {
        return new AbstractMap.SimpleImmutableEntry<>(claim.getCode(), claim.getAsmtTypeCode());
    }

    private Map.Entry<String, String> getKey(final ItemClaim claim, final String asmtTypeCode) {
        return new AbstractMap.SimpleImmutableEntry<>(claim.getCode(), asmtTypeCode);
    }

    private WarehouseScorableClaim getReferenced(final Collection<WarehouseScorableClaim> claims) {
        if (claims.isEmpty()) return null;

        final Map<Integer, WarehouseScorableClaim> staleClaimsById = claims.stream()
                .collect(Collectors.toMap(
                        WarehouseScorableClaim::getId,
                        claim -> claim
                ));
        final Integer referencedId = repository.isReferenced(staleClaimsById.keySet());
        return referencedId == null ? null : staleClaimsById.get(referencedId);
    }
}
