package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.AbstractMap;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseScorableClaim;
import org.opentestsystem.rdw.ingest.processor.repository.ScorableClaimRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectScorableClaimService;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;
import static org.springframework.util.CollectionUtils.isEmpty;

/**
 * Default implementation of a SubjectScorableClaimService
 */
@Service
class DefaultSubjectScorableClaimService implements SubjectScorableClaimService {

    private final ScorableClaimRepository repository;

    @Autowired
    public DefaultSubjectScorableClaimService(final ScorableClaimRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final String subjectCode = subject.getCode();
        final Map<Map.Entry<String, String>, WarehouseScorableClaim> existingByCode =
            repository.findBySubject(subjectCode).stream().collect(Collectors.toMap(this::getKey, claim -> claim));

        final Set<String> scorableAsmtTypeCodes = newHashSet();
        for (final SubjectAssessmentType assessmentType : subject.getAssessmentTypes()) {
            if (assessmentType.getClaimScoring() == null
                    || assessmentType.getClaimScoring().getPerformanceLevels() == null
                    || isEmpty(assessmentType.getClaimScoring().getPerformanceLevels().getPerformanceLevels())) {
                continue;
            }
            scorableAsmtTypeCodes.add(assessmentType.getCode());
        }

        final List<WarehouseScorableClaim> newClaims = newArrayList();
        final List<WarehouseScorableClaim> dataOrderUpdatedClaims = newArrayList();
        final List<WarehouseScorableClaim> updatedClaims = newArrayList();

        final List<ItemClaim> scorableClaims = subject.getClaims().stream()
                .filter(ItemClaim::isScorable)
                .collect(Collectors.toList());
        for (final ItemClaim claim : scorableClaims) {
            for (final String asmtTypeCode : scorableAsmtTypeCodes) {
                final WarehouseScorableClaim existing = existingByCode.remove(getKey(claim, asmtTypeCode));
                if (existing == null) {
                    newClaims.add(WarehouseScorableClaim.builder()
                            .code(claim.getCode())
                            .displayOrder(claim.getDisplayOrder())
                            .asmtTypeCode(asmtTypeCode)
                            .dataOrder(claim.getDataOrder())
                            .build());
                } else if (!existing.getDataOrder().equals(claim.getDataOrder())
                        || !existing.getDisplayOrder().equals(claim.getDisplayOrder())) {
                    final WarehouseScorableClaim updated = existing.copy()
                            .dataOrder(claim.getDataOrder())
                            .displayOrder(claim.getDisplayOrder())
                            .build();
                    updatedClaims.add(updated);

                    if (!updated.getDataOrder().equals(existing.getDataOrder())) {
                        dataOrderUpdatedClaims.add(updated);
                    }
                }
            }
        }
        repository.create(subjectCode, newClaims);

        // update claims iff it is safe to do so ...
        final WarehouseScorableClaim referencedDataOrderClaim = getReferenced(dataOrderUpdatedClaims);
        if (referencedDataOrderClaim != null) {
            throw new IllegalArgumentException("Unable to update data order on existing scorable claim: " + referencedDataOrderClaim.getId() +
                    " code: " + referencedDataOrderClaim.getCode() +
                    " due to being referenced by an existing assessment. " +
                    " This is likely a result of adding/removing/recoding scorable claims once assessments have been ingested.");
        }
        repository.update(updatedClaims);

        // delete any left-over existing claims, iff they aren't referenced
        if (existingByCode.isEmpty()) {
            return;
        }
        final WarehouseScorableClaim referencedDeletedClaim = getReferenced(existingByCode.values());
        if (referencedDeletedClaim != null) {
            throw new IllegalArgumentException("Unable to delete existing scorable claim: " + referencedDeletedClaim.getId() +
                    " code: " + referencedDeletedClaim.getCode() +
                    " due to being referenced by an existing assessment");
        }
        repository.delete(existingByCode.values().stream()
                .map(WarehouseScorableClaim::getId)
                .collect(Collectors.toSet()));
    }

    private Map.Entry<String, String> getKey(final WarehouseScorableClaim claim) {
        return new AbstractMap.SimpleImmutableEntry<>(claim.getCode(), claim.getAsmtTypeCode());
    }

    private Map.Entry<String, String> getKey(final ItemClaim claim, final String asmtTypeCode) {
        return new AbstractMap.SimpleImmutableEntry<>(claim.getCode(), asmtTypeCode);
    }

    private WarehouseScorableClaim getReferenced(final Collection<WarehouseScorableClaim> claims) {
        if (claims.isEmpty()) return null;

        final Map<Integer, WarehouseScorableClaim> staleClaimsById = claims.stream()
                .collect(Collectors.toMap(
                        WarehouseScorableClaim::getId,
                        claim -> claim
                ));
        final Integer referencedId = repository.isReferenced(staleClaimsById.keySet());
        return referencedId == null ? null : staleClaimsById.get(referencedId);
    }
}
