package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseScorableClaim;
import org.opentestsystem.rdw.ingest.processor.repository.ScorableClaimRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectScorableClaimService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;

/**
 * Default implementation of a SubjectScorableClaimService
 */
@Service
class DefaultSubjectScorableClaimService implements SubjectScorableClaimService {

    private final ScorableClaimRepository repository;

    @Autowired
    public DefaultSubjectScorableClaimService(final ScorableClaimRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final String subjectCode = subject.getCode();
        final Map<String, WarehouseScorableClaim> existingByCode = repository.findBySubject(subjectCode).stream()
                .collect(Collectors.toMap(
                        WarehouseScorableClaim::getCode,
                        claim -> claim
                ));

        final List<WarehouseScorableClaim> newClaims = newArrayList();
        final List<WarehouseScorableClaim> updatedClaims = newArrayList();
        for (final ItemClaim claim : subject.getClaims()) {
            if (!claim.isScorable()) continue;

            final WarehouseScorableClaim existing = existingByCode.remove(claim.getCode());
            if (existing == null) {
                newClaims.add(WarehouseScorableClaim.builder().code(claim.getCode()).displayOrder(claim.getDisplayOrder()).build());
            } else if (!existing.getDisplayOrder().equals(claim.getDisplayOrder())) {
                updatedClaims.add(existing.copy().displayOrder(claim.getDisplayOrder()).build());
            }
        }
        repository.create(subjectCode, newClaims);
        repository.update(updatedClaims);

        if (existingByCode.isEmpty()) return;

        final Map<Integer, WarehouseScorableClaim> staleClaimsById = existingByCode.values().stream()
                .collect(Collectors.toMap(
                        WarehouseScorableClaim::getId,
                        claim -> claim
                ));
        final Integer referencedId = repository.hasAssessment(staleClaimsById.keySet());
        if (referencedId != null) {
            final WarehouseScorableClaim referencedClaim = staleClaimsById.get(referencedId);
            throw new IllegalArgumentException("Unable to delete existing scorable claim: " + referencedId +
                    " code: " + referencedClaim.getCode() +
                    " due to being referenced by an existing assessment");
        }
        repository.delete(staleClaimsById.keySet());
    }
}
