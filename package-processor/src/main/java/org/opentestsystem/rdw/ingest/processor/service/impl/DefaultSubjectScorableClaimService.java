package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseScorableClaim;
import org.opentestsystem.rdw.ingest.processor.repository.ScorableClaimRepository;
import org.opentestsystem.rdw.ingest.processor.service.SubjectScorableClaimService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.AbstractMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;
import static org.springframework.util.CollectionUtils.isEmpty;

/**
 * Default implementation of a SubjectScorableClaimService
 */
@Service
class DefaultSubjectScorableClaimService implements SubjectScorableClaimService {

    private final ScorableClaimRepository repository;

    @Autowired
    public DefaultSubjectScorableClaimService(final ScorableClaimRepository repository) {
        this.repository = repository;
    }

    @Override
    public void upsert(final Subject subject) {
        final String subjectCode = subject.getCode();
        final Map<Map.Entry<String, String>, WarehouseScorableClaim> existingByCode = repository.findBySubject(subjectCode).stream()
                .collect(Collectors.toMap(
                        this::getKey,
                        claim -> claim
                ));

        final Set<String> scorableAsmtTypeCodes = newHashSet();
        for (final SubjectAssessmentType assessmentType : subject.getAssessmentTypes()) {
            if (assessmentType.getClaimScoring() == null
                    || assessmentType.getClaimScoring().getPerformanceLevels() == null
                    || isEmpty(assessmentType.getClaimScoring().getPerformanceLevels().getPerformanceLevels())) {
                continue;
            }
            scorableAsmtTypeCodes.add(assessmentType.getCode());
        }

        final List<WarehouseScorableClaim> newClaims = newArrayList();
        final List<WarehouseScorableClaim> updatedClaims = newArrayList();
        for (final ItemClaim claim : subject.getClaims()) {
            if (!claim.isScorable()) continue;

            for (final String asmtTypeCode : scorableAsmtTypeCodes) {
                final WarehouseScorableClaim existing = existingByCode.remove(getKey(claim, asmtTypeCode));
                if (existing == null) {
                    newClaims.add(WarehouseScorableClaim.builder()
                            .code(claim.getCode())
                            .displayOrder(claim.getDisplayOrder())
                            .asmtTypeCode(asmtTypeCode)
                            .build());
                } else if (!existing.getDisplayOrder().equals(claim.getDisplayOrder())) {
                    updatedClaims.add(existing.copy().displayOrder(claim.getDisplayOrder()).build());
                }
            }
        }
        repository.create(subjectCode, newClaims);
        repository.update(updatedClaims);

        if (existingByCode.isEmpty()) return;

        final Map<Integer, WarehouseScorableClaim> staleClaimsById = existingByCode.values().stream()
                .collect(Collectors.toMap(
                        WarehouseScorableClaim::getId,
                        claim -> claim
                ));
        final Integer referencedId = repository.hasAssessment(staleClaimsById.keySet());
        if (referencedId != null) {
            final WarehouseScorableClaim referencedClaim = staleClaimsById.get(referencedId);
            throw new IllegalArgumentException("Unable to delete existing scorable claim: " + referencedId +
                    " code: " + referencedClaim.getCode() +
                    " due to being referenced by an existing assessment");
        }
        repository.delete(staleClaimsById.keySet());
    }

    private Map.Entry<String, String> getKey(final WarehouseScorableClaim claim) {
        return new AbstractMap.SimpleImmutableEntry<>(claim.getCode(), claim.getAsmtTypeCode());
    }

    private Map.Entry<String, String> getKey(final ItemClaim claim, final String asmtTypeCode) {
        return new AbstractMap.SimpleImmutableEntry<>(claim.getCode(), asmtTypeCode);
    }
}
