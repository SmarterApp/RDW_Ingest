package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.Iterables;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.model.PercentileScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.opentestsystem.rdw.ingest.processor.repository.PercentileRepository;

import static com.google.common.base.Preconditions.checkArgument;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDouble;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDoubleOrNull;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toInteger;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLocalDate;

@Service
class DefaultPercentileParser implements PercentileParser {
    private static final String HeaderAssessmentId = "assessment_id";
    private static final String HeaderStartDate = "start_date";
    private static final String HeaderEndDate = "end_date";
    private static final String HeaderCount = "count";
    private static final String HeaderMean = "mean";
    private static final String HeaderStandardDeviation = "standard_deviation";
    private static final String HeaderMinScore = "min_score";
    private static final String HeaderMaxScore = "max_score";
    private static final String HeaderPercentileRank = "percentile_rank";
    private static final String HeaderScore = "score";

    private static final Integer MinimumRanks = 3;
    private static final String ErrorMinimumRanks = "-rank(s) provided not equal to or greater than " + MinimumRanks;

    private final AssessmentPackageRepository assessmentPackageRepository;
    private final PercentileRepository percentileRepository;

    @Autowired
    public DefaultPercentileParser(final AssessmentPackageRepository assessmentPackageRepository,
                                   final PercentileRepository percentileRepository) {
        this.assessmentPackageRepository = assessmentPackageRepository;
        this.percentileRepository = percentileRepository;
    }

    @Override
    public List<Percentile> parse(final byte[] percentilePayload) {

        try (final Reader reader = new InputStreamReader(new BOMInputStream(new ByteArrayInputStream(percentilePayload)), StandardCharsets.UTF_8)) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180
                    .withFirstRecordAsHeader()
                    .withCommentMarker('#')
                    .parse(reader).iterator();

            if (!recordIterator.hasNext()) throw new ImportException(BAD_DATA, "Empty payload");

            final List<Percentile> percentiles = new ArrayList<>();

            final DataElementErrorCollector parseErrorCollector = new DataElementErrorCollector();
            final CsvPercentileHelper helper = new CsvPercentileHelper(parseErrorCollector);
            helper.startNew(recordIterator.next());
            while (recordIterator.hasNext()) {
                final CSVRecord record = recordIterator.next();
                if (helper.isSkippable(record)) continue;

                if (!helper.isSamePercentile(record)) {
                    percentiles.add(helper.build());
                    helper.startNew(record);
                } else {
                    helper.addRank(record);
                }
            }
            percentiles.add(helper.build());

            // Errors are collected and thrown if not empty after parsing all rows for a comprehensive list
            if (!parseErrorCollector.isEmpty()) {
                throw new ImportException(BAD_DATA, parseErrorCollector.toJson());
            }

            return percentiles;

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private class CsvPercentileHelper {
        private final DataElementErrorCollector errorCollector;
        private final ParserHelper parserHelper;

        private Percentile.Builder percentileBuilder;
        private List<PercentileScore> percentileScores;

        private String asmtNaturalId;
        private String startDate;
        private String endDate;
        private Double minScore;
        private Double maxScore;
        private long row;

        CsvPercentileHelper(final DataElementErrorCollector errorCollector) {
            this.errorCollector = errorCollector;
            this.parserHelper = new ParserHelper(this.errorCollector);
        }

        void startNew(final CSVRecord record) {
            row = record.getRecordNumber();
            // The first three fields comprise the unique id for a table.  Parsed and stored as string,
            // allowing for comparision with following records prior to validation.
            asmtNaturalId = record.get(HeaderAssessmentId).trim();
            startDate = record.get(HeaderStartDate).trim();
            endDate = record.get(HeaderEndDate).trim();

            // get min/max score for this set of percentile ranks
            // allowing for vetting of rank scores as they come in
            minScore = parserHelper.validate(contextName(HeaderMinScore), record.get(HeaderMinScore), toDouble);
            maxScore = parserHelper.validate(contextName(HeaderMaxScore), record.get(HeaderMaxScore), toDouble);
            if (minScore != null && maxScore != null && minScore >= maxScore) {
                errorCollector.add(new DataElementError(contextName("min/max_score"), "" + minScore,
                        "min score " + minScore + " must be less than max score " + maxScore));
            }

            percentileBuilder = Percentile.builder()
                    .assessmentId(parserHelper.validate(contextName(HeaderAssessmentId), asmtNaturalId, toAsmtId))
                    .startDate(parserHelper.validate(contextName(HeaderStartDate), startDate, toLocalDate))
                    .endDate(parserHelper.validate(contextName(HeaderEndDate), endDate, toLocalDate))
                    .count(parserHelper.validate(contextName(HeaderCount), record.get(HeaderCount), toInteger))
                    .mean(parserHelper.validate(contextName(HeaderMean), record.get(HeaderMean), toScaleScore))
                    .standardDeviation(parserHelper.validate(contextName(HeaderStandardDeviation), record.get(HeaderStandardDeviation), toDoubleOrNull))
                    .minScore(minScore)
                    .maxScore(maxScore);

            percentileScores = new ArrayList<>();
            addRank(record);
        }

        void addRank(final CSVRecord record) {
            row = record.getRecordNumber();
            // quietly skip rows with no percentile score info (mostly because main percentile row might not have rank data)
            if (isBlank(record.get(HeaderPercentileRank)) && isBlank(record.get(HeaderScore))) return;

            // validator will return null (and collect message) if there is a problem
            final Integer rank = parserHelper.validate(contextName(HeaderPercentileRank), record.get(HeaderPercentileRank), toInteger);
            final Double score = parserHelper.validate(contextName(HeaderScore), record.get(HeaderScore), toScaleScore);
            if (rank == null || score == null) return;

            if (!percentileScores.isEmpty()) {
                final PercentileScore previous = percentileScores.get(percentileScores.size() - 1);
                if (rank <= previous.getPercentileRank()) {
                    errorCollector.add(new DataElementError(contextName("min/max_score"), "" + rank,
                            "rank " + rank + " must be greater than previous rank " + previous.getPercentileRank()));
                }
                if (score < previous.getScore()) {
                    errorCollector.add(new DataElementError(contextName("min/max_score"), "" + score,
                            "score " + score + " must not be less than previous score " + previous.getScore()));
                }
            }
            percentileScores.add(PercentileScore.builder().percentileRank(rank).score(score).build());
        }

        boolean isSkippable(final CSVRecord record) {
            return Iterables.all(record, this::isBlank);
        }

        boolean isBlank(final String value) {
            return value == null || value.trim().isEmpty();
        }

        boolean isSamePercentile(final CSVRecord record) {
            return record.get(HeaderAssessmentId).trim().equals(asmtNaturalId)
                    && record.get(HeaderStartDate).trim().equals(startDate)
                    && record.get(HeaderEndDate).trim().equals(endDate);
        }

        /**
         * After all rows for one table have been added validate and build the {@link Percentile}.
         *
         * @return {@link Percentile}
         */
        Percentile build() {
            // build it so we can get values out ... sigh
            final Percentile current = percentileBuilder.build();
            return percentileBuilder
                    .id(getExistingPercentileId(current.getAssessmentId(), current.getStartDate(), current.getEndDate()))
                    .percentileScores(calculateMinAndMax(percentileScores, current.getMinScore(), current.getMaxScore()))
                    .build();
        }

        private Integer getExistingPercentileId(final Integer assessmentId, final LocalDate startDate, final LocalDate endDate) {
            if (assessmentId == null || startDate == null || endDate == null) {
                return null;
            }

            final Integer existPercentileId = percentileRepository.findIdByKey(assessmentId, startDate, endDate);

            if (existPercentileId == null) {
                // If not exist check if this new percentile overlaps dates for the same assessment
                final List<Integer> overlapIds = percentileRepository.findIdsByDateOverlap(assessmentId, startDate, endDate);
                if (overlapIds.size() > 0) {
                    errorCollector.add(new DataElementError(contextName(HeaderAssessmentId), startDate + " to " + endDate,
                            "start_date and end_date overlap " + overlapIds.size() + " existing percentile(s) for the same assessment"));
                }
            }
            return existPercentileId;
        }

        /**
         * Method to calculate minInclusive and maxExclusive given a list of percentile ranks, scores,
         * and the minScore and maxScore possible for a {@link Percentile} table.
         *
         * @param inScores a list of {@link PercentileScore}'s in order by percentileRank for a {@link Percentile} table
         * @param minScore the lowest possible score for the {@link Percentile}
         * @param maxScore the highest possible score for the {@link Percentile}
         * @return {@link List} of {@link PercentileScore}'s with minInclusive and maxExclusive calculated
         */
        private List<PercentileScore> calculateMinAndMax(final List<PercentileScore> inScores, final Double minScore, final Double maxScore) {
            if (inScores.size() < MinimumRanks) {
                errorCollector.add(new DataElementError(contextName(HeaderAssessmentId), Integer.toString(inScores.size()), inScores.size() + ErrorMinimumRanks));
                return inScores;
            }

            final List<PercentileScore> outScores = new ArrayList<>();
            final PercentileScore.Builder builder = PercentileScore.builder();

            outScores.add(builder.copy(inScores.get(0))
                    .minInclusive(minScore)
                    .maxExclusive(inScores.get(1).getScore())
                    .build());
            for (int i = 1; i < inScores.size() - 1; ++i) {
                outScores.add(builder.copy(inScores.get(i))
                        .minInclusive(inScores.get(i).getScore())
                        .maxExclusive(inScores.get(i + 1).getScore())
                        .build());

            }
            outScores.add(builder.copy(inScores.get(inScores.size() - 1))
                    .minInclusive(inScores.get(inScores.size() - 1).getScore())
                    .maxExclusive(maxScore)
                    .build());
            return outScores;
        }

        private String contextName(final String fieldName) {
            return "[row:" + row + "][" + asmtNaturalId + "," + startDate + "," + endDate + "], " + fieldName;
        }

        private final Function<String, Integer> toAsmtId = value -> {
            try {
                return assessmentPackageRepository.findOneByNaturalId(value).getId();
            } catch (Exception ex) {
                throw new IllegalArgumentException("Missing assessment with natural id of " + value);
            }
        };

        private final Function<String, Double> toScaleScore = new Function<String, Double>() {
            @Override
            public Double apply(final String value) {
                checkArgument(StringUtils.hasText(value), "value may not be blank");
                final double score = Double.parseDouble(value);
                checkArgument(minScore <= score && score <= maxScore, "value must be in range " + minScore + " - " + maxScore);
                return score;
            }
        };

    }

}
