package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.config.SbacScoreConfiguration;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.model.PercentileScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;

import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDouble;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDoubleOrNull;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toInteger;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toIntegerOrNull;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLocalDate;

@Service
class DefaultPercentileParser implements PercentileParser {

    private final AssessmentPackageRepository assessmentPackageRepository;
    private final SbacScoreConfiguration scoreConfiguration;

    @Autowired
    public DefaultPercentileParser(final AssessmentPackageRepository assessmentPackageRepository,
                                   final SbacScoreConfiguration scoreConfiguration) {
        this.assessmentPackageRepository = assessmentPackageRepository;
        this.scoreConfiguration = scoreConfiguration;
    }

    public List<Percentile> parse(final byte[] percentilePayload, final DataElementErrorCollector percentilesErrorCollector) {
        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(percentilePayload), StandardCharsets.UTF_8)) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(reader).iterator();

            final List<Percentile> percentiles = new ArrayList<>();
            if (!recordIterator.hasNext()) return percentiles;

            PercentileReader percentileReader = new PercentileReader(recordIterator.next());

            while (recordIterator.hasNext()) {
                final CSVRecord percentileRecord = recordIterator.next();

                if (!percentileReader.isSamePercentile(percentileRecord)) {
                    percentiles.add(percentileReader.safeBuild(percentilesErrorCollector));
                    percentileReader = new PercentileReader(percentileRecord);
                } else {
                    percentileReader.addPercentileScore(percentileRecord);
                }
            }
            percentiles.add(percentileReader.safeBuild(percentilesErrorCollector));

            return percentilesErrorCollector.isEmpty() ? percentiles : new ArrayList<>();

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private class PercentileReader {
        private static final String AssessmentId = "assessment_id";
        private static final String StartDate = "start_date";
        private static final String EndDate = "end_date";
        private static final String Count = "count";
        private static final String Mean = "mean";
        private static final String StandardDeviation = "standard_deviation";
        private static final String MinScore = "min_score";
        private static final String MaxScore = "max_score";
        private static final String PercentileRank = "percentile_rank";
        private static final String Score = "score";

        private final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        private final ParserHelper parserHelper = new ParserHelper(errorCollector);
        private final String asmtNaturalId;
        private final String startDate;
        private final String endDate;

        private List<PercentileScore> percentileScores = new ArrayList<>();
        private Percentile.Builder percentileBuilder;

        PercentileReader(CSVRecord record) {
            // The first three fields comprise the unique id for a table.  Parsed and stored as string,
            // allowing for comparision with following records prior to validation.
            asmtNaturalId = record.get(AssessmentId).trim();
            startDate = record.get(StartDate).trim();
            endDate = record.get(EndDate).trim();

            percentileBuilder = new Percentile.Builder()
                    .assessmentId(parserHelper.validate(contextName(AssessmentId), asmtNaturalId, toAsmtId))
                    .startDate(parserHelper.validate(contextName(StartDate), startDate, toLocalDate))
                    .endDate(parserHelper.validate(contextName(EndDate), endDate, toLocalDate))
                    .count(parserHelper.validate(contextName(Count), record.get(Count), toIntegerOrNull))
                    .mean(parserHelper.validate(contextName(Mean), record.get(Mean), toDoubleOrNull))
                    .standardDeviation(parserHelper.validate(contextName(StandardDeviation), record.get(StandardDeviation), toDoubleOrNull))
                    .minScore(parserHelper.validate(contextName(MinScore), record.get(MinScore), toScaleScoreMin))
                    .maxScore(parserHelper.validate(contextName(MaxScore), record.get(MaxScore), toScaleScoreMax));

            addPercentileScore(record);
        }

        void addPercentileScore(final CSVRecord record) {
            percentileScores.add(new PercentileScore.Builder()
                    .percent(parserHelper.validate(contextName(PercentileRank), record.get(PercentileRank), toInteger))
                    .score(parserHelper.validate(contextName(Score), record.get(Score), toDouble))
                    .build());
        }

        boolean isSamePercentile(final CSVRecord record) {
            return record.get(AssessmentId).trim().equals(asmtNaturalId)
                    && record.get(StartDate).trim().equals(startDate)
                    && record.get(EndDate).trim().equals(endDate);
        }

        Percentile safeBuild(final DataElementErrorCollector percentilesErrorCollector) {
            validatePercentileScoreOrder();
            // todo: compose min and max for percentileScore(s)
            if (errorCollector.isEmpty()) {
                return percentileBuilder
                        .percentileScores(percentileScores)
                        .build();
            }
            percentilesErrorCollector.addAll(errorCollector);
            return null;
        }

        private void validatePercentileScoreOrder() {
            PercentileScore previous = null;
            for (PercentileScore percentileScore : percentileScores) {
                if (previous != null) {
                    if (percentileScore.getPercent() <= previous.getPercent()) {
                        errorCollector.add(new DataElementError(contextName(PercentileRank), percentileScore.getPercent().toString(), "Not greater than previous"));
                    }
                    if (percentileScore.getScore() < previous.getScore()) {
                        errorCollector.add(new DataElementError(contextName(Score), percentileScore.getScore().toString(), "Not greater than or equal to previous"));
                    }
                }
                previous = percentileScore;
            }
        }

        private String contextName(String fieldName) {
            return "[" + asmtNaturalId + "," + startDate + "," + endDate + "], " + fieldName;
        }

        private final Function<String, Integer> toAsmtId = value -> {
            try {
                return assessmentPackageRepository.findOneByNaturalId(value).getId();
            } catch (Exception ex) {
                throw new IllegalArgumentException("Missing assessment with natural id of " + value);
            }
        };

        private final Function<String, Double> toScaleScoreMin = value ->
                StringUtils.hasText(value) ? Double.parseDouble(value.trim()) : scoreConfiguration.getScaleScore().getMin();

        private final Function<String, Double> toScaleScoreMax = value ->
                StringUtils.hasText(value) ? Double.parseDouble(value.trim()) : scoreConfiguration.getScaleScore().getMax();
    }

}