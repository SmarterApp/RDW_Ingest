package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.model.PercentileScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDouble;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toInteger;
import static org.springframework.util.StringUtils.hasText;


@Service
class DefaultPercentileParser implements PercentileParser {

    private final AssessmentPackageRepository assessmentPackageRepository;


    @Autowired
    public DefaultPercentileParser(final AssessmentPackageRepository assessmentPackageRepository) {
        this.assessmentPackageRepository = assessmentPackageRepository;
    }

    public List<Percentile> parse(final byte[] percentilePayload, final DataElementErrorCollector elementErrorCollector) {
        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(percentilePayload), Charset.forName("utf8"))) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(reader).iterator();

            final List<Percentile> percentiles = newArrayList();
            if (!recordIterator.hasNext()) return percentiles;

            final PercentileParserHelper percentileParserHelper = new PercentileParserHelper();

            percentileParserHelper.newPercentileRecord(recordIterator.next());

            while (recordIterator.hasNext()) {
                final CSVRecord percentileRecord = recordIterator.next();
                if (!percentileParserHelper.isSamePercentile(percentileRecord)) {
                    // build what we have
                    percentiles.add(percentileParserHelper.safeBuild(elementErrorCollector));
                    // set up the parent object for the new percentile
                    percentileParserHelper.newPercentileRecord(percentileRecord);
                } else {
                    percentileParserHelper.addPercentileScore(percentileRecord);
                }
            }
            percentiles.add(percentileParserHelper.safeBuild(elementErrorCollector));

            // if there are any errors return an empty list.
            return elementErrorCollector.isEmpty() ? percentiles : newArrayList();

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private class PercentileParserHelper {
        private static final String AssessmentId = "assessment_id";
        private static final String Count = "count";
        private static final String Mean = "mean";
        private static final String StandardDeviation = "standard_deviation";
        private static final String Percent = "percent";
        private static final String Score = "score";

        private final DataElementErrorCollector errorCollector = new DataElementErrorCollector();

        ParserHelper parserHelper = new ParserHelper(errorCollector);

        private Percentile.Builder percentileBuilder;
        private String percentileNaturalId;

        void newPercentileRecord(final CSVRecord record) {
            // collect errors separately for each assessment
            errorCollector.reset();
            parse(record);
            addPercentileScore(record);
        }

        void parse(final CSVRecord record) {
            percentileNaturalId = parserHelper.validate(AssessmentId, record.get(AssessmentId), 250, true);
            percentileBuilder = new Percentile.Builder()
                    .assessmentId(parserHelper.validate("Find existing asmt by natural id [" + percentileNaturalId + "]", percentileNaturalId, this::toAsmtId))
                    .count(parserHelper.validate(contextName(Count), record.get(Count), this::toNullableInteger))
                    .mean(parserHelper.validate(contextName(Mean), record.get(Mean), this::toNullableDouble))
                    .standardDeviation(parserHelper.validate(contextName(StandardDeviation), record.get(StandardDeviation), this::toNullableDouble));
        }

        void addPercentileScore(final CSVRecord record) {
            final PercentileScore.Builder builder = new PercentileScore.Builder();

            builder.percent(parserHelper.validate(contextName(Percent), record.get(Percent), toInteger))
                    .score(parserHelper.validate(contextName(Score), record.get(Score), toDouble));

            percentileBuilder.percentileScore(builder.build());
        }

        String contextName(String fieldName) {
            return  "[" + percentileNaturalId + "], " + fieldName;
        }

        boolean isSamePercentile(final CSVRecord record) {
            return record.get(AssessmentId).trim().equals(percentileNaturalId);
        }

        Percentile safeBuild(final DataElementErrorCollector elementErrorCollector) {
            if (errorCollector.isEmpty()) {
                return percentileBuilder.build();
            }
            elementErrorCollector.addAll(errorCollector);
            return null;
        }

        private Double toNullableDouble(final String value) {
            if (hasText(value)) {
                return Double.parseDouble(value);
            }
            return null;
        }

        private Integer toNullableInteger(final String value) {
            if (hasText(value)) {
                return Integer.parseInt(value);
            }
            return null;
        }

        private Integer toAsmtId(final String naturalId) {
            try {
                return assessmentPackageRepository.findOneByNaturalId(percentileNaturalId).getId();
            } catch (Exception ex) {
                throw new IllegalArgumentException("Missing assessment with natural id of " + naturalId);
            }
        }
    }

}