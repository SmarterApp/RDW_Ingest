package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.model.PercentileScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDouble;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toInteger;
import static org.springframework.util.StringUtils.hasText;


@Service
class DefaultPercentileParser implements PercentileParser {

    private final AssessmentPackageRepository assessmentPackageRepository;

    @Autowired
    public DefaultPercentileParser(final AssessmentPackageRepository assessmentPackageRepository) {
        this.assessmentPackageRepository = assessmentPackageRepository;
    }

    public List<Percentile> parse(final byte[] percentilePayload, final DataElementErrorCollector percentilesErrorCollector) {
        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(percentilePayload), Charset.forName("utf8"))) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(reader).iterator();

            final List<Percentile> percentiles = new ArrayList<>();
            if (!recordIterator.hasNext()) return percentiles;

            PercentileReader percentileReader = new PercentileReader(recordIterator.next());

            while (recordIterator.hasNext()) {
                final CSVRecord percentileRecord = recordIterator.next();

                if (!percentileReader.isSamePercentile(percentileRecord)) {
                    percentiles.add(percentileReader.safeBuild(percentilesErrorCollector));
                    percentileReader = new PercentileReader(percentileRecord);
                } else {
                    percentileReader.addPercentileScore(percentileRecord);
                }
            }
            percentiles.add(percentileReader.safeBuild(percentilesErrorCollector));

            return percentilesErrorCollector.isEmpty() ? percentiles : new ArrayList<>();

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private class PercentileReader {
        private static final String AssessmentId = "assessment_id";
        private static final String Count = "count";
        private static final String Mean = "mean";
        private static final String StandardDeviation = "standard_deviation";
        private static final String Percent = "percent";
        private static final String Score = "score";

        private DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        private ParserHelper parserHelper = new ParserHelper(errorCollector);

        private List<PercentileScore> percentileScores = new ArrayList<>();
        private Percentile.Builder percentileBuilder;
        private String percentileNaturalId;

        PercentileReader(CSVRecord newPercentileRecord) {
            percentileNaturalId = parserHelper.validate(AssessmentId, newPercentileRecord.get(AssessmentId), 250, true);

            percentileBuilder = new Percentile.Builder()
                    .assessmentId(parserHelper.validate("Find existing asmt by natural id [" + percentileNaturalId + "]", percentileNaturalId, this::toAsmtId))
                    .count(parserHelper.validate(contextName(Count), newPercentileRecord.get(Count), this::toNullableInteger))
                    .mean(parserHelper.validate(contextName(Mean), newPercentileRecord.get(Mean), this::toNullableDouble))
                    .standardDeviation(parserHelper.validate(contextName(StandardDeviation), newPercentileRecord.get(StandardDeviation), this::toNullableDouble));

            addPercentileScore(newPercentileRecord);
        }

        void addPercentileScore(final CSVRecord record) {
            percentileScores.add(new PercentileScore.Builder()
                    .percent(parserHelper.validate(contextName(Percent), record.get(Percent), toInteger))
                    .score(parserHelper.validate(contextName(Score), record.get(Score), toDouble))
                    .build());
        }

        boolean isSamePercentile(final CSVRecord record) {
            return record.get(AssessmentId).trim().equals(percentileNaturalId);
        }

        Percentile safeBuild(final DataElementErrorCollector percentilesErrorCollector) {

            // check percent
            PercentileScore previous = null;
            for (PercentileScore percentileScore : percentileScores) {
                if (previous != null) {
                    if (percentileScore.getPercent() <= previous.getPercent()) {
                        errorCollector.add(new DataElementError(contextName(Percent), percentileScore.getPercent().toString(), "Not greater than previous"));
                    }
                    if (percentileScore.getScore() < previous.getScore()) {
                        errorCollector.add(new DataElementError(contextName(Score), percentileScore.getScore().toString(), "Not greater than previous"));
                    }
                }
                previous = percentileScore;
            }

            // todo: compose min and max

            if (errorCollector.isEmpty()) {
                return percentileBuilder
                        .percentileScores(percentileScores)
                        .build();
            }
            percentilesErrorCollector.addAll(errorCollector);
            return null;
        }

        private String contextName(String fieldName) {
            return "[" + percentileNaturalId + "], " + fieldName;
        }

        private Double toNullableDouble(final String value) {
            if (hasText(value)) {
                return Double.parseDouble(value);
            }
            return null;
        }

        private Integer toNullableInteger(final String value) {
            if (hasText(value)) {
                return Integer.parseInt(value);
            }
            return null;
        }

        private Integer toAsmtId(final String naturalId) {
            try {
                return assessmentPackageRepository.findOneByNaturalId(percentileNaturalId).getId();
            } catch (Exception ex) {
                throw new IllegalArgumentException("Missing assessment with natural id of " + naturalId);
            }
        }
    }
}