package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.config.SbacScoreConfiguration;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.model.PercentileScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.opentestsystem.rdw.ingest.processor.repository.PercentileRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.function.Function;

import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDouble;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDoubleOrNull;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toInteger;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLocalDate;

@Service
class DefaultPercentileParser implements PercentileParser {

    private final AssessmentPackageRepository assessmentPackageRepository;
    private final PercentileRepository percentileRepository;
    private final SbacScoreConfiguration scoreConfiguration;

    @Autowired
    public DefaultPercentileParser(final AssessmentPackageRepository assessmentPackageRepository,
                                   final PercentileRepository percentileRepository,
                                   final SbacScoreConfiguration scoreConfiguration) {
        this.assessmentPackageRepository = assessmentPackageRepository;
        this.percentileRepository = percentileRepository;
        this.scoreConfiguration = scoreConfiguration;
    }

    public List<Percentile> parse(final byte[] percentilePayload) {
        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(percentilePayload), StandardCharsets.UTF_8)) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(reader).iterator();
            final List<Percentile> percentiles = new ArrayList<>();
            final DataElementErrorCollector parseErrorCollector = new DataElementErrorCollector();

            if (!recordIterator.hasNext()) throw new ImportException(BAD_DATA, "Empty payload");

            PercentileReader percentileReader = new PercentileReader(recordIterator.next());

            while (recordIterator.hasNext()) {
                final CSVRecord percentileRecord = recordIterator.next();

                if (!percentileReader.isSamePercentile(percentileRecord)) {
                    percentiles.add(percentileReader.safeBuild(parseErrorCollector));
                    percentileReader = new PercentileReader(percentileRecord);
                } else {
                    percentileReader.addPercentileScore(percentileRecord);
                }
            }
            percentiles.add(percentileReader.safeBuild(parseErrorCollector));

            // Errors are collected and thrown after parsing all rows for a comprehensive list
            if (!parseErrorCollector.isEmpty()) throw new ImportException(BAD_DATA, parseErrorCollector.toJson());
            return percentiles;

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private class PercentileReader {
        private static final String AssessmentId = "assessment_id";
        private static final String StartDate = "start_date";
        private static final String EndDate = "end_date";
        private static final String Count = "count";
        private static final String Mean = "mean";
        private static final String StandardDeviation = "standard_deviation";
        private static final String MinScore = "min_score";
        private static final String MaxScore = "max_score";
        private static final String PercentileRank = "percentile_rank";
        private static final String Score = "score";

        private final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        private final ParserHelper parserHelper = new ParserHelper(errorCollector);
        private final String asmtNaturalId;
        private final String startDate;
        private final String endDate;
        private final Double minScore;
        private final Double maxScore;

        private List<PercentileScore> percentileScores = new ArrayList<>();
        private Percentile.Builder percentileBuilder;

        PercentileReader(CSVRecord record) {
            // The first three fields comprise the unique id for a table.  Parsed and stored as string,
            // allowing for comparision with following records prior to validation.
            asmtNaturalId = record.get(AssessmentId).trim();
            startDate = record.get(StartDate).trim();
            endDate = record.get(EndDate).trim();
            // The minScore and maxScore score is used in the percentile rank.
            minScore = parserHelper.validate(contextName(MinScore), record.get(MinScore), toScaleScoreMin);
            maxScore = parserHelper.validate(contextName(MaxScore), record.get(MaxScore), toScaleScoreMax);

            percentileBuilder = new Percentile.Builder()
                    .assessmentId(parserHelper.validate(contextName(AssessmentId), asmtNaturalId, toAsmtId))
                    .startDate(parserHelper.validate(contextName(StartDate), startDate, toLocalDate))
                    .endDate(parserHelper.validate(contextName(EndDate), endDate, toLocalDate))
                    .count(parserHelper.validate(contextName(Count), record.get(Count), toInteger))
                    .mean(parserHelper.validate(contextName(Mean), record.get(Mean), toDouble))
                    .standardDeviation(parserHelper.validate(contextName(StandardDeviation), record.get(StandardDeviation), toDoubleOrNull))
                    .minScore(minScore)
                    .maxScore(maxScore);

            addPercentileScore(record);
        }

        void addPercentileScore(final CSVRecord record) {
            percentileScores.add(new PercentileScore.Builder()
                    .percentileRank(parserHelper.validate(contextName(PercentileRank), record.get(PercentileRank), toInteger))
                    .score(parserHelper.validate(contextName(Score), record.get(Score), toDouble))
                    .build());
        }

        boolean isSamePercentile(final CSVRecord record) {
            return record.get(AssessmentId).trim().equals(asmtNaturalId)
                    && record.get(StartDate).trim().equals(startDate)
                    && record.get(EndDate).trim().equals(endDate);
        }

        /**
         * After all rows for one table have been added validate and build the {@link Percentile}.
         *
         * @param percentilesErrorCollector the {@link DataElementErrorCollector} to add this {@link Percentile}'s errors to if any
         * @return Percentile built or null if errors
         */
        Percentile safeBuild(final DataElementErrorCollector percentilesErrorCollector) {
            validatePercentileScoreOrder();
            final Integer existingId = getExistingPercentileId();

            if (errorCollector.isEmpty()) {
                return percentileBuilder
                        .id(existingId)
                        .percentileScores(calculateMinAndMax(percentileScores, minScore, maxScore))
                        .build();
            }
            percentilesErrorCollector.addAll(errorCollector);
            return null;
        }

        private Integer getExistingPercentileId() {
            final Percentile percentile = percentileBuilder.build();
            final Integer existPercentileId = percentileRepository.findIdByKey(percentile.getAssessmentId(), percentile.getStartDate(), percentile.getEndDate());

            if (existPercentileId == null) {
                // If not exist then check if this new percentile overlaps dates
                final List<Integer> overlapIds = percentileRepository.findIdsByDateOverlap(percentile.getAssessmentId(), percentile.getStartDate(), percentile.getEndDate());
                if (overlapIds.size() > 0) {
                    errorCollector.add(new DataElementError(AssessmentId, startDate + " to " + endDate,
                            "start_date and end_date overlap " + overlapIds.size() + " existing percentile(s) for the same assessment"));
                }
            }
            return existPercentileId;
        }

        private void validatePercentileScoreOrder() {
            PercentileScore previous = null;
            for (PercentileScore percentileScore : percentileScores) {
                if (previous != null) {
                    if (percentileScore.getPercentileRank() <= previous.getPercentileRank()) {
                        errorCollector.add(new DataElementError(contextName(PercentileRank), percentileScore.getPercentileRank().toString(), "Not greater than previous"));
                    }
                    if (percentileScore.getScore() < previous.getScore()) {
                        errorCollector.add(new DataElementError(contextName(Score), percentileScore.getScore().toString(), "Not greater than or equal to previous"));
                    }
                }
                previous = percentileScore;
            }
        }

        private List<PercentileScore> calculateMinAndMax(List<PercentileScore> inScores, Double minScore, Double maxScore) {
            Double previousScore = null;
            List<PercentileScore> outScores = new ArrayList<>();
            PercentileScore.Builder builder = new PercentileScore.Builder();

            ListIterator<PercentileScore> iterator = inScores.listIterator(inScores.size());

            while (iterator.hasPrevious()) {
                PercentileScore percentileScore = iterator.previous();
                // Last in list
                if (iterator.nextIndex() == inScores.size() - 1) {
                    outScores.add(0,
                            builder.percentileRank(percentileScore.getPercentileRank())
                                    .score(percentileScore.getScore())
                                    .minScore(percentileScore.getScore())
                                    .maxScore(maxScore)
                                    .build());
                    // First in list
                } else if (iterator.previousIndex() == -1) {
                    outScores.add(0,
                            builder.percentileRank(percentileScore.getPercentileRank())
                                    .score(percentileScore.getScore())
                                    .minScore(minScore)
                                    .maxScore(previousScore)
                                    .build());
                } else {
                    outScores.add(0,
                            builder.percentileRank(percentileScore.getPercentileRank())
                                    .score(percentileScore.getScore())
                                    .minScore(percentileScore.getScore())
                                    .maxScore(previousScore)
                                    .build());
                }
                previousScore = percentileScore.getScore();
            }
            return outScores;
        }

        private String contextName(String fieldName) {
            return "[" + asmtNaturalId + "," + startDate + "," + endDate + "], " + fieldName;
        }

        private final Function<String, Integer> toAsmtId = value -> {
            try {
                return assessmentPackageRepository.findOneByNaturalId(value).getId();
            } catch (Exception ex) {
                throw new IllegalArgumentException("Missing assessment with natural id of " + value);
            }
        };

        private final Function<String, Double> toScaleScoreMin = value ->
                StringUtils.hasText(value) ? Double.parseDouble(value.trim()) : scoreConfiguration.getScaleScore().getMin();

        private final Function<String, Double> toScaleScoreMax = value ->
                StringUtils.hasText(value) ? Double.parseDouble(value.trim()) : scoreConfiguration.getScaleScore().getMax();
    }

}