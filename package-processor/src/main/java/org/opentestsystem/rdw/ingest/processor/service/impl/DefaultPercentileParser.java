package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.Iterables;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.config.SbacScoreConfiguration;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Percentile;
import org.opentestsystem.rdw.ingest.processor.model.PercentileScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.opentestsystem.rdw.ingest.processor.repository.PercentileRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;

import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_FORMAT;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDouble;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDoubleOrNull;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toInteger;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLocalDate;

@Service
class DefaultPercentileParser implements PercentileParser {
    private static final String HeaderAssessmentId = "assessment_id";
    private static final String HeaderStartDate = "start_date";
    private static final String HeaderEndDate = "end_date";
    private static final String HeaderCount = "count";
    private static final String HeaderMean = "mean";
    private static final String HeaderStandardDeviation = "standard_deviation";
    private static final String HeaderMinScore = "min_score";
    private static final String HeaderMaxScore = "max_score";
    private static final String HeaderPercentileRank = "percentile_rank";
    private static final String HeaderScore = "score";

    private static final Integer MinimumRanks = 3;
    private static final String ErrorMinimumRanks = "-rank(s) provided not equal to or greater than " + MinimumRanks;

    private final AssessmentPackageRepository assessmentPackageRepository;
    private final PercentileRepository percentileRepository;
    private final SbacScoreConfiguration scoreConfiguration;

    @Autowired
    public DefaultPercentileParser(final AssessmentPackageRepository assessmentPackageRepository,
                                   final PercentileRepository percentileRepository,
                                   final SbacScoreConfiguration scoreConfiguration) {
        this.assessmentPackageRepository = assessmentPackageRepository;
        this.percentileRepository = percentileRepository;
        this.scoreConfiguration = scoreConfiguration;
    }

    @Override
    public List<Percentile> parse(final byte[] percentilePayload) {

        try (final Reader reader = new InputStreamReader(new ByteArrayInputStream(percentilePayload), StandardCharsets.UTF_8)) {
            final Iterator<CSVRecord> recordIterator = CSVFormat.RFC4180
                    .withFirstRecordAsHeader()
                    .withCommentMarker('#')
                    .parse(reader).iterator();

            if (!recordIterator.hasNext()) throw new ImportException(BAD_DATA, "Empty payload");

            final List<Percentile> percentiles = new ArrayList<>();

            final DataElementErrorCollector parseErrorCollector = new DataElementErrorCollector();
            final CsvPercentileHelper helper = new CsvPercentileHelper(parseErrorCollector);
            helper.addPercentile(recordIterator.next());
            while (recordIterator.hasNext()) {
                final CSVRecord record = recordIterator.next();
                if (helper.isSkippable(record)) continue;

                if (!helper.isSamePercentile(record)) {
                    percentiles.add(helper.build());
                    helper.addPercentile(record);
                } else {
                    helper.addPercentileScore(record);
                }
            }
            percentiles.add(helper.build());

            // Errors are collected and thrown if not empty after parsing all rows for a comprehensive list
            if (!parseErrorCollector.isEmpty()) {
                throw new ImportException(BAD_DATA, parseErrorCollector.toJson());
            }

            return percentiles;

        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private class CsvPercentileHelper {
        private final DataElementErrorCollector errorCollector;
        private final ParserHelper parserHelper;

        private Percentile.Builder percentileBuilder;
        private List<PercentileScore> percentileScores;

        private String asmtNaturalId;
        private String startDate;
        private String endDate;
        private long row;

        CsvPercentileHelper(final DataElementErrorCollector errorCollector) {
            this.errorCollector = errorCollector;
            this.parserHelper = new ParserHelper(this.errorCollector);
        }

        void addPercentile(final CSVRecord record) {
            row = record.getRecordNumber();
            // The first three fields comprise the unique id for a table.  Parsed and stored as string,
            // allowing for comparision with following records prior to validation.
            asmtNaturalId = record.get(HeaderAssessmentId).trim();
            startDate = record.get(HeaderStartDate).trim();
            endDate = record.get(HeaderEndDate).trim();

            percentileBuilder = new Percentile.Builder()
                    .assessmentId(parserHelper.validate(contextName(HeaderAssessmentId), asmtNaturalId, toAsmtId))
                    .startDate(parserHelper.validate(contextName(HeaderStartDate), startDate, toLocalDate))
                    .endDate(parserHelper.validate(contextName(HeaderEndDate), endDate, toLocalDate))
                    .count(parserHelper.validate(contextName(HeaderCount), record.get(HeaderCount), toInteger))
                    .mean(parserHelper.validate(contextName(HeaderMean), record.get(HeaderMean), toDouble))
                    .standardDeviation(parserHelper.validate(contextName(HeaderStandardDeviation), record.get(HeaderStandardDeviation), toDoubleOrNull))
                    .minScore(parserHelper.validate(contextName(HeaderMinScore), record.get(HeaderMinScore), toScaleScoreMin))
                    .maxScore(parserHelper.validate(contextName(HeaderMaxScore), record.get(HeaderMaxScore), toScaleScoreMax));

            percentileScores = new ArrayList<>();
            addPercentileScore(record);
        }

        void addPercentileScore(final CSVRecord record) {
            row = record.getRecordNumber();
            percentileScores.add(new PercentileScore.Builder()
                    .percentileRank(parserHelper.validate(contextName(HeaderPercentileRank), record.get(HeaderPercentileRank), toInteger))
                    .score(parserHelper.validate(contextName(HeaderScore), record.get(HeaderScore), toDouble))
                    .build());
        }

        boolean isSkippable(final CSVRecord record) {
            return Iterables.all(record, value -> value == null || value.trim().isEmpty());
        }

        boolean isSamePercentile(final CSVRecord record) {
            return record.get(HeaderAssessmentId).trim().equals(asmtNaturalId)
                    && record.get(HeaderStartDate).trim().equals(startDate)
                    && record.get(HeaderEndDate).trim().equals(endDate);
        }

        /**
         * After all rows for one table have been added validate and build the {@link Percentile}.
         *
         * @return {@link Percentile}
         */
        Percentile build() {
            final Percentile current = percentileBuilder.build();
            validatePercentileScoreOrder();

            return percentileBuilder
                    .id(getExistingPercentileId(current.getAssessmentId(), current.getStartDate(), current.getEndDate()))
                    .percentileScores(calculateMinAndMax(percentileScores, current.getMinScore(), current.getMaxScore()))
                    .build();
        }

        private Integer getExistingPercentileId(final Integer assessmentId, final LocalDate startDate, final LocalDate endDate) {
            if (assessmentId == null || startDate == null || endDate == null) {
                return null;
            }

            final Integer existPercentileId = percentileRepository.findIdByKey(assessmentId, startDate, endDate);

            if (existPercentileId == null) {
                // If not exist check if this new percentile overlaps dates for the same assessment
                final List<Integer> overlapIds = percentileRepository.findIdsByDateOverlap(assessmentId, startDate, endDate);
                if (overlapIds.size() > 0) {
                    errorCollector.add(new DataElementError(contextName(HeaderAssessmentId), startDate + " to " + endDate,
                            "start_date and end_date overlap " + overlapIds.size() + " existing percentile(s) for the same assessment"));
                }
            }
            return existPercentileId;
        }

        private void validatePercentileScoreOrder() {
            PercentileScore previous = null;
            for (final PercentileScore percentileScore : percentileScores) {
                if (previous != null) {
                    if (percentileScore.getPercentileRank() <= previous.getPercentileRank()) {
                        errorCollector.add(new DataElementError(contextName(HeaderPercentileRank), percentileScore.getPercentileRank().toString(), "Not greater than previous"));
                    }
                    if (percentileScore.getScore() < previous.getScore()) {
                        errorCollector.add(new DataElementError(contextName(HeaderScore), percentileScore.getScore().toString(), "Not greater than or equal to previous"));
                    }
                }
                previous = percentileScore;
            }
        }

        /**
         * Method to calculate minInclusive and maxExclusive given a list of percentile ranks, scores,
         * and the minScore and maxScore possible for a {@link Percentile} table.
         *
         * @param inScores a list of {@link PercentileScore}'s in order by percentileRank for a {@link Percentile} table
         * @param minScore the lowest possible score for the {@link Percentile}
         * @param maxScore the highest possible score for the {@link Percentile}
         * @return {@link List} of {@link PercentileScore}'s with minInclusive and maxExclusive calculated
         */
        private List<PercentileScore> calculateMinAndMax(final List<PercentileScore> inScores, final Double minScore, final Double maxScore) {
            if (inScores.size() < MinimumRanks) {
                errorCollector.add(new DataElementError(contextName(HeaderAssessmentId), Integer.toString(inScores.size()), inScores.size() + ErrorMinimumRanks));
                return inScores;
            }

            final List<PercentileScore> outScores = new ArrayList<>();
            final PercentileScore.Builder builder = new PercentileScore.Builder();

            outScores.add(builder.copy(inScores.get(0))
                    .minInclusive(minScore)
                    .maxExclusive(inScores.get(1).getScore())
                    .build());
            for (int i = 1; i < inScores.size() - 1; ++i) {
                outScores.add(builder.copy(inScores.get(i))
                        .minInclusive(inScores.get(i).getScore())
                        .maxExclusive(inScores.get(i + 1).getScore())
                        .build());

            }
            outScores.add(builder.copy(inScores.get(inScores.size() - 1))
                    .minInclusive(inScores.get(inScores.size() - 1).getScore())
                    .maxExclusive(maxScore)
                    .build());
            return outScores;
        }

        private String contextName(final String fieldName) {
            return "[row:" + row + "][" + asmtNaturalId + "," + startDate + "," + endDate + "], " + fieldName;
        }

        private final Function<String, Integer> toAsmtId = value -> {
            try {
                return assessmentPackageRepository.findOneByNaturalId(value).getId();
            } catch (Exception ex) {
                throw new IllegalArgumentException("Missing assessment with natural id of " + value);
            }
        };

        private final Function<String, Double> toScaleScoreMin = value ->
                StringUtils.hasText(value) ? Double.parseDouble(value.trim()) : scoreConfiguration.getScaleScore().getMin();

        private final Function<String, Double> toScaleScoreMax = value ->
                StringUtils.hasText(value) ? Double.parseDouble(value.trim()) : scoreConfiguration.getScaleScore().getMax();
    }

}