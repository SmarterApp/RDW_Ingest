package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.ingest.common.model.District;
import org.opentestsystem.rdw.ingest.common.model.School;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Map;

import static com.google.common.collect.Maps.newHashMap;
import static org.springframework.util.StringUtils.hasText;

/**
 * This parses the json document, extracting pertinent district, group, and institution info.
 * It is as forgiving as possible wrt to the structure: it looks for json objects that have
 * the required type, id, name, and parent id fields. It allows the order of the objects to
 * be flexible (e.g. districts can come after schools).
 * <p>
 * The payload is expected to be concatenated json response from ART. The required data fields are:<ul>
 *     <li>entityType</li>
 *     <li>entityId</li>
 *     <li>entityName</li>
 *     <li>parentEntityId</li>
 * </ul>
 * The precise structure of the payload isn't critical but might look like this:<pre>
 * { "districts": PAYLOAD-FROM-ART,
 *   "groupsofschools": PAYLOAD-FROM-ART,
 *   "schools": PAYLOAD-FROM-ART
 * }
 * </pre>
 * Where each ART payload is a collection of entities, optionally in a search results wrapper.
 * For example, simple collection of districts:<pre>
 [
 {
 "id": "572d7630e4b0ed2c55c37e34",
 "entityId": "DISTRICT9",
 "entityName": "District 9 - Prawn Town",
 "parentEntityId": "CA",
 "nationwideIdentifier": null,
 "entityType": "DISTRICT",
 }, ...
 ]
 * </pre>
 * And a list of schools wrapped in search results:<pre>
 {
 "searchResults": [
 {
 "id": "57325fc6e4b0ed2c55c37e40",
 "entityId": "DS9001",
 "entityName": "District 9 Institution 1",
 "parentEntityId": "DISTRICT9",
 "stateAbbreviation": "CA",
 "nationwideIdentifier": "NCESID001",
 "entityType": "INSTITUTION",
 }, ...
 ],
 "currentPage": 0,
 "returnCount": 1000,
 "pageSize": 1000,
 "totalCount": 1800,
 "nextPageUrl": "?pageSize=1000&currentPage=1"
 }
 * </pre>
 * </p>
 */
class JsonOrganizationParser implements OrganizationParser {
    private static final Logger logger = LoggerFactory.getLogger(JsonOrganizationParser.class);

    private ParserHelper parserHelper;
    private final Map<String, District> districts = newHashMap();
    private final Map<String, School> schools = newHashMap();
    private final Map<String, String> groupToDistrict = newHashMap();
    private final Map<String, String> schoolToParent = newHashMap();

    public Map<String, School> getSchools() {
        return schools;
    }

    public void parse(final byte[] payload, final ParserHelper parserHelper) {
        this.parserHelper = parserHelper;
        districts.clear();
        schools.clear();
        groupToDistrict.clear();
        schoolToParent.clear();

        final JsonFactory factory = new JsonFactory();
        final ObjectMapper mapper = new ObjectMapper(factory);
        try {
            processNode(mapper.readTree(payload));
            resolveSchoolParents();
            logger.info("parsed {} schools, {} districts", schools.size(), districts.size());
        } catch (final IOException e) {
            throw new IllegalArgumentException("invalid organization payload", e);
        }
    }

    private void processNode(final JsonNode node) {
        if (node.isArray() || (node.isContainerNode() && !node.has("entityType"))) {
            node.forEach(this::processNode);
        } else if (node.isContainerNode() && node.has("entityType")) {
            final String entityId = validateNodeText("entityId", node.get("entityId"), 40);
            final String entityName = validateNodeText("entityName", node.get("entityName"), 100);
            final String parentId = validateNodeText("parentEntityId", node.get("parentEntityId"), 40);
            if (hasText(entityId) && hasText(entityName) && hasText(parentId)) {
                switch (node.get("entityType").asText().toUpperCase()) {
                    case "DISTRICT":
                        districts.put(entityId, District.builder().naturalId(entityId).name(entityName).stateCode(parentId).build());
                        break;
                    case "GROUPOFINSTITUTIONS":
                        groupToDistrict.put(entityId, parentId);
                        break;
                    case "INSTITUTION":
                        schools.put(entityId, School.builder().naturalId(entityId).name(entityName).build());
                        schoolToParent.put(entityId, parentId);
                        break;
                    default:
                        break;
                }
            }
        }
    }

    private String validateNodeText(final String name, final JsonNode node, final int maxLength) {
        return parserHelper.validate(name, parserHelper.validate(name, node, JsonNode::asText), maxLength, true);
    }

    private void resolveSchoolParents() {
        for (final School school : schools.values()) {
            String parentId = schoolToParent.get(school.getNaturalId());
            if (groupToDistrict.containsKey(parentId)) {
                parentId = groupToDistrict.get(parentId);
            }
            school.setDistrict(parserHelper.validate(school.getNaturalId() + " district", parentId, value -> {
                if (!districts.containsKey(value)) throw new IllegalArgumentException("unknown district [" + value + "]");
                return districts.get(value);
            }));
        }
    }
}
