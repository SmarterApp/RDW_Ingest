package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.ingest.common.model.District;
import org.opentestsystem.rdw.ingest.common.model.DistrictGroup;
import org.opentestsystem.rdw.ingest.common.model.Organization;
import org.opentestsystem.rdw.ingest.common.model.School;
import org.opentestsystem.rdw.ingest.common.model.SchoolGroup;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.springframework.util.StringUtils.hasText;

/**
 * This parses the json document, extracting pertinent district, group, and institution info.
 * It is as forgiving as possible wrt to the structure: it looks for json objects that have
 * the required type, id, name, and parent id fields.
 * <p>
 * NOTE: this parse is not multi-thread safe!
 * </p>
 * <p>
 * The payload is expected to be concatenated json response from ART. The required data fields are:<ul>
 *     <li>entityType</li>
 *     <li>entityId</li>
 *     <li>entityName</li>
 *     <li>parentEntityId</li>
 * </ul>
 * The precise structure of the payload isn't critical but might look like this:<pre>
 * { "groupsofdistricts": PAYLOAD-FROM-ART,
 *   "districts": PAYLOAD-FROM-ART,
 *   "groupsofschools": PAYLOAD-FROM-ART,
 *   "schools": PAYLOAD-FROM-ART
 * }
 * </pre>
 * Where each ART payload is a collection of entities, optionally in a search results wrapper.
 * For example, simple collection of districts:<pre>
 [
 {
 "id": "572d7630e4b0ed2c55c37e34",
 "entityId": "DISTRICT9",
 "entityName": "District 9 - Prawn Town",
 "parentEntityId": "CA",
 "nationwideIdentifier": null,
 "entityType": "DISTRICT",
 }, ...
 ]
 * </pre>
 * And a list of schools wrapped in search results:<pre>
 {
 "searchResults": [
 {
 "id": "57325fc6e4b0ed2c55c37e40",
 "entityId": "DS9001",
 "entityName": "District 9 Institution 1",
 "parentEntityId": "DISTRICT9",
 "stateAbbreviation": "CA",
 "nationwideIdentifier": "NCESID001",
 "entityType": "INSTITUTION",
 }, ...
 ],
 "currentPage": 0,
 "returnCount": 1000,
 "pageSize": 1000,
 "totalCount": 1800,
 "nextPageUrl": "?pageSize=1000&currentPage=1"
 }
 * </pre>
 * </p>
 */
class JsonOrganizationParser implements OrganizationParser {
    private static final Logger logger = LoggerFactory.getLogger(JsonOrganizationParser.class);

    // NOTE: this state makes parse() completely NOT thread-safe
    private ParserHelper parserHelper;
    // map of type+naturalId to organization for non-schools
    private final Map<String, Organization> orgs = newHashMap();
    private final List<School> schools = newArrayList();

    @Override
    public Collection<School> parse(final byte[] payload, final ParserHelper parserHelper) {
        this.parserHelper = parserHelper;
        orgs.clear();
        schools.clear();

        final JsonFactory factory = new JsonFactory();
        final ObjectMapper mapper = new ObjectMapper(factory);
        try {
            processNode(mapper.readTree(payload));
            logger.info("parsed {} schools, {} organizations", schools.size(), orgs.size());
            return schools;
        } catch (final IOException e) {
            throw new IllegalArgumentException("invalid organization payload", e);
        }
    }

    private void processNode(final JsonNode node) {
        if (node.isArray() || (node.isContainerNode() && !node.has("entityType"))) {
            node.forEach(this::processNode);
        } else if (node.isContainerNode() && node.has("entityType")) {
            final String entityId = validateNodeText("entityId", node.get("entityId"), 40);
            final String entityName = validateNodeText("entityName", node.get("entityName"), 100);
            final String parentId = validateNodeText("parentEntityId", node.get("parentEntityId"), 40);
            if (hasText(entityId) && hasText(entityName) && hasText(parentId)) {
                final String stateCode = nodeTextOrNull("stateAbbreviation", node);
                final String externalId = nodeTextOrNull("nationwideIdentifier", node);
                final String parentType = nodeTextOrNull("parentEntityType", node);
                Organization parent = null;
                if (parentType != null && !parentType.equalsIgnoreCase("STATE")) {
                    parent = parserHelper.validate(entityId + " parent", orgs.get(parentType + parentId), org -> {
                        if (org == null) {
                            throw new IllegalArgumentException("unknown " + parentType + " [" + parentId + "]");
                        }
                        return org;
                    });
                }
                switch (node.get("entityType").asText().toUpperCase()) {
                    case "GROUPOFDISTRICTS":
                        orgs.put("GROUPOFDISTRICTS" + entityId, DistrictGroup.builder()
                                .naturalId(entityId)
                                .name(entityName)
                                .stateCode(stateCode)
                                .externalId(externalId)
                                .parent(parent)
                                .build());
                        break;
                    case "DISTRICT":
                        orgs.put("DISTRICT" + entityId, District.builder()
                                .naturalId(entityId)
                                .name(entityName)
                                .stateCode(stateCode)
                                .externalId(externalId)
                                .parent(parent)
                                .build());
                        break;
                    case "GROUPOFINSTITUTIONS":
                        orgs.put("GROUPOFINSTITUTIONS" + entityId, SchoolGroup.builder()
                                .naturalId(entityId)
                                .name(entityName)
                                .stateCode(stateCode)
                                .externalId(externalId)
                                .parent(parent)
                                .build());
                        break;
                    case "INSTITUTION":
                        // for institution, if parentType isn't specified, assume it is a district
                        // and try looking it up in the known organizations ...
                        if (parentType == null) {
                            parent = orgs.get("DISTRICT" + parentId);
                        }
                        // completely ignore schools that are not parented by an organization
                        if (parent == null) {
                            logger.info("Skipping school {} (entityId={}) with invalid parent {}", entityName, entityId, parentId);
                        } else {
                            schools.add(School.builder()
                                    .naturalId(entityId)
                                    .name(entityName)
                                    .stateCode(stateCode)
                                    .externalId(externalId)
                                    .parent(parent)
                                    .build());
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }

    private String validateNodeText(final String name, final JsonNode node, final int maxLength) {
        return parserHelper.validate(name, parserHelper.validate(name, node, JsonNode::asText), maxLength, true);
    }

    private String nodeTextOrNull(final String name, final JsonNode node) {
        final JsonNode element = node.get(name);
        if (element == null) return null;

        final String text = element.asText();
        if (!hasText(text)) return null;

        return text;
    }
}
