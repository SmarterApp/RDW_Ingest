package org.opentestsystem.rdw.ingest.processor.service.impl.validator;

import com.google.common.base.Joiner;
import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevels;
import org.opentestsystem.rdw.common.model.subject.ReportAssessmentType;
import org.opentestsystem.rdw.common.model.subject.ReportClaim;
import org.opentestsystem.rdw.common.model.subject.ReportGrade;
import org.opentestsystem.rdw.common.model.subject.ReportPerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.SubjectValidationContext;
import org.opentestsystem.rdw.ingest.processor.service.SubjectValidator;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Sets.newHashSet;

/**
 * This validator validates {@link ReportGrade} models as well as their
 * child {@link ReportAssessmentType}, {@link ReportClaim}, and {@link ReportPerformanceLevel} models.
 * It validates that cross-model references to {@link SubjectAssessmentType}, {@link PerformanceLevel},
 * and {@link ItemClaim} models within the same Subject are valid.
 */
@Component
public class ReportGradeValidator implements SubjectValidator {

    @Override
    public void validate(final SubjectValidationContext context, final Subject subject) {
        if (subject.getReportGrades() == null) return;

        final Set<String> gradeCodes = newHashSet();
        for (final ReportGrade grade : subject.getReportGrades()) {
            final String code = grade.getCode();
            context.push("ReportGrade", code);

            if (!gradeCodes.add(code)) {
                context.failure("Duplicate code found: " + code);
            }
            validateReportAssessmentTypes(context, grade.getReportAssessmentTypes(), subject);

            context.pop();
        }
    }

    private void validateReportAssessmentTypes(final SubjectValidationContext context,
                                               final Collection<ReportAssessmentType> types,
                                               final Subject subject) {
        if (types == null) return;

        final Map<String, SubjectAssessmentType> subjectAssessmentTypes = subject.getAssessmentTypes().stream()
                .collect(Collectors.toMap(
                        SubjectAssessmentType::getCode,
                        type -> type
                ));

        final Set<String> typeCodes = newHashSet();
        for (final ReportAssessmentType type : types) {
            final String code = type.getCode();
            context.push("ReportAssessmentType", code);

            if (!typeCodes.add(code)) {
                context.failure("Duplicate code found: " + code);
            }
            if (!subjectAssessmentTypes.containsKey(code)) {
                context.failure("ReportAssessmentType code must reference an existing Subject.Assessment_Type code: " + code);
            } else {
                final SubjectAssessmentType subjectAssessmentType = subjectAssessmentTypes.get(code);
                //Validate overall performance levels
                validateReportPerformanceLevels(context, subjectAssessmentType.getPerformanceLevels(), type.getReportPerformanceLevels());
                //Validate scorable claims
                validateReportClaims(context, subjectAssessmentType, type.getReportClaims(), subject);
            }


            context.pop();
        }
    }

    private void validateReportPerformanceLevels(final SubjectValidationContext context,
                                                 final PerformanceLevels sourcePerformanceLevels,
                                                 final Collection<ReportPerformanceLevel> performanceLevels) {
        if (performanceLevels == null) return;

        final Set<Integer> sourceLevels = sourcePerformanceLevels.getPerformanceLevels().stream()
                .map(PerformanceLevel::getLevel)
                .collect(Collectors.toSet());

        context.push("ReportPerformanceLevels");
        final Set<Integer> levels = newHashSet();
        for (final ReportPerformanceLevel performanceLevel : performanceLevels) {
            final int level = performanceLevel.getLevel();
            if (!levels.add(level)) {
                context.failure("Duplicate performance level: " + level);
                continue;
            }
            if (!sourceLevels.remove(level)) {
                context.failure("Report references non-existent performance level: " + level);
            }
        }
        if (!sourceLevels.isEmpty()) {
            context.failure("Performance levels exist without associated report messages: " + Joiner.on(", ").join(sourceLevels));
        }
        context.pop();
    }

    private void validateReportClaims(final SubjectValidationContext context,
                                      final SubjectAssessmentType subjectAssessmentType,
                                      final Collection<ReportClaim> claims,
                                      final Subject subject) {
        if (claims == null
                || subjectAssessmentType.getSubScoring() == null
                || subjectAssessmentType.getSubScoring().getPerformanceLevels() == null) {
            // There are no report claims OR the assessment type doesn't support claim-level-scoring
            return;
        }

        final Map<String, ItemClaim> subjectClaims = subject.getClaims().stream()
                .filter(ItemClaim::isScorable)
                .collect(Collectors.toMap(
                        ItemClaim::getCode,
                        claim -> claim
                ));

        final Set<String> claimCodes = newHashSet();
        for (final ReportClaim reportClaim : claims) {
            final String code = reportClaim.getCode();
            context.push("ReportClaim", code);
            if (!claimCodes.add(code)) {
                context.failure("Duplicate report claim: " + code);
                continue;
            }
            if (subjectClaims.remove(code) == null) {
                context.failure("Report references non-existent scorable claim: " + code);
            }

            //Validate claim performance levels
            final PerformanceLevels claimPerformanceLevels = subjectAssessmentType.getSubScoring().getPerformanceLevels();
            validateReportPerformanceLevels(context, claimPerformanceLevels, reportClaim.getPerformanceLevels());
            context.pop();
        }

        if (!subjectClaims.isEmpty()) {
            context.push("ReportClaim");
            context.failure("There exist scorable claims without associated ReportClaim elements: "
                    + Joiner.on(", ").join(subjectClaims.keySet()));
            context.pop();
        }
    }
}
