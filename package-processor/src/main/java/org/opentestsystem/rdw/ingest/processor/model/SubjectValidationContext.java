package org.opentestsystem.rdw.ingest.processor.model;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import com.google.common.collect.Ordering;
import com.google.common.collect.Queues;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Deque;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;

/**
 * This class is responsible for maintaining the current state of a
 * Subject validation.  It tracks the current "location" as well as stores
 * and collates any validation failure messages.
 */
public class SubjectValidationContext {
    private static final Logger logger = LoggerFactory.getLogger(SubjectValidationContext.class);
    private static final Joiner LocationJoiner = Joiner.on(":");
    private static final Ordering<SubjectValidationFailure> FailureOrdering = Ordering.natural()
            .onResultOf(SubjectValidationFailure::getLocation);
    static final int MaxMessageCount = 100;

    private final Deque<String> location;
    private final List<SubjectValidationFailure> failures;
    private final ObjectMapper objectMapper;

    public SubjectValidationContext() {
        this.location = Queues.newArrayDeque();
        this.failures = newArrayList();
        objectMapper = new ObjectMapper();
    }

    /**
     * Push an additional location string onto the location stack.
     * (Example: "SubScoring")
     *
     * @param locationType The location display string
     */
    public void push(final String locationType) {
        this.location.push(locationType);
    }

    /**
     * Push an additional location string with a detail code onto the location stack.
     * (Example: "AssessmentType(ica)")
     *
     * @param locationType The location display string
     * @param code An additional location differentiator
     */
    public void push(final String locationType, final String code) {
        this.location.push(locationType + "(" + code + ")");
    }

    /**
     * Remove the top (most recent) location from the location stack.
     */
    public void pop() {
        if (location.isEmpty()) return;

        location.pop();
    }

    /**
     * Add a failure message with the current location.
     *
     * @param message The failure detail message
     */
    public void failure(final String message) {
        final List<String> orderedLocation = Lists.reverse(newArrayList(location));
        failures.add(new SubjectValidationFailure(LocationJoiner.join(orderedLocation), message));
    }

    /**
     * @return The current failure messages and locations
     */
    public List<SubjectValidationFailure> getFailures() {
        return FailureOrdering.sortedCopy(failures);
    }

    /**
     * @return A JSON representation of the current failure messages and locations, limited to 100 failure messages
     */
    public String toJson() {
        List<SubjectValidationFailure> failures = getFailures();

        //Truncate to MaxMessageCount failure messages.
        if (failures.size() > MaxMessageCount) {
            final List<SubjectValidationFailure> truncatedFailures = newArrayList(failures.subList(0, MaxMessageCount));
            truncatedFailures.add(new SubjectValidationFailure(
                    "System",
                    "With " + (failures.size() - MaxMessageCount) + " additional failures."
            ));
            failures = truncatedFailures;
        }

        try {
            return objectMapper.writeValueAsString(failures);
        } catch (final JsonProcessingException e) {
            logger.warn("Unable to serialize Subject validation failure messages", e);
            return "[{\"location\":\"SystemError\",\"message\":\"Unable to serialize Subject validation failure messages\"}]";
        }
    }

    /**
     * @return True if there are no validation failure messages
     */
    public boolean isValid() {
        return failures.isEmpty();
    }
}
