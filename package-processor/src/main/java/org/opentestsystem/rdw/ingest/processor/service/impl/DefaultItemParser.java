package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Function;
import com.google.common.base.Strings;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.ClaimRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CommonCoreStandardRepository;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.MathPracticeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import static com.google.common.collect.Sets.newHashSet;

@Service
class DefaultItemParser implements ItemParser {

    private static final String ClaimContentTarget = "ClaimContentTarget";
    private static final String SecondaryClaimContentTarget = "SecondaryClaimContentTarget";
    private static final String CommonCore = "CommonCore";
    private static final String SecondaryCommonCore = "SecondaryCommonCore";
    private static final String FullItemKey = "FullItemKey";
    private static final String avg_b = "avg_b";
    private static final String DOK = "DOK";
    private static final String AllowCalculator = "AllowCalculator";
    private static final String MathematicalPractice = "MathematicalPractice";
    private static final String MaxPoints = "MaxPoints";

    private final ClaimRepository claimRepository;
    private final TargetRepository targetRepository;
    private final DepthOfKnowledgeRepository depthOfKnowledgeRepository;
    private final MathPracticeRepository mathPracticeRepository;
    private final CommonCoreStandardRepository commonCoreStandardRepository;

    @Autowired
    public DefaultItemParser(final ClaimRepository claimRepository,
                             final TargetRepository targetRepository,
                             final DepthOfKnowledgeRepository depthOfKnowledgeRepository,
                             final MathPracticeRepository mathPracticeRepository,
                             final CommonCoreStandardRepository commonCoreStandardRepository) {
        this.claimRepository = claimRepository;
        this.targetRepository = targetRepository;
        this.depthOfKnowledgeRepository = depthOfKnowledgeRepository;
        this.mathPracticeRepository = mathPracticeRepository;
        this.commonCoreStandardRepository = commonCoreStandardRepository;
    }

    @Override
    public Item parse(final CSVRecord record, final DataElementErrorCollector errorCollector, final int subjectId) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final ClaimTarget primaryClaimTarget = getClaimTarget(record.get(ClaimContentTarget), ClaimContentTarget, errorCollector);

        final Item.Builder itemBuilder = Item.builder()
                .naturalId(parserHelper.validate(FullItemKey, record.get(FullItemKey), Strings::emptyToNull))
                .claimId(primaryClaimTarget == null ? null : primaryClaimTarget.getClaimId())
                .targetId(primaryClaimTarget == null ? null : primaryClaimTarget.getTargetId())
                .difficulty(parserHelper.validate(avg_b, record.get(avg_b), Doubles::tryParse))
                .dokId(parserHelper.validate(DOK, record.get(DOK), Ints::tryParse, (Function<Integer, Integer>)
                        value -> depthOfKnowledgeRepository.findIdByLevelAndSubject(value, subjectId)))
                .maxPoints(parserHelper.validate(MaxPoints, record.get(MaxPoints), Doubles::tryParse))
                .commonCoreStandards(getCommonCoreStandards(record.get(CommonCore), CommonCore, subjectId, errorCollector))
                .commonCoreStandards(getCommonCoreStandards(record.get(SecondaryCommonCore), SecondaryCommonCore, subjectId, errorCollector));

        //Optional fields
        if (!record.get(AllowCalculator).isEmpty()) {
            itemBuilder.allowCalculator(record.get(AllowCalculator).trim().equals("Yes"));
        }

        if (!record.get(MathematicalPractice).isEmpty() && !record.get(MathematicalPractice).toLowerCase().equals("none")) {
            itemBuilder.mathPractice(parserHelper.validate(MathematicalPractice, record.get(MathematicalPractice).trim(),
                    Ints::tryParse, mathPracticeRepository::findByPractice));
        }
        itemBuilder.otherTargets(getOtherTargets(record.get(SecondaryClaimContentTarget), errorCollector));

        return errorCollector.isEmpty() ? itemBuilder.build() : null;
    }

    private Collection<Integer> getCommonCoreStandards(final String rawValue,
                                                       final String fieldName,
                                                       final Integer subjectId,
                                                       final DataElementErrorCollector errorCollector) {
        final String value = rawValue.trim();
        //common core standards are optional, do not log an error if it is missing
        if (value.isEmpty()) return newHashSet();

        final Set<String> parsedCommonCoreStandards = newHashSet();
        for (final String commonCore : value.split(";")) {
            parsedCommonCoreStandards.add(commonCore.trim().replace("\t", ""));
        }
        final List<Integer> commonCoreStandardIds = commonCoreStandardRepository.findIdsBySubjectIdAndNaturalIds(parsedCommonCoreStandards, subjectId);
        if (commonCoreStandardIds.size() == parsedCommonCoreStandards.size()) return commonCoreStandardIds;

        errorCollector.add(new DataElementError(fieldName, rawValue, "unable to find all common core standards for an item and subject id [" + subjectId + "]"));
        return newHashSet();
    }

    // other targets are optional
    private Collection<Integer> getOtherTargets(final String rawValue, final DataElementErrorCollector elementErrorCollector) {
        final Set<Integer> parsedTargets = newHashSet();

        final String value = rawValue.trim();
        if (value.isEmpty()) return parsedTargets;

        final String[] otherClaimTargets = value.split(";");

        for (final String claimTarget : otherClaimTargets) {
            final ClaimTarget parsedClaimTarget = getClaimTarget(claimTarget, SecondaryClaimContentTarget, elementErrorCollector);
            if (parsedClaimTarget != null) parsedTargets.add(parsedClaimTarget.getTargetId());
        }
        return parsedTargets;
    }

    private ClaimTarget getClaimTarget(final String rawValue, final String field, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final String value = rawValue.trim();
        final int claimSeparatorIndex = rawValue.length() == 0 ? -1 : value.indexOf("|");

        if (claimSeparatorIndex < 1) {
            errorCollector.add(new DataElementError(field, value, "invalid value"));
            return null;
        }

        final Integer claimId = parserHelper.validate(field, value.substring(0, claimSeparatorIndex), Strings::emptyToNull, claimRepository::findIdByCode);
        if (claimId == null) return null;

        final Integer targetId = parserHelper.validate(field, value.substring(claimSeparatorIndex + 1), Strings::emptyToNull,
                (Function<String, Integer>) value1 -> targetRepository.findIdByNaturalIdAndClaimId(value1, claimId));
        if (targetId == null) return null;

        return new ClaimTarget(claimId, targetId);
    }

    private static class ClaimTarget {
        private final Integer claimId;
        private final Integer targetId;

        ClaimTarget(final Integer claimId, final Integer targetId) {
            this.claimId = claimId;
            this.targetId = targetId;
        }

        Integer getClaimId() {
            return claimId;
        }

        Integer getTargetId() {
            return targetId;
        }
    }
}
