package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.primitives.Floats;
import com.google.common.primitives.Ints;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.*;
import org.opentestsystem.rdw.ingest.processor.service.ItemParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.function.Function;

import static org.opentestsystem.rdw.ingest.common.util.Precondition.checkNotBlank;

/**
 * ItemParserImpl - parses and validates item parameters from package
 */
@Service
public class DefaultItemParser implements ItemParser {
    private final ClaimRepository claimRepository;
    private final TargetRepository targetRepository;
    private final DepthOfKnowledgeRepository depthOfKnowledgeRepository;
    private final MathPracticeRepository mathPracticeRepository;

    @Autowired
    public DefaultItemParser(final ClaimRepository claimRepository,
                             final TargetRepository targetRepository,
                             final DepthOfKnowledgeRepository depthOfKnowledgeRepository,
                             final MathPracticeRepository mathPracticeRepository) {
        this.claimRepository = claimRepository;
        this.targetRepository = targetRepository;
        this.depthOfKnowledgeRepository = depthOfKnowledgeRepository;
        this.mathPracticeRepository = mathPracticeRepository;
    }

    //TODO: Change the way parsing is done to collect all errors, similar to exam service
    @Override
    public Item parse(CSVRecord record) throws IllegalArgumentException{
        String claimCode = record.get("Claim").replaceAll("\"", "").trim();
        String targetCode = record.get("Target").replaceAll("\"", "").trim();
        Item.Builder itemBuilder = Item.builder()
                .naturalId(checkNotBlank(record.get("ItemId")))
                .assessmentNaturalId(checkNotBlank(record.get("AssessmentId")))
                .claimId(claimRepository.findIdByCode(claimCode))
                .targetId(targetRepository.findIdByCodeAndClaim(targetCode, claimRepository.findIdByCode(claimCode)))
                .difficulty(basicValidation(record.get("avg_b"), "Invalid difficulty value", Floats::tryParse))
                .dokId(repositoryValidation(record.get("DOK"), "Invalid depth of knowledge level", Ints::tryParse,
                        depthOfKnowledgeRepository::findByLevel));

        //Optional fields
        if(!record.get("AllowCalculator").isEmpty()) {
            itemBuilder.allowCalculator(record.get("AllowCalculator").equals("Yes"));
        }

        if(!record.get("MathematicalPractice").isEmpty()) {
            itemBuilder.mathPractice(repositoryValidation(record.get("MathematicalPractice"),
                    "Invalid math practice", Ints::tryParse, mathPracticeRepository::findByPractice));
        }
        return itemBuilder.build();
    }


    //Basic validation for Number types (integer, float, double, etc), that don't require a query against the database
    private <T extends Number> T basicValidation (String value, String errMessage, Function<String, T> fx) throws IllegalArgumentException {
        T validatedT = fx.apply(value);
        if(validatedT != null) return validatedT;
        else throw new IllegalArgumentException(String.format("%s [%s]", errMessage, value));
    }

    //Validation of values against a supplied repository query, checking for valid primitive type first
    private <T extends Number, R> R repositoryValidation(String value, String errMessage, Function<String, T> fx, Function<T, R> repoFx) throws IllegalArgumentException {
        T validatedVal = basicValidation(value, errMessage, fx);
        return repoFx.apply(validatedVal);
    }

}
