package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.ClaimRepository;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.MathPracticeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;
import org.opentestsystem.rdw.ingest.processor.service.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.service.ItemParser;
import org.opentestsystem.rdw.ingest.processor.utils.ParserHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * ItemParserImpl - parses and validates item parameters from package
 */
@Service
public class DefaultItemParser implements ItemParser {
    private final ClaimRepository claimRepository;
    private final TargetRepository targetRepository;
    private final DepthOfKnowledgeRepository depthOfKnowledgeRepository;
    private final MathPracticeRepository mathPracticeRepository;
    private final ParserHelper parserHelper;
    private final DataElementErrorCollector errorCollector;
    private static final String ITEM_CLAIM = "Claim";
    private static final String ITEM_TARGET = "Target";
    private static final String FULL_ITEM_KEY = "FullItemKey";
    private static final String ASSESSMENT_ID = "AssessmentId";
    private static final String DIFFICULTY = "avg_b";
    private static final String DEPTH_OF_KNOWLEDGE = "DOK";
    private static final String ALLOW_CALCULATOR = "AllowCalculator";
    private static final String MATH_PRACTICE = "MathematicalPractice";


    @Autowired
    public DefaultItemParser(final ClaimRepository claimRepository,
                             final TargetRepository targetRepository,
                             final DepthOfKnowledgeRepository depthOfKnowledgeRepository,
                             final MathPracticeRepository mathPracticeRepository,
                             final ParserHelper parserHelper,
                             final DataElementErrorCollector errorCollector) {
        this.claimRepository = claimRepository;
        this.targetRepository = targetRepository;
        this.depthOfKnowledgeRepository = depthOfKnowledgeRepository;
        this.mathPracticeRepository = mathPracticeRepository;
        this.parserHelper = parserHelper;
        this.errorCollector = errorCollector;
    }

    /**
     * Parse function to validate and extract an {@link Item}. Any errors found are gathered in a central error collector.
     * @param record - {@link CSVRecord} to parse
     * @return {@link Item} if successfully validated and parsed, null otherwise
     */
    @Override
    public Item parse(CSVRecord record){
        Item.Builder itemBuilder = Item.builder()
                .naturalId(parserHelper.basicValidation(FULL_ITEM_KEY, record.get(FULL_ITEM_KEY).trim(),
                        Strings::emptyToNull))
                .assessmentNaturalId(parserHelper.basicValidation(ASSESSMENT_ID, record.get(ASSESSMENT_ID).trim(),
                        Strings::emptyToNull))
                .claimId(parserHelper.repositoryValidation(ITEM_CLAIM, record.get(ITEM_CLAIM).trim(),
                        Strings::emptyToNull, claimRepository::findIdByCode))
                .targetId(parserHelper.repositoryBiValidation(ITEM_TARGET, record.get(ITEM_TARGET).trim(), Strings::emptyToNull,
                        ITEM_CLAIM, record.get(ITEM_CLAIM).trim(), Strings::emptyToNull, targetRepository::findIdByCodeAndClaim))
                .difficulty(parserHelper.basicValidation(DIFFICULTY, record.get(DIFFICULTY),
                        Doubles::tryParse))
                .dokId(parserHelper.repositoryValidation(DEPTH_OF_KNOWLEDGE, record.get(DEPTH_OF_KNOWLEDGE).trim(),
                       Ints::tryParse, depthOfKnowledgeRepository::findByLevel));

        //Optional fields
        if(!record.get(ALLOW_CALCULATOR).isEmpty()) {
            itemBuilder.allowCalculator(record.get(ALLOW_CALCULATOR).trim().equals("Yes"));
        }

        if(!record.get(MATH_PRACTICE).isEmpty()) {
            itemBuilder.mathPractice(parserHelper.repositoryValidation(MATH_PRACTICE, record.get(MATH_PRACTICE).trim(),
                    Ints::tryParse, mathPracticeRepository::findByPractice));
        }
        if (errorCollector.isEmpty()) return itemBuilder.build();
        return null;
    }

}
