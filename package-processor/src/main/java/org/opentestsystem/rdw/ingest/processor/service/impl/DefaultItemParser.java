package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.ClaimRepository;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.MathPracticeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
class DefaultItemParser implements ItemParser {
    private static final String ITEM_CLAIM = "Claim";
    private static final String ITEM_TARGET = "Target";
    private static final String ITEM_CLAIM_TARGET = "ClaimTarget";
    private static final String FULL_ITEM_KEY = "FullItemKey";
    private static final String ASSESSMENT_ID = "AssessmentId";
    private static final String ASSESSMENT_SUBJECT = "AssessmentSubject";
    private static final String DIFFICULTY = "avg_b";
    private static final String DEPTH_OF_KNOWLEDGE = "DOK";
    private static final String ALLOW_CALCULATOR = "AllowCalculator";
    private static final String MATH_PRACTICE = "MathematicalPractice";
    private static final String MAX_POINTS = "MaxPoints";
    private final ClaimRepository claimRepository;
    private final TargetRepository targetRepository;
    private final DepthOfKnowledgeRepository depthOfKnowledgeRepository;
    private final MathPracticeRepository mathPracticeRepository;

    @Autowired
    public DefaultItemParser(final ClaimRepository claimRepository,
                             final TargetRepository targetRepository,
                             final DepthOfKnowledgeRepository depthOfKnowledgeRepository,
                             final MathPracticeRepository mathPracticeRepository) {
        this.claimRepository = claimRepository;
        this.targetRepository = targetRepository;
        this.depthOfKnowledgeRepository = depthOfKnowledgeRepository;
        this.mathPracticeRepository = mathPracticeRepository;
    }

    @Override
    public Item parse(final CSVRecord record, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        Item.Builder itemBuilder = Item.builder()
                .naturalId(parserHelper.basicValidation(FULL_ITEM_KEY, record.get(FULL_ITEM_KEY).trim(),
                        Strings::emptyToNull))
                .assessmentNaturalId(parserHelper.basicValidation(ASSESSMENT_ID, record.get(ASSESSMENT_ID).trim(),
                        Strings::emptyToNull))
                .claimId(parserHelper.repositoryValidation(ITEM_CLAIM, toClaim(record.get(ITEM_CLAIM_TARGET).trim()),
                        Strings::emptyToNull, claimRepository::findIdByCode))
                .targetId(parserHelper.repositoryBiValidation(ITEM_TARGET, toTargetNaturalId(record.get(ITEM_CLAIM_TARGET).trim()), Strings::emptyToNull,
                        ITEM_CLAIM, toClaim(record.get(ITEM_CLAIM_TARGET).trim()), Strings::emptyToNull, targetRepository::findIdByNaturalIdAndClaim))
                .difficulty(parserHelper.basicValidation(DIFFICULTY, record.get(DIFFICULTY),
                        Doubles::tryParse))
                .dokId(parserHelper.repositoryBiValidation(DEPTH_OF_KNOWLEDGE, record.get(DEPTH_OF_KNOWLEDGE).trim(),
                        Ints::tryParse, ASSESSMENT_SUBJECT, record.get(ASSESSMENT_SUBJECT).trim(), Strings::emptyToNull,
                        depthOfKnowledgeRepository::findIdByLevelAndSubject))
                .maxPoints(parserHelper.basicValidation(MAX_POINTS, record.get(MAX_POINTS).trim(),
                        Doubles::tryParse));

        //Optional fields
        if (!record.get(ALLOW_CALCULATOR).isEmpty()) {
            itemBuilder.allowCalculator(record.get(ALLOW_CALCULATOR).trim().equals("Yes"));
        }

        if (!record.get(MATH_PRACTICE).isEmpty() && !record.get(MATH_PRACTICE).toLowerCase().equals("none")) {
            itemBuilder.mathPractice(parserHelper.repositoryValidation(MATH_PRACTICE, record.get(MATH_PRACTICE).trim(),
                    Ints::tryParse, mathPracticeRepository::findByPractice));
        }

        return errorCollector.isEmpty() ? itemBuilder.build() : null;
    }

    private String toClaim(final String claimTarget) {
        final int claimEndIndex = findClaimSeparatorIndex(claimTarget);

        return claimEndIndex < 1 ? null : claimTarget.substring(0, claimEndIndex);
    }

    private String toTargetNaturalId(final String claimTarget) {
        final int claimEndIndex = findClaimSeparatorIndex(claimTarget);

        return claimEndIndex < 1 ? null : claimTarget.substring(claimEndIndex + 1);
    }

    private int findClaimSeparatorIndex(final String claimTarget) {
        if (claimTarget == null || claimTarget.length() == 0) return -1;
        return claimTarget.indexOf("|");
    }
}
