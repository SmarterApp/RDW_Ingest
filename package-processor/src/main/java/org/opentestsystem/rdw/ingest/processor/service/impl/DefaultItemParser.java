package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.error.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.ClaimRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CommonCoreStandardRepository;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.MathPracticeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;

@Service
class DefaultItemParser implements ItemParser {

    private static final String OtherClaimTargets = "OtherClaimTargets";
    private static final String CommonCore = "CommonCore";
    private static final String FullItemKey = "FullItemKey";
    private static final String avg_b = "avg_b";
    private static final String DOK = "DOK";
    private static final String AllowCalculator = "AllowCalculator";
    private static final String MathematicalPractice = "MathematicalPractice";
    private static final String MaxPoints = "MaxPoints";

    private final ClaimRepository claimRepository;
    private final TargetRepository targetRepository;
    private final DepthOfKnowledgeRepository depthOfKnowledgeRepository;
    private final MathPracticeRepository mathPracticeRepository;
    private final CommonCoreStandardRepository commonCoreStandardRepository;

    @Autowired
    public DefaultItemParser(final ClaimRepository claimRepository,
                             final TargetRepository targetRepository,
                             final DepthOfKnowledgeRepository depthOfKnowledgeRepository,
                             final MathPracticeRepository mathPracticeRepository,
                             final CommonCoreStandardRepository commonCoreStandardRepository) {
        this.claimRepository = claimRepository;
        this.targetRepository = targetRepository;
        this.depthOfKnowledgeRepository = depthOfKnowledgeRepository;
        this.mathPracticeRepository = mathPracticeRepository;
        this.commonCoreStandardRepository = commonCoreStandardRepository;
    }

    @Override
    public Item parse(final CSVRecord record, final DataElementErrorCollector errorCollector, final int subjectId) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final ClaimTarget primaryClaimTarget = getClaimTarget(record.get("ClaimTarget"), "ClaimTarget", errorCollector);

        Item.Builder itemBuilder = Item.builder()
                .naturalId(parserHelper.basicValidation(FullItemKey, record.get(FullItemKey), Strings::emptyToNull))
                .claimId(primaryClaimTarget == null ? null : primaryClaimTarget.getClaimId())
                .targetId(primaryClaimTarget == null ? null : primaryClaimTarget.getTargetId())
                .difficulty(parserHelper.basicValidation(avg_b, record.get(avg_b), Doubles::tryParse))
                .dokId(parserHelper.repositoryBiValidation(DOK, record.get(DOK), Ints::tryParse, subjectId, depthOfKnowledgeRepository::findIdByLevelAndSubject))
                .maxPoints(parserHelper.basicValidation(MaxPoints, record.get(MaxPoints), Doubles::tryParse))
                .commonCoreStandards(getCommonCoreStandards(record.get(CommonCore), subjectId, errorCollector));

        //Optional fields
        if (!record.get(AllowCalculator).isEmpty()) {
            itemBuilder.allowCalculator(record.get(AllowCalculator).trim().equals("Yes"));
        }

        if (!record.get(MathematicalPractice).isEmpty() && !record.get(MathematicalPractice).toLowerCase().equals("none")) {
            itemBuilder.mathPractice(parserHelper.repositoryValidation(MathematicalPractice, record.get(MathematicalPractice).trim(),
                    Ints::tryParse, mathPracticeRepository::findByPractice));
        }
        itemBuilder.otherTargets(getOtherTargets(record.get(OtherClaimTargets), errorCollector));

        return errorCollector.isEmpty() ? itemBuilder.build() : null;
    }

    private Iterable<Integer> getCommonCoreStandards(final String rawValue, final Integer subjectId, final DataElementErrorCollector errorCollector) {

        final String value = rawValue.trim();
        //common core standards are optional, do not log an error if it is missing
        if (value.isEmpty()) return newArrayList();

        final String[] parsedCommonCoreStandards = value.split(";");

        final List<Integer> commonCoreStandardIds = commonCoreStandardRepository.findIdsBySubjectIdAndNaturalIds(Arrays.asList(parsedCommonCoreStandards), subjectId);
        if (commonCoreStandardIds.size() == parsedCommonCoreStandards.length) return commonCoreStandardIds;

        errorCollector.addDataElementError(new DataElementError(CommonCore, rawValue, "unable to find all common core standards for an item"));
        return newArrayList();
    }

    // other targets are optional
    private List<Integer> getOtherTargets(final String rawValue, final DataElementErrorCollector elementErrorCollector) {
        final List<Integer> parsedTargets = newArrayList();

        final String value = rawValue.trim();
        if (value.isEmpty()) return parsedTargets;

        final String[] otherClaimTargets = value.split(";");

        for (final String claimTarget : otherClaimTargets) {
            final ClaimTarget parsedClaimTarget = getClaimTarget(claimTarget, OtherClaimTargets, elementErrorCollector);
            if (parsedClaimTarget != null) parsedTargets.add(parsedClaimTarget.getTargetId());
        }
        return parsedTargets;
    }

    private ClaimTarget getClaimTarget(final String rawValue, final String field, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final String value = rawValue.trim();
        final int claimSeparatorIndex = rawValue.length() == 0 ? -1 : value.indexOf("|");

        if (claimSeparatorIndex < 1) {
            errorCollector.addDataElementError(new DataElementError(field, value, "invalid value"));
            return null;
        }

        final Integer claimId = parserHelper.repositoryValidation(field, value.substring(0, claimSeparatorIndex), Strings::emptyToNull, claimRepository::findIdByCode);
        if (claimId == null) return null;

        final Integer targetId = parserHelper.repositoryBiValidation(field, value.substring(claimSeparatorIndex + 1), Strings::emptyToNull, claimId, targetRepository::findIdByNaturalIdAndClaimId);
        if (targetId == null) return null;

        return new ClaimTarget(claimId, targetId);
    }

    private static class ClaimTarget {
        private final Integer claimId;
        private final Integer targetId;

        ClaimTarget(final Integer claimId, final Integer targetId) {
            this.claimId = claimId;
            this.targetId = targetId;
        }

        Integer getClaimId() {
            return claimId;
        }

        Integer getTargetId() {
            return targetId;
        }
    }
}
