package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import com.google.common.primitives.Doubles;
import com.google.common.primitives.Ints;
import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.ClaimRepository;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.MathPracticeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * ItemParserImpl - parses and validates item parameters from package
 */
@Service
public class DefaultItemParser implements ItemParser {
    private static final String ITEM_CLAIM = "Claim";
    private static final String ITEM_TARGET = "Target";
    private static final String FULL_ITEM_KEY = "FullItemKey";
    private static final String ASSESSMENT_ID = "AssessmentId";
    private static final String ASSESSMENT_SUBJECT = "AssessmentSubject";
    private static final String DIFFICULTY = "avg_b";
    private static final String DEPTH_OF_KNOWLEDGE = "DOK";
    private static final String ALLOW_CALCULATOR = "AllowCalculator";
    private static final String MATH_PRACTICE = "MathematicalPractice";
    private static final String MAX_POINTS = "MaxPoints";
    private final ClaimRepository claimRepository;
    private final TargetRepository targetRepository;
    private final DepthOfKnowledgeRepository depthOfKnowledgeRepository;
    private final MathPracticeRepository mathPracticeRepository;
    private final SubjectRepository subjectRepository;

    @Autowired
    public DefaultItemParser(final ClaimRepository claimRepository,
                             final TargetRepository targetRepository,
                             final DepthOfKnowledgeRepository depthOfKnowledgeRepository,
                             final MathPracticeRepository mathPracticeRepository,
                             final SubjectRepository subjectRepository) {
        this.claimRepository = claimRepository;
        this.targetRepository = targetRepository;
        this.depthOfKnowledgeRepository = depthOfKnowledgeRepository;
        this.mathPracticeRepository = mathPracticeRepository;
        this.subjectRepository = subjectRepository;
    }

    /**
     * Parse function to validate and extract an {@link Item}. Any errors found are gathered in the error collector.
     *
     * @param record         {@link CSVRecord} to parse
     * @param errorCollector error collector
     * @return {@link Item} if successfully validated and parsed, null otherwise
     */
    @Override
    public Item parse(final CSVRecord record, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        //TODO: add more tests
        parserHelper.repositoryValidation(ASSESSMENT_SUBJECT, record.get(ASSESSMENT_SUBJECT).trim(), Strings::emptyToNull, subjectRepository::findIdByName);

        Item.Builder itemBuilder = Item.builder()
                .naturalId(parserHelper.basicValidation(FULL_ITEM_KEY, record.get(FULL_ITEM_KEY).trim(),
                        Strings::emptyToNull))
                .assessmentNaturalId(parserHelper.basicValidation(ASSESSMENT_ID, record.get(ASSESSMENT_ID).trim(),
                        Strings::emptyToNull))
                .claimId(parserHelper.repositoryValidation(ITEM_CLAIM, record.get(ITEM_CLAIM).trim(),
                        Strings::emptyToNull, claimRepository::findIdByCode))
                .targetId(parserHelper.repositoryBiValidation(ITEM_TARGET, record.get(ITEM_TARGET).trim(), Strings::emptyToNull,
                        ITEM_CLAIM, record.get(ITEM_CLAIM).trim(), Strings::emptyToNull, targetRepository::findIdByCodeAndClaim))
                .difficulty(parserHelper.basicValidation(DIFFICULTY, record.get(DIFFICULTY),
                        Doubles::tryParse))
                .dokId(parserHelper.repositoryBiValidation(DEPTH_OF_KNOWLEDGE, record.get(DEPTH_OF_KNOWLEDGE).trim(),
                        Ints::tryParse, ASSESSMENT_SUBJECT, record.get(ASSESSMENT_SUBJECT).trim(), Strings::emptyToNull,
                        depthOfKnowledgeRepository::findIdByLevelAndSubject))
                .maxPoints(parserHelper.basicValidation(MAX_POINTS, record.get(MAX_POINTS).trim(),
                        Doubles::tryParse));

        //Optional fields
        if (!record.get(ALLOW_CALCULATOR).isEmpty()) {
            itemBuilder.allowCalculator(record.get(ALLOW_CALCULATOR).trim().equals("Yes"));
        }

        if (!record.get(MATH_PRACTICE).isEmpty() && !record.get(MATH_PRACTICE).toLowerCase().equals("none")) {
            itemBuilder.mathPractice(parserHelper.repositoryValidation(MATH_PRACTICE, record.get(MATH_PRACTICE).trim(),
                    Ints::tryParse, mathPracticeRepository::findByPractice));
        }

        return errorCollector.isEmpty() ? itemBuilder.build() : null;
    }

}
