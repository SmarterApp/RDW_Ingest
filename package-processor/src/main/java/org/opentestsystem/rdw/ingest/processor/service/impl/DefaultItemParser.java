package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.apache.commons.csv.CSVRecord;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.ClaimRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CommonCoreStandardRepository;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.MathPracticeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.Set;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toBooleanOrNull;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toDouble;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toInteger;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toIntegerOrNull;

@Service
class DefaultItemParser implements ItemParser {
    private static final Logger logger = LoggerFactory.getLogger(DefaultItemParser.class);

    private static final String ClaimContentTarget = "ClaimContentTarget";
    private static final String SecondaryClaimContentTarget = "SecondaryClaimContentTarget";
    private static final String CommonCore = "CommonCore";
    private static final String SecondaryCommonCore = "SecondaryCommonCore";
    private static final String FullItemKey = "FullItemKey";
    private static final String avg_b = "avg_b";
    private static final String DOK = "DOK";
    private static final String ItemPosition = "ItemPosition";
    private static final String AllowCalculator = "AllowCalculator";
    private static final String MathematicalPractice = "MathematicalPractice";
    private static final String MaxPoints = "MaxPoints";
    private static final String AnswerKey = "AnswerKey";
    private static final String NumberOfAnswerOptions = "NumberOfAnswerOptions";
    private static final String IsFieldTest = "IsFieldTest";
    private static final String IsActive = "IsActive";
    private static final String ItemType = "ItemType";

    private final ClaimRepository claimRepository;
    private final TargetRepository targetRepository;
    private final DepthOfKnowledgeRepository depthOfKnowledgeRepository;
    private final MathPracticeRepository mathPracticeRepository;
    private final CommonCoreStandardRepository commonCoreStandardRepository;

    @Autowired
    public DefaultItemParser(final ClaimRepository claimRepository,
                             final TargetRepository targetRepository,
                             final DepthOfKnowledgeRepository depthOfKnowledgeRepository,
                             final MathPracticeRepository mathPracticeRepository,
                             final CommonCoreStandardRepository commonCoreStandardRepository) {
        this.claimRepository = claimRepository;
        this.targetRepository = targetRepository;
        this.depthOfKnowledgeRepository = depthOfKnowledgeRepository;
        this.mathPracticeRepository = mathPracticeRepository;
        this.commonCoreStandardRepository = commonCoreStandardRepository;
    }

    @Override
    public Item parse(final CSVRecord record, final DataElementErrorCollector errorCollector, final String asmtNaturalId, final int subjectId) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final String naturalId = parserHelper.validate("Asmt id [" + asmtNaturalId + "], " + FullItemKey, record.get(FullItemKey), 40, true);

        final String logMsgPrefix = "[" + asmtNaturalId + "], item id [" + naturalId + "], ";
        final ClaimTarget primaryClaimTarget = getClaimTarget(record.get(ClaimContentTarget), logMsgPrefix + ClaimContentTarget, errorCollector);
        final String itemType = parserHelper.validate(logMsgPrefix + ItemType, record.get(ItemType), checkNotBlank);

        final Collection<Integer> commonCoreStandards = getCommonCoreStandards(record.get(CommonCore), logMsgPrefix + CommonCore, subjectId, errorCollector);
        commonCoreStandards.addAll(getCommonCoreStandards(record.get(SecondaryCommonCore), logMsgPrefix + SecondaryCommonCore, subjectId, errorCollector));

        final Item.Builder itemBuilder = Item.builder()
                .naturalId(naturalId)
                .claimId(primaryClaimTarget == null ? null : primaryClaimTarget.getClaimId())
                .targetId(primaryClaimTarget == null ? null : primaryClaimTarget.getTargetId())
                .difficulty(parserHelper.validate(naturalId + " " + avg_b, record.get(avg_b), toDouble))
                .dokId(parserHelper.validate(logMsgPrefix + DOK, record.get(DOK),
                        toInteger.andThen(value -> depthOfKnowledgeRepository.findIdByLevelAndSubject(value, subjectId)).andThen(new CheckNotNull<>())))
                .position(parserHelper.validate(logMsgPrefix + ItemPosition, record.get(ItemPosition), toIntegerOrNull))
                .maxPoints(parserHelper.validate(logMsgPrefix + MaxPoints, record.get(MaxPoints), toDouble))
                .mathPractice(getMathPractice(logMsgPrefix + MathematicalPractice, record.get(MathematicalPractice), parserHelper))
                .allowCalculator(parserHelper.validate(logMsgPrefix + AllowCalculator, record.get(AllowCalculator), toBooleanOrNull))
                .commonCoreStandards(commonCoreStandards)
                .otherTargets(getOtherTargets(record.get(SecondaryClaimContentTarget), errorCollector, logMsgPrefix + SecondaryClaimContentTarget))
                .active(parserHelper.validate(logMsgPrefix + IsActive, record.get(IsActive), toBooleanOrNull))
                .fieldTest(parserHelper.validate(logMsgPrefix + IsFieldTest, record.get(IsFieldTest), toBooleanOrNull))
                .optionsCount(parserHelper.validate(logMsgPrefix + NumberOfAnswerOptions, record.get(NumberOfAnswerOptions), toInteger))
                .type(itemType)
                .answerKey(getAnswerKey(logMsgPrefix + AnswerKey, record.get(AnswerKey), parserHelper, itemType));

        return errorCollector.isEmpty() ? itemBuilder.build() : null;
    }

    private String getAnswerKey(final String name, final String rawValue, final ParserHelper parserHelper, final String itemType) {
        if (!itemType.equalsIgnoreCase("MS") && !itemType.equalsIgnoreCase("MC")) return rawValue;

        return parserHelper.validate(name, rawValue, checkNotBlank);
    }

    private Integer getMathPractice(final String name, final String rawValue, final ParserHelper parserHelper) {
        if (isNullOrEmpty(rawValue) || "none".equalsIgnoreCase(rawValue)) return null;
        return parserHelper.validate(name, rawValue,
                toInteger.andThen(mathPracticeRepository::findByPractice).andThen(new CheckNotNull<>()));
    }

    private Collection<Integer> getCommonCoreStandards(final String rawValue,
                                                       final String fieldName,
                                                       final Integer subjectId,
                                                       final DataElementErrorCollector errorCollector) {
        final String value = rawValue.trim();
        //common core standards are optional, do not log an error if it is missing
        if (value.isEmpty()) return newHashSet();

        final Set<String> parsedCommonCoreStandards = newHashSet();
        for (final String commonCore : value.split(";")) {
            parsedCommonCoreStandards.add(commonCore.trim().replace("\t", ""));
        }
        final List<Integer> commonCoreStandardIds = commonCoreStandardRepository.findIdsBySubjectIdAndNaturalIds(parsedCommonCoreStandards, subjectId);
        if (commonCoreStandardIds.size() == parsedCommonCoreStandards.size()) return commonCoreStandardIds;

        logger.info("Common core standard not found for '{}'", value);
        errorCollector.add(new DataElementError(fieldName, rawValue, "unable to find all common core standards for an item and subject id [" + subjectId + "]"));
        return newHashSet();
    }

    // other targets are optional
    private Collection<Integer> getOtherTargets(final String rawValue, final DataElementErrorCollector elementErrorCollector, final String logMsg) {
        final Set<Integer> parsedTargets = newHashSet();

        final String value = rawValue.trim();
        if (value.isEmpty()) return parsedTargets;

        final String[] otherClaimTargets = value.split(";");

        for (final String claimTarget : otherClaimTargets) {
            final ClaimTarget parsedClaimTarget = getClaimTarget(claimTarget, logMsg, elementErrorCollector);
            if (parsedClaimTarget != null) parsedTargets.add(parsedClaimTarget.getTargetId());
        }
        return parsedTargets;
    }

    private ClaimTarget getClaimTarget(final String rawValue, final String field, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final String value = rawValue == null ? "" : rawValue.trim();
        final int claimSeparatorIndex = value.isEmpty() ? -1 : value.indexOf("|");

        if (claimSeparatorIndex < 1) {
            errorCollector.add(new DataElementError(field, value, "invalid value"));
            return null;
        }

        final Integer claimId = parserHelper.validate(field, value.substring(0, claimSeparatorIndex), checkNotBlank.andThen(claimRepository::findIdByCode));
        if (claimId == null) {
            logger.info("Claim not found for '{}'", value);
            errorCollector.add(new DataElementError(field, value, "claim not found"));
            return null;
        }

        final Integer targetId = parserHelper.validate(field, value.substring(claimSeparatorIndex + 1), checkNotBlank.andThen(value1 -> targetRepository.findIdByNaturalIdAndClaimId(value1, claimId)));
        if (targetId == null) {
            logger.info("Target not found for '{}'", value);
            errorCollector.add(new DataElementError(field, value, "target not found for"));
            return null;
        }

        return new ClaimTarget(claimId, targetId);
    }

    private static class ClaimTarget {
        private final Integer claimId;
        private final Integer targetId;

        ClaimTarget(final Integer claimId, final Integer targetId) {
            this.claimId = claimId;
            this.targetId = targetId;
        }

        Integer getClaimId() {
            return claimId;
        }

        Integer getTargetId() {
            return targetId;
        }
    }
}
