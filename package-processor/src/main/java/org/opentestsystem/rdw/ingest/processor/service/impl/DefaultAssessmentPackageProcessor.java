package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Item;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.opentestsystem.rdw.ingest.processor.service.AssessmentPackageProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Objects;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toMap;
import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.ingest.common.util.JdbcUtil.equivalent;

@Service
class DefaultAssessmentPackageProcessor implements AssessmentPackageProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAssessmentPackageProcessor.class);
    private final AssessmentPackageRepository packageRepository;
    private final AssessmentParser parser;

    @Autowired
    public DefaultAssessmentPackageProcessor(final AssessmentPackageRepository packageRepository,
                                             final AssessmentParser parser) {
        this.packageRepository = packageRepository;
        this.parser = parser;
    }

    @Override
    public String process(final byte[] assessmentPackage, final long importId) {
        final DataElementErrorCollector elementErrorCollector = new DataElementErrorCollector();

        final List<Assessment> assessments = parser.parse(assessmentPackage, elementErrorCollector);

        //If there are errors in the container, don't insert anything into the database, just bail out
        if (!elementErrorCollector.isEmpty()) throw new ImportException(BAD_DATA, elementErrorCollector.toJson());

        final List<Assessment> newAssessments = newArrayList();
        final List<Assessment> updatedAssessments = newArrayList();
        final List<Assessment> rejectedAssessments = newArrayList();

        for (final Assessment toUpsert : assessments) {

            final Assessment existing = packageRepository.findOneByNaturalId(toUpsert.getNaturalId());

            if (existing == null) {
                newAssessments.add(toUpsert);
            } else if (validToUpdate(existing, toUpsert)) {
                final Assessment assessmentToUpdate = processAssessmentForUpdate(existing, toUpsert);
                if (assessmentToUpdate != null) updatedAssessments.add(assessmentToUpdate);
            } else {
                rejectedAssessments.add(toUpsert);
                // TODO: not sure what to do here ?
            }
        }
        packageRepository.update(updatedAssessments, importId);
        packageRepository.create(newAssessments, importId);
        final String msg = "Total assessments processed " + assessments.size() + ", newly created count " + newAssessments.size() + ", updated count " + updatedAssessments.size() + ", rejected count " + rejectedAssessments.size();
        logger.info(msg);
        return msg;
    }

    private boolean validToUpdate(final Assessment existing, final Assessment toUpsert) {
        return existing.getSubjectId() == toUpsert.getSubjectId()
                && existing.getGradeId() == toUpsert.getGradeId()
                && existing.getTypeId() == toUpsert.getTypeId();
    }

    /**
     * Combines existing assessment with the newly provided one.
     * The rules for building the assessment are:
     * - the assessment must be updated if at least one field has changed. This is done to update the import id and 'updated' timestamp for migrate to pick up the change.
     * - if an existing assessment has more items, they should be preserved, we do not allow for items to be deleted in a case there are exams that are linked to it
     */
    private Assessment processAssessmentForUpdate(final Assessment existing, final Assessment toUpsert) {
        boolean update = !asmWithoutItemsEqual(existing, toUpsert);

        final Assessment.Builder asmtBuilder = Assessment.builder()
                .copyWithoutItems(toUpsert)
                .id(existing.getId());

        final Map<String, Item> existingItemsById = existing.getItems().stream().collect(toMap(Item::getNaturalId, i -> i));
        final List<Item> items = newArrayList();

        for (final Item itemToUpsert : toUpsert.getItems()) {
            if (existingItemsById.containsKey(itemToUpsert.getNaturalId())) {
                final Item existingItem = existingItemsById.get(itemToUpsert.getNaturalId());
                final Item updatedItem = Item.builder().copy(itemToUpsert).id(existingItem.getId()).build();
                if (!updatedItem.equals(existingItem)) {
                    items.add(updatedItem);
                    update = true;
                }
            } else {
                items.add(itemToUpsert);
                update = true;
            }
        }
        return update ? asmtBuilder.items(items).build() : null;
    }

    private boolean asmWithoutItemsEqual(final Assessment one, final Assessment another) {
        return Objects.equals(one.getCutPoint1(), another.getCutPoint1())
                && equivalent(one.getCutPoint2(), another.getCutPoint2())
                && equivalent(one.getCutPoint3(), another.getCutPoint3())
                && equivalent(one.getMaxScore(), another.getMaxScore())
                && equivalent(one.getMinScore(), another.getMinScore())
                && Objects.equals(one.getName(), another.getName())
                && Objects.equals(one.getLabel(), another.getLabel())
                && Objects.equals(one.getVersion(), another.getVersion())
                && (one.getTypeId() == another.getTypeId())
                && (one.getSchoolYear() == another.getSchoolYear());
    }
}

