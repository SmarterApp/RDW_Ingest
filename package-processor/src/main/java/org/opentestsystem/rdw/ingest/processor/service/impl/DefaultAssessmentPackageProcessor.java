package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseAssessment;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseAssessmentItem;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseAssessmentScoring;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentPackageRepository;
import org.opentestsystem.rdw.ingest.processor.service.AssessmentPackageProcessor;
import org.opentestsystem.rdw.utils.DataElementErrorCollector;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.ingest.common.util.JdbcUtil.equivalent;

@Service
class DefaultAssessmentPackageProcessor implements AssessmentPackageProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAssessmentPackageProcessor.class);
    private final AssessmentPackageRepository packageRepository;
    private final AssessmentParser parser;

    @Autowired
    public DefaultAssessmentPackageProcessor(final AssessmentPackageRepository packageRepository,
                                             final AssessmentParser parser) {
        this.packageRepository = packageRepository;
        this.parser = parser;
    }

    @Override
    public String process(final byte[] assessmentPackage, final long importId) {
        final DataElementErrorCollector elementErrorCollector = new DataElementErrorCollector();

        final List<WarehouseAssessment> assessments = parser.parse(assessmentPackage, elementErrorCollector);

        //If there are errors in the container, don't insert anything into the database, just bail out
        if (!elementErrorCollector.isEmpty()) {
            throw new ImportException(BAD_DATA, elementErrorCollector.toJson());
        }

        final List<WarehouseAssessment> newAssessments = newArrayList();
        final List<WarehouseAssessment> updatedAssessments = newArrayList();
        final List<WarehouseAssessment> rejectedAssessments = newArrayList();

        for (final WarehouseAssessment toUpsert : assessments) {
            final WarehouseAssessment existing = packageRepository.findOneByNaturalId(toUpsert.getNaturalId());

            if (existing == null) {
                newAssessments.add(toUpsert);
            } else if (validToUpdate(existing, toUpsert)) {
                final WarehouseAssessment assessmentToUpdate = processAssessmentForUpdate(existing, toUpsert);
                if (assessmentToUpdate != null) updatedAssessments.add(assessmentToUpdate);
            } else {
                rejectedAssessments.add(toUpsert);
            }
        }
        packageRepository.update(updatedAssessments, importId);
        packageRepository.create(newAssessments, importId);
        final String msg = "Assessments processed: " + assessments.size() + ", created: " + newAssessments.size() + ", updated: " + updatedAssessments.size() + ", rejected: " + rejectedAssessments.size();
        logger.info(msg);
        return msg;
    }

    private boolean validToUpdate(final WarehouseAssessment existing, final WarehouseAssessment toUpsert) {
        return existing.getSubjectId() == toUpsert.getSubjectId()
                && existing.getGradeId() == toUpsert.getGradeId()
                && existing.getTypeId() == toUpsert.getTypeId();
    }

    /**
     * Combines existing assessment with the newly provided one.
     * The rules for building the assessment are:
     * <ul>
     * <li>the assessment must be updated if at least one field has changed.
     * This is done to update the import id and 'updated' timestamp for migrate to pick up the change.
     * </li>
     * <li>if an existing assessment has more items, they should be preserved,
     * we do not allow for items to be deleted in a case there are exams that are linked to it
     * </li>
     * </ul>
     **/
    private WarehouseAssessment processAssessmentForUpdate(final WarehouseAssessment existingAsmt, final WarehouseAssessment toUpsert) {
        boolean update = !equalsIgnoringItems(existingAsmt, toUpsert);

        final WarehouseAssessment.Builder asmtBuilder = WarehouseAssessment.builder()
                .copyWithoutItems(toUpsert)
                .id(existingAsmt.getId());

        final List<WarehouseAssessmentItem> items = newArrayList();

        for (final WarehouseAssessmentItem itemToUpsert : toUpsert.getItems()) {
            final WarehouseAssessmentItem existingItem = existingAsmt.findItem(itemToUpsert.getNaturalId());
            if (existingItem != null) {
                final WarehouseAssessmentItem updatedItem = WarehouseAssessmentItem.builder().copy(itemToUpsert).id(existingItem.getId()).build();
                if (!updatedItem.equals(existingItem)) {
                    items.add(updatedItem);
                    update = true;
                }
            } else {
                items.add(itemToUpsert);
                update = true;
            }
        }
        return update ? asmtBuilder.items(items).build() : null;
    }

    private boolean equalsIgnoringItems(final WarehouseAssessment o1, final WarehouseAssessment o2) {
        // if we got here, we already know that naturalId, subjectId, gradeId, and typeId are equal

        if (!Objects.equals(o1.getName(), o2.getName())
         && Objects.equals(o1.getLabel(), o2.getLabel())
         && Objects.equals(o1.getVersion(), o2.getVersion())
         && (o1.getTypeId() == o2.getTypeId())
         && (o1.getSchoolYear() == o2.getSchoolYear())) {
            return false;
        }

        final Map<Integer, WarehouseAssessmentScoring> s1 = o1.getScores().stream().collect(Collectors.toMap(WarehouseAssessmentScoring::getSubjectScoreId, s -> s));
        final Map<Integer, WarehouseAssessmentScoring> s2 = o2.getScores().stream().collect(Collectors.toMap(WarehouseAssessmentScoring::getSubjectScoreId, s -> s));
        if (!s1.keySet().equals(s2.keySet())) {
            return false;
        }
        for (final Integer subjectScoreId : s1.keySet()) {
            if (!equalsForUpdate(s1.get(subjectScoreId), s2.get(subjectScoreId))) {
                return false;
            }
        }

        return true;
    }

    private boolean equalsForUpdate(final WarehouseAssessmentScoring o1, final WarehouseAssessmentScoring o2) {
        return Objects.equals(o1.getSubjectScoreId(), o2.getSubjectScoreId())
                && equivalent(o1.getCutPoint1(), o2.getCutPoint1())
                && equivalent(o1.getCutPoint2(), o2.getCutPoint2())
                && equivalent(o1.getCutPoint3(), o2.getCutPoint3())
                && equivalent(o1.getCutPoint4(), o2.getCutPoint4())
                && equivalent(o1.getCutPoint5(), o2.getCutPoint5())
                && equivalent(o1.getMinScore(), o2.getMinScore())
                && equivalent(o1.getMaxScore(), o2.getMaxScore());
    }
}

