package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Accommodation;
import org.opentestsystem.rdw.ingest.processor.repository.AccommodationTranslationRepository;
import org.opentestsystem.rdw.ingest.processor.service.AccommodationsProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.common.model.ImportStatus.BAD_DATA;

/**
 * DefaultAccessibilityProcessor
 */
@Service
class DefaultAccommodationsProcessor implements AccommodationsProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAccommodationsProcessor.class);

    private final AccommodationTranslationRepository translationRepository;

    private final XPathExpression xpathAccSelections;
    private final XPathExpression xpathCode;
    private final XPathExpression xpathText;
    private final XPathExpression xpathLanguage;
    private final XPathExpression xpathLabel;

    @Autowired
    public DefaultAccommodationsProcessor(final AccommodationTranslationRepository translationRepository) {
        this.translationRepository = translationRepository;

        // compile the xpath expressions so we fast-fail for any coding errors
        final XPath xpath = XPathFactory.newInstance().newXPath();
        try {
            xpathAccSelections = xpath.compile("/Accessibility/MasterResourceFamily/*[starts-with(ResourceType,'Accom')]/Selection");
            xpathCode = xpath.compile("Code");
            xpathText = xpath.compile("Text");
            xpathLanguage = xpath.compile("Language");
            xpathLabel = xpath.compile("Label");
        } catch (final XPathExpressionException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Processes an Accessibility Config File in xml format for accommodation codes and their
     * translations and inserts the codes and translations in to the data warehouse.
     *
     * This does not remove any existing accommodations or translations. It may result in the 'orphan' values.
     *
     * <p>
     * Implementation note: javax.xml has a terrible interface so there are some helpers that
     * try to hide that ugliness and make the main code look a little more like java 8.
     * </p>
     *
     * @param accessibilityConfig An Accessibility Config File as referenced at https://github.com/SmarterApp/AccessibilityAccommodationConfigurations
     * @param importId            id of the import
     * @throws ImportException if any errors are encountered during processing
     */
    @Override
    public String process(final byte[] accessibilityConfig, final long importId) throws ImportException {

        final Document doc = parseDoc(accessibilityConfig);

        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper(errorCollector);
        final List<Accommodation> accommodations = newArrayList();

        for (final Node accNode : nodes(doc, xpathAccSelections)) {
            final String code = parserHelper.validate("Accommodation code", text(accNode, xpathCode), 25, true);

            final Accommodation.Builder builder = Accommodation.builder().code(code);
            for (final Node textNode : nodes(accNode, xpathText)) {
                final String langCode = parserHelper.validate(code + " language code", text(textNode, xpathLanguage), 3, true);
                final String label = parserHelper.validate("Translation", text(textNode, xpathLabel), 40, true);
                builder.addTranslation(langCode, label);

                logger.debug(code + " = [" + langCode + "] " + label);
            }
            accommodations.add(builder.build());
        }

        //If there are errors in the container, don't insert anything into the database, just bail out
        if (!errorCollector.isEmpty()) {
            throw new ImportException(BAD_DATA, errorCollector.toJson());
        }

        //Insert into database
        translationRepository.upsert(accommodations);

        final String msg = accommodations.size() + " accommodations processed";
        logger.info(msg);
        return msg;
    }

    private Document parseDoc(final byte[] accessibilityConfig) throws ImportException {
        try {
            final SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
            final Schema schema = schemaFactory.newSchema(this.getClass().getResource("/AccessibilityConfig.xsd"));

            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            dbf.setSchema(schema);

            final DocumentBuilder builder = dbf.newDocumentBuilder();
            builder.setErrorHandler(new ErrorHandler() {
                public void warning(final SAXParseException e) throws SAXException {
                    logger.info(e.getMessage());
                }

                public void error(final SAXParseException e) throws SAXException {
                    throw e;
                }

                public void fatalError(final SAXParseException e) throws SAXException {
                    throw e;
                }
            });

            return builder.parse(new ByteArrayInputStream(accessibilityConfig));

        } catch (final ParserConfigurationException | SAXException | IOException e) {
            throw new ImportException(BAD_DATA, e.toString());
        }
    }

    /**
     * Return an iterable for the node list resulting from applying the xpath expression to the item.
     * Exceptions are caught and result in an empty iterator.
     *
     * @param item  parent item
     * @param xpath xpath expression
     * @return iterable over node, may be empty, won't be null
     */
    private static Iterable<Node> nodes(final Object item, final XPathExpression xpath) {
        final NodeList nodeList = nodeListOrNull(item, xpath);
        return () -> new Iterator<Node>() {
            int index = 0;

            @Override
            public boolean hasNext() {
                return nodeList != null && index < nodeList.getLength();
            }

            @Override
            public Node next() {
                if (!hasNext()) throw new NoSuchElementException();
                return nodeList.item(index++);
            }
        };
    }

    private static NodeList nodeListOrNull(final Object item, final XPathExpression xpath) {
        try {
            return (NodeList) xpath.evaluate(item, XPathConstants.NODESET);
        } catch (final IllegalArgumentException | NullPointerException | XPathExpressionException e) {
            return null;
        }
    }

    /**
     * Return the text content for the node resulting from applying the xpath expression to the item.
     * Exceptions are caught and result in an empty string.
     *
     * @param item  parent item
     * @param xpath xpath expression
     * @return string, may be empty, won't be null
     */
    private static String text(final Object item, final XPathExpression xpath) {
        try {
            return ((Node) xpath.evaluate(item, XPathConstants.NODE)).getTextContent().trim();
        } catch (final IllegalArgumentException | NullPointerException | XPathExpressionException e) {
            return "";
        }
    }
}
