package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Accommodation;
import org.opentestsystem.rdw.ingest.processor.repository.AccommodationTranslationRepository;
import org.opentestsystem.rdw.ingest.processor.repository.LanguageRepository;
import org.opentestsystem.rdw.ingest.processor.service.AccommodationsProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.checkNotBlank;

/**
 * DefaultAccessibilityProcessor
 */
@Service
public class DefaultAccommodationsProcessor implements AccommodationsProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAccommodationsProcessor.class);

    private final AccommodationTranslationRepository translationRepository;
    private final LanguageRepository languageRepository;

    private XPathExpression xpathAccSelections;
    private XPathExpression xpathCode;
    private XPathExpression xpathText;
    private XPathExpression xpathLanguage;
    private XPathExpression xpathLabel;

    @Autowired
    public DefaultAccommodationsProcessor(final AccommodationTranslationRepository translationRepository,
                                          final LanguageRepository languageRepository) {
        this.translationRepository = translationRepository;
        this.languageRepository = languageRepository;

        // compile the xpath expressions so we fast-fail for any coding errors
        final XPath xpath = XPathFactory.newInstance().newXPath();
        try {
            xpathAccSelections = xpath.compile("/Accessibility/MasterResourceFamily/*[starts-with(ResourceType,'Accom')]/Selection");
            xpathCode = xpath.compile("Code");
            xpathText = xpath.compile("Text");
            xpathLanguage = xpath.compile("Language");
            xpathLabel = xpath.compile("Label");
        } catch (final XPathExpressionException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Processes an Accessibility Config File in xml format for accommodation codes and their
     * translations and inserts the codes and translations in to the data warehouse.
     * <p>
     * Implementation note: javax.xml has a terrible interface so there are some helpers that
     * try to hide that ugliness and make the main code look a little more like java 8.
     * </p>
     *
     * @param accessibilityConfig An Accessibility Config File as referenced at https://github.com/SmarterApp/AccessibilityAccommodationConfigurations
     * @throws ImportException if any errors are encountered during processing
     */
    @Override
    public void process(final byte[] accessibilityConfig) throws ImportException {

        final Document doc = parseDoc(accessibilityConfig);

        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper(errorCollector);
        final List<Accommodation> accommodations = newArrayList();

        for (final Node accNode : nodes(doc, xpathAccSelections)) {
            final String code = parserHelper.validate("Accommodation code", text(accNode, xpathCode), 25, true);

            for (final Node textNode : nodes(accNode, xpathText)) {
                final String lang = text(textNode, xpathLanguage);
                final Integer langId = parserHelper.validate(code + " language code", lang, checkNotBlank.andThen(languageRepository::findIdByCode).andThen(new CheckNotNull<>()));
                final String label = parserHelper.validate("Translation", text(textNode, xpathLabel), 40, true);
                accommodations.add(Accommodation.builder()
                        .code(code)
                        .addTranslation(langId, label)
                        .build());
                logger.debug(code + " = [" + lang + "] " + label);
            }
        }

        //If there are errors in the container, don't insert anything into the database, just bail out
        if (!errorCollector.isEmpty()) {
            throw new ImportException(BAD_DATA, errorCollector.toJson());
        }

        //Insert into database
        translationRepository.create(accommodations);

        logger.info(String.format("Processed %d accommodation codes", accommodations.size()));
    }

    private Document parseDoc(final byte[] accessibilityConfig) throws ImportException {
        try {
            final SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
            final Schema schema = schemaFactory.newSchema(this.getClass().getResource("/AccessibilityConfig.xsd"));

            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            dbf.setSchema(schema);

            final DocumentBuilder builder = dbf.newDocumentBuilder();
            builder.setErrorHandler(new ErrorHandler() {
                public void warning(final SAXParseException e) throws SAXException {
                    logger.info(e.getMessage());
                }

                public void error(final SAXParseException e) throws SAXException {
                    throw e;
                }

                public void fatalError(final SAXParseException e) throws SAXException {
                    throw e;
                }
            });

            return builder.parse(new ByteArrayInputStream(accessibilityConfig));

        } catch (final ParserConfigurationException | SAXException | IOException e) {
            throw new ImportException(BAD_DATA, e.toString());
        }
    }

    /**
     * Return an iterable for the node list resulting from applying the xpath expression to the item.
     * Exceptions are caught and result in an empty iterator.
     *
     * @param item  parent item
     * @param xpath xpath expression
     * @return iterable over node, may be empty, won't be null
     */
    private static Iterable<Node> nodes(final Object item, final XPathExpression xpath) {
        final NodeList nodeList = nodeListOrNull(item, xpath);
        return () -> new Iterator<Node>() {
            int index = 0;

            @Override
            public boolean hasNext() {
                return nodeList != null && index < nodeList.getLength();
            }

            @Override
            public Node next() {
                if (!hasNext()) throw new NoSuchElementException();
                return nodeList.item(index++);
            }
        };
    }

    private static NodeList nodeListOrNull(final Object item, final XPathExpression xpath) {
        try {
            return (NodeList) xpath.evaluate(item, XPathConstants.NODESET);
        } catch (final IllegalArgumentException | NullPointerException | XPathExpressionException e) {
            return null;
        }
    }

    /**
     * Return the text content for the node resulting from applying the xpath expression to the item.
     * Exceptions are caught and result in an empty string.
     *
     * @param item  parent item
     * @param xpath xpath expression
     * @return string, may be empty, won't be null
     */
    private static String text(final Object item, final XPathExpression xpath) {
        try {
            return ((Node) xpath.evaluate(item, XPathConstants.NODE)).getTextContent().trim();
        } catch (final IllegalArgumentException | NullPointerException | XPathExpressionException e) {
            return "";
        }
    }
}
