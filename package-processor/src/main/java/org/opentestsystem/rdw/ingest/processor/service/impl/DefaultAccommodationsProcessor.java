package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.base.Strings;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Accommodation;
import org.opentestsystem.rdw.ingest.processor.repository.AccommodationTranslationRepository;
import org.opentestsystem.rdw.ingest.processor.repository.LanguageRepository;
import org.opentestsystem.rdw.ingest.processor.service.AccommodationsProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_FORMAT;

/**
 * DefaultAccessibilityProcessor
 */
@Service
public class DefaultAccommodationsProcessor implements AccommodationsProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAccommodationsProcessor.class);

    private final AccommodationTranslationRepository translationRepository;
    private final LanguageRepository languageRepository;

    @Autowired
    public DefaultAccommodationsProcessor(final AccommodationTranslationRepository translationRepository,
                                          final LanguageRepository languageRepository) {
        this.translationRepository = translationRepository;
        this.languageRepository = languageRepository;
    }

    /**
     * Processes an Accessibility Config File in xml format for accommodation codes and their translations and inserts
     * the codes and translations in to the data warehouse
     *
     * @param accessibilityConfig An Accessibility Config File as referenced at https://github.com/SmarterApp/AccessibilityAccommodationConfigurations
     * @throws ImportException if any errors are encountered during processing
     */
    @Override
    public void process(final byte[] accessibilityConfig) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper( errorCollector );
        List<Accommodation> accommodations = new ArrayList<>();

        try {
            validate(accessibilityConfig);

            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(new ByteArrayInputStream(accessibilityConfig));
            XPathFactory xPathfactory = XPathFactory.newInstance();
            XPath xpath = xPathfactory.newXPath();

            XPathExpression accessibilityGroup = xpath.compile("/Accessibility/MasterResourceFamily/*[starts-with(ResourceType,'Accom')]/Selection");
            XPathExpression accessibilityCode = xpath.compile("Code");
            XPathExpression accessibilityLanguageGroups = xpath.compile("Text");
            XPathExpression accessibilityLanguage = xpath.compile("Language");
            XPathExpression accessibilityLabel = xpath.compile("Label");
            NodeList accGroup = (NodeList) accessibilityGroup.evaluate(doc, XPathConstants.NODESET);

            for (int i =0; i< accGroup.getLength(); i++) {
                Node code = (Node) accessibilityCode.evaluate(accGroup.item(i), XPathConstants.NODE);
                NodeList langGroup = (NodeList) accessibilityLanguageGroups.evaluate(accGroup.item(i), XPathConstants.NODESET);
                for(int j = 0; j < langGroup.getLength(); j++) {
                    Node lang = (Node) accessibilityLanguage.evaluate(langGroup.item(j), XPathConstants.NODE);
                    Node label = (Node) accessibilityLabel.evaluate(langGroup.item(j), XPathConstants.NODE);
                    accommodations.add(Accommodation.builder()
                            .code(parserHelper.basicValidation("Accommodation code",
                                    code.getTextContent().trim(),
                                    Strings::emptyToNull))
                            .addTranslation(
                                    parserHelper.repositoryValidation(code.getTextContent() + " language code",
                                            lang.getTextContent().trim(),
                                            Strings::emptyToNull,
                                            languageRepository::findIdByCode),
                                    parserHelper.basicValidation("Translation",
                                            label.getTextContent().trim(),
                                            Strings::emptyToNull))
                            .build());
                    logger.debug(code.getTextContent() + " = [" + lang.getTextContent() + "] " + label.getTextContent());
                }
            }

            //If there are errors in the container, don't insert anything into the database, just bail out
            if (!errorCollector.isEmpty()) {
                throw new ImportException(BAD_DATA, errorCollector.toJson());
            }

            //Insert into database
            translationRepository.create(accommodations);

            logger.info(String.format("Processed %d accommodation codes", accommodations.size()));
        } catch (final IllegalArgumentException |
                javax.xml.xpath.XPathExpressionException |
                org.xml.sax.SAXException |
                javax.xml.parsers.ParserConfigurationException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        }
    }

    private void validate(final byte[] accessibilityConfig) throws IOException {
        Source xmlFile = new StreamSource(new InputStreamReader(new ByteArrayInputStream(accessibilityConfig), Charset.forName("utf8")));
        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);

        try {
            Schema schema = schemaFactory.newSchema(this.getClass().getResource("/AccessibilityConfig.xsd"));
            Validator validator = schema.newValidator();

            validator.validate(xmlFile);

       } catch (SAXException e) {
        throw new ImportException(BAD_DATA, "Accessibility Config File failed XSD validation");
       }
    }
}
