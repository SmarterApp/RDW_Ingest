package org.opentestsystem.rdw.ingest.processor;

import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.ingest.processor.service.StudentsProcessor;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.springframework.http.MediaType;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.GenericMessage;

import java.time.Instant;
import java.util.Optional;
import java.util.stream.Collectors;

import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.common.script.PipelineService;
import org.opentestsystem.rdw.ingest.common.script.PipelineType;
import org.opentestsystem.rdw.ingest.processor.service.AccommodationsProcessor;
import org.opentestsystem.rdw.ingest.processor.service.AssessmentPackageProcessor;
import org.opentestsystem.rdw.ingest.processor.service.NormsProcessor;
import org.opentestsystem.rdw.ingest.processor.service.OrganizationProcessor;
import org.opentestsystem.rdw.ingest.processor.service.SubjectProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScriptDefinition;
import org.opentestsystem.rdw.script.PipelineScriptType;
import org.opentestsystem.rdw.script.PropertyResolver;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.impl.DefaultPipelineFactory;
import org.opentestsystem.rdw.script.impl.EmptyPropertyResolver;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Collections.singletonList;
import static org.assertj.core.api.Assertions.fail;
import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.PipelineScriptType.Base;
import static org.opentestsystem.rdw.script.PipelineScriptType.Post;
import static org.opentestsystem.rdw.script.PipelineScriptType.Pre;

public class AssessmentTransformationTest {

    private PackageProcessor processor;
    private ImportRepository importRepository;
    private ArchiveService archiveService;
    private Message message;

    @Before
    public void createProcessor() throws Exception {
        // Set up a partially mocked pipeline that will still do the actual XML transformations.
        final Pipeline pipeline = setupPipeline();

        final PipelineService pipelineService = mock(PipelineService.class);
        when(pipelineService.getPipeline(PipelineType.Assessment.code())).thenReturn(Optional.of(pipeline));

        // no-op everything else since we're focusing on the transformation
        importRepository = mock(ImportRepository.class);
        archiveService = mock(ArchiveService.class);
        final AssessmentPackageProcessor packageProcessor = mock(AssessmentPackageProcessor.class);

        final AccommodationsProcessor accommodationsProcessor = mock(AccommodationsProcessor.class);
        final OrganizationProcessor organizationProcessor = mock(OrganizationProcessor.class);
        final NormsProcessor normsProcessor = mock(NormsProcessor.class);
        final SubjectProcessor subjectProcessor = mock(SubjectProcessor.class);
        final StudentsProcessor studentsProcessor = mock(StudentsProcessor.class);


        processor = new PackageProcessor(
                importRepository,
                packageProcessor,
                accommodationsProcessor,
                organizationProcessor,
                normsProcessor,
                subjectProcessor,
                studentsProcessor,
                archiveService,
                pipelineService);
    }

    @Before
    public void createMessage() throws Exception {
        // make a nice well-formed message
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(null);
        accessor.setContent(ImportContent.EXAM.name());
        accessor.setContentType(MediaType.APPLICATION_XML);
        accessor.setImportId(1);
        accessor.setTenantId("CA");

        final byte[] payload = loadStringFromResourceFile("/SampleAssessment-truncated.csv").getBytes(UTF_8);

        message = new GenericMessage<>(payload, accessor.getMessageHeaders());
    }

    private Pipeline setupPipeline() throws Exception {
        // use a mostly real factory to create a mostly real pipeline
        // published user script
        final PipelineScriptDefinition userScript = PipelineScriptDefinition.builder()
                .type(PipelineScriptType.User)
                .body(loadStringFromResourceFile("/scripts/user.1.groovy"))
                .version("1")
                .build();

        final PipelineScriptDefinition baseScript = PipelineScriptDefinition.builder()
                .type(Base)
                .body(loadStringFromResourceFile("/scripts/DSLScriptBase.groovy"))
                .build();

        final PipelineDefinition publishedPipeline = PipelineDefinition.builder()
                .pipelineCode("test")
                .published(Instant.now())
                .publishedBy("publisher")
                .version("1")
                .scripts(singletonList(userScript))
                .build();

        final ScriptSource scriptSource = mock(ScriptSource.class);
        when(scriptSource.getScript(eq(Base), anyString())).thenReturn(Optional.of(baseScript));
        when(scriptSource.getScript(eq(Pre), anyString())).thenReturn(Optional.empty());
        when(scriptSource.getScript(eq(Post), anyString())).thenReturn(Optional.empty());

        final PublishedPipelineRepository repository = mock(PublishedPipelineRepository.class);
        when(repository.findByCodeAndVersion(anyString(), anyString())).thenReturn(publishedPipeline);

        final PropertyResolver propertyResolver = new EmptyPropertyResolver();

        final PipelineFactory factory = new DefaultPipelineFactory(repository, propertyResolver, null, scriptSource);

        try {
            return factory.getPipeline(PipelineType.Assessment.code(), "1");
        } catch (final PipelineBuildException e) {
            fail(e.getErrors().values().stream().map(Exception::getMessage).collect(Collectors.joining("\n")));
            throw e;
        }
    }

    @Test
    public void itShouldProcessMessageWithCsvContent() {
        // this should also transform the payload; can check by debugging
        processor.processPackage(message);
        verify(archiveService).writeResource(anyString(), (byte [])any(), any());
        verify(importRepository, times(1)).updateStatusAndMessageById(1, ImportStatus.PROCESSED, null);
    }

    @Test
    public void itShouldPerformTransformationsOnAssessment() {
        final ArgumentCaptor<byte[]> captor = ArgumentCaptor.forClass(byte[].class);
        processor.processPackage(message);
        verify(archiveService).writeResource(anyString(), captor.capture(), any());

        final String transformed = new String(captor.getValue(), UTF_8);

        // Rows with assessment id containing DELETE_ME are deleted
        assertThat(transformed).doesNotContain("DELETE_ME");

        // very very very very long names are compressed
        assertThat(transformed).doesNotContain("very very very long name");
        assertThat(transformed).contains("Here is a very long name");

        // Change from interim to summative
        assertThat(transformed).doesNotContain("interim");
        assertThat(transformed).contains("summative");
    }

    private String loadStringFromResourceFile(final String name) throws Exception {
        return IOUtils.toString(this.getClass().getResourceAsStream(name), UTF_8);
    }
}
