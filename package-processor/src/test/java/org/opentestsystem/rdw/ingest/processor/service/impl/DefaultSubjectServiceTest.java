package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.ScoreType;
import org.opentestsystem.rdw.common.model.subject.AltScore;
import org.opentestsystem.rdw.common.model.subject.AltScoring;
import org.opentestsystem.rdw.common.model.subject.Claim;
import org.opentestsystem.rdw.common.model.subject.ClaimScoring;
import org.opentestsystem.rdw.common.model.subject.OverallScoring;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevels;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentScoring;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectScore;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectAssessmentTypeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectScoreRepository;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyCollection;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.ScoreType.ALT;
import static org.opentestsystem.rdw.common.model.ScoreType.CLAIM;
import static org.opentestsystem.rdw.ingest.processor.service.impl.DefaultSubjectService.cross;

@RunWith(MockitoJUnitRunner.class)
public class DefaultSubjectServiceTest {
    private static final String SubjectCode = "test_sub";

    @Mock
    private SubjectRepository subjectRepository;
    @Mock
    private SubjectAssessmentTypeRepository subjectAssessmentTypeRepository;
    @Mock
    private SubjectScoreRepository subjectScoreRepository;
    private DefaultSubjectService service;

    @Before
    public void setup() {
        service = new DefaultSubjectService(subjectRepository, subjectAssessmentTypeRepository, subjectScoreRepository);
    }

    @Test
    public void itShouldCreateASubject() {
        final long importId = 123L;
        final int subjectId = 42;
        when(subjectRepository.findIdByCode(eq(SubjectCode))).thenReturn(null);
        when(subjectRepository.create(SubjectCode, importId)).thenReturn(subjectId);

        final Subject subject = subject().build();

        service.upsert(subject, importId);
        verify(subjectRepository).create(SubjectCode, importId);

        final ArgumentCaptor<WarehouseSubjectAssessmentType> typeCaptor =
                ArgumentCaptor.forClass(WarehouseSubjectAssessmentType.class);
        verify(subjectAssessmentTypeRepository, times(3)).create(eq(subjectId), typeCaptor.capture());
        final Map<AssessmentType, WarehouseSubjectAssessmentType> types = typeCaptor.getAllValues().stream()
                .collect(Collectors.toMap(WarehouseSubjectAssessmentType::getAssessmentType, type -> type));
        final WarehouseSubjectAssessmentType ica = types.get(ICA);
        assertThat(ica.getScoring(ScoreType.OVERALL).getPerformanceLevelCount()).isEqualTo(4);
        assertThat(ica.getScoring(ScoreType.OVERALL).getPerformanceLevelStandardCutoff()).isEqualTo(3);
        assertThat(ica.getScoring(ALT)).isNull();
        assertThat(ica.getScoring(ScoreType.CLAIM).getPerformanceLevelCount()).isEqualTo(4);

        final WarehouseSubjectAssessmentType iab = types.get(AssessmentType.IAB);
        assertThat(iab.getScoring(ScoreType.OVERALL).getPerformanceLevelCount()).isEqualTo(3);
        assertThat(iab.getScoring(ScoreType.OVERALL).getPerformanceLevelStandardCutoff()).isNull();
        assertThat(iab.getScoring(ALT)).isNull();
        assertThat(iab.getScoring(ScoreType.CLAIM)).isNull();

        final WarehouseSubjectAssessmentType sum = types.get(SUMMATIVE);
        assertThat(sum.getScoring(ScoreType.OVERALL).getPerformanceLevelCount()).isEqualTo(4);
        assertThat(sum.getScoring(ScoreType.OVERALL).getPerformanceLevelStandardCutoff()).isEqualTo(3);
        assertThat(sum.getScoring(ALT).getPerformanceLevelCount()).isEqualTo(1);
        assertThat(sum.getScoring(ScoreType.CLAIM).getPerformanceLevelCount()).isEqualTo(3);

        // ICA/SUMMATIVE have CLAIM scoring, and there are 2 claims = 4 subject scores
        // SUMMATIVE has ALT scoring, and there is 1 alt score = 1 subject score
        final ArgumentCaptor<List<WarehouseSubjectScore>> scoresCaptor = ArgumentCaptor.forClass(List.class);
        verify(subjectScoreRepository).create(eq(subjectId), scoresCaptor.capture());
        final List<WarehouseSubjectScore> scores = scoresCaptor.getValue();
        assertThat(scores).hasSize(5);
        assertThat(scores.stream().filter(s -> s.getAssessmentType() == ICA)).hasSize(2);
        assertThat(scores.stream().filter(s -> s.getAssessmentType() == SUMMATIVE)).hasSize(3);
        assertThat(scores.stream().filter(s -> s.getScoreType() == ScoreType.CLAIM)).hasSize(4);
        assertThat(scores.stream().filter(s -> s.getScoreType() == ALT)).hasSize(1);
    }

    @Test
    public void itShouldUpdateASubject() {
        final int subjectId = 1;
        when(subjectRepository.findIdByCode(eq(SubjectCode))).thenReturn(subjectId);

        final List<WarehouseSubjectAssessmentType> existingTypes = ImmutableList.of(
                warehouseType(ICA, 4, 3).build(),
                warehouseType(AssessmentType.IAB, 3, 0).build(),
                warehouseType(SUMMATIVE, 4, 3).build()
        );
        when(subjectAssessmentTypeRepository.findBySubjectId(subjectId)).thenReturn(existingTypes);

        // for existing, have a couple extra scores (claim_c, pass_fail) and change data order on alt_score
        final List<WarehouseSubjectScore> existingScores = ImmutableList.of(
                WarehouseSubjectScore.builder().id(1).code("claim_a").assessmentType(ICA).scoreType(CLAIM).displayOrder(1).dataOrder(1).build(),
                WarehouseSubjectScore.builder().id(2).code("claim_b").assessmentType(ICA).scoreType(CLAIM).displayOrder(2).dataOrder(2).build(),
                WarehouseSubjectScore.builder().id(3).code("claim_a").assessmentType(SUMMATIVE).scoreType(CLAIM).displayOrder(1).dataOrder(1).build(),
                WarehouseSubjectScore.builder().id(4).code("claim_b").assessmentType(SUMMATIVE).scoreType(CLAIM).displayOrder(2).dataOrder(2).build(),
                WarehouseSubjectScore.builder().id(5).code("claim_c").assessmentType(SUMMATIVE).scoreType(CLAIM).displayOrder(3).dataOrder(3).build(),
                WarehouseSubjectScore.builder().id(6).code("alt_score").assessmentType(SUMMATIVE).scoreType(ALT).displayOrder(2).dataOrder(2).build(),
                WarehouseSubjectScore.builder().id(7).code("pass_fail").assessmentType(SUMMATIVE).scoreType(ALT).displayOrder(1).dataOrder(1).build()
        );
        when(subjectScoreRepository.findBySubjectId(subjectId)).thenReturn(existingScores);
        when(subjectScoreRepository.isReferenced(anyCollection())).thenReturn(null);

        // update ica, delete iab, leave sum unchanged
        final Subject subject = subject()
                .assessmentTypes(ImmutableList.of(
                        assessmentType(ICA, 5, 5).build(),
                        assessmentType(SUMMATIVE, 4, 3).build()
                ))
                .build();

        service.upsert(subject, 123L);
        verify(subjectRepository).update(SubjectCode, 123L);

        final ArgumentCaptor<AssessmentType> typeCaptor = ArgumentCaptor.forClass(AssessmentType.class);
        verify(subjectAssessmentTypeRepository, times(2)).isReferenced(eq(subjectId), typeCaptor.capture());
        assertThat(typeCaptor.getAllValues().stream())
                .containsOnly(ICA, AssessmentType.IAB);
        final ArgumentCaptor<WarehouseSubjectAssessmentType> asmtTypeCaptor = ArgumentCaptor.forClass(WarehouseSubjectAssessmentType.class);
        verify(subjectAssessmentTypeRepository).update(eq(subjectId), asmtTypeCaptor.capture());
        assertThat(asmtTypeCaptor.getValue().getAssessmentType()).isEqualTo(ICA);
        verify(subjectAssessmentTypeRepository).delete(subjectId, AssessmentType.IAB);

        final ArgumentCaptor<List<Integer>> idsCaptor = ArgumentCaptor.forClass(List.class);
        verify(subjectScoreRepository).delete(idsCaptor.capture());
        assertThat(idsCaptor.getValue()).containsExactlyInAnyOrder(5, 7);
        final ArgumentCaptor<List<WarehouseSubjectScore>> scoresCaptor = ArgumentCaptor.forClass(List.class);
        verify(subjectScoreRepository).update(scoresCaptor.capture());
        final List<WarehouseSubjectScore> updated = scoresCaptor.getValue();
        assertThat(updated).hasSize(1);
        assertThat(updated.get(0).getId()).isEqualTo(6);
        assertThat(updated.get(0).getDataOrder()).isEqualTo(1);
        verify(subjectScoreRepository, never()).create(eq(subjectId), anyCollection());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotAllowRemovingATypeWithExams() {
        final int subjectId = 1;
        final List<WarehouseSubjectAssessmentType> existingTypes = ImmutableList.of(
                warehouseType(ICA, 4, 3).build()
        );
        when(subjectAssessmentTypeRepository.findBySubjectId(subjectId)).thenReturn(existingTypes);
        when(subjectAssessmentTypeRepository.isReferenced(subjectId, ICA)).thenReturn(true);

        final Subject updated = subject()
                .assessmentTypes(ImmutableList.of())
                .build();

        service.updateSubjectAssessmentTypes(subjectId, updated);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotAllowUpdatingPerformanceLevelCountsForATypeWithExams() {
        final int subjectId = 1;
        final List<WarehouseSubjectAssessmentType> existingTypes = ImmutableList.of(
                warehouseType(ICA, 4, 3).build()
        );
        when(subjectAssessmentTypeRepository.findBySubjectId(subjectId)).thenReturn(existingTypes);
        when(subjectAssessmentTypeRepository.isReferenced(subjectId, ICA)).thenReturn(true);

        final Subject updated = subject()
                .assessmentTypes(ImmutableList.of(
                        assessmentType(ICA, 5, 5).build()
                ))
                .build();

        service.updateSubjectAssessmentTypes(subjectId, updated);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotAllowUpdatingClaimScorePerformanceLevelCountsForATypeWithExams() {
        final int subjectId = 1;
        final List<WarehouseSubjectAssessmentType> existingTypes = ImmutableList.of(
                warehouseType(ICA, 4, 3).build()
        );
        when(subjectAssessmentTypeRepository.findBySubjectId(subjectId)).thenReturn(existingTypes);
        when(subjectAssessmentTypeRepository.isReferenced(subjectId, ICA)).thenReturn(true);

        final Subject updated = subject()
                .assessmentTypes(ImmutableList.of(
                        assessmentType(ICA, 4, 5).build()
                ))
                .build();

        service.updateSubjectAssessmentTypes(subjectId, updated);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotUpdateDataOrderForReferencedSubjectScores() {
        final int subjectId = 1;

        // simple subject to make this easy
        final Subject subject = Subject.builder()
                .code(SubjectCode)
                .assessmentTypes(ImmutableList.of(assessmentType(SUMMATIVE, 4, 0).build()))
                .altScores(ImmutableList.of(
                        AltScore.builder().code("alt1").displayOrder(1).dataOrder(1).build(),
                        AltScore.builder().code("alt2").displayOrder(2).dataOrder(2).build()
                ))
                .build();
        // the existing score needs a different data order
        final List<WarehouseSubjectScore> existingScores = ImmutableList.of(
            WarehouseSubjectScore.builder().id(1).code("alt1").assessmentType(SUMMATIVE).scoreType(ALT).displayOrder(1).dataOrder(2).build(),
            WarehouseSubjectScore.builder().id(2).code("alt2").assessmentType(SUMMATIVE).scoreType(ALT).displayOrder(2).dataOrder(1).build()
        );
        when(subjectScoreRepository.findBySubjectId(subjectId)).thenReturn(existingScores);
        when(subjectScoreRepository.isReferenced(eq(newArrayList(1, 2)))).thenReturn(1);

        service.updateSubjectScores(subjectId, subject);
        verify(subjectScoreRepository, never()).delete(anyCollection());
        verify(subjectScoreRepository, never()).update(anyCollection());
        verify(subjectScoreRepository, never()).create(any(), anyCollection());
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotDeleteReferencedSubjectScores() {
        final int subjectId = 1;

        // simple subject to make this easy
        final Subject subject = Subject.builder()
                .code(SubjectCode)
                .assessmentTypes(ImmutableList.of(assessmentType(SUMMATIVE, 4, 0).build()))
                .altScores(ImmutableList.of(
                        AltScore.builder().code("alt1").displayOrder(1).dataOrder(1).build()
                ))
                .build();
        // need an extra existing score
        final List<WarehouseSubjectScore> existingScores = ImmutableList.of(
                WarehouseSubjectScore.builder().id(1).code("alt1").assessmentType(SUMMATIVE).scoreType(ALT).displayOrder(1).dataOrder(1).build(),
                WarehouseSubjectScore.builder().id(2).code("alt2").assessmentType(SUMMATIVE).scoreType(ALT).displayOrder(2).dataOrder(2).build()
        );
        when(subjectScoreRepository.findBySubjectId(subjectId)).thenReturn(existingScores);
        when(subjectScoreRepository.isReferenced(eq(newArrayList(2)))).thenReturn(2);

        service.updateSubjectScores(subjectId, subject);
        verify(subjectScoreRepository, never()).delete(anyCollection());
        verify(subjectScoreRepository, never()).update(anyCollection());
        verify(subjectScoreRepository, never()).create(any(), anyCollection());
    }

    @Test
    public void itShouldCrossStreamsAndThatIsNotBad() {
        assertThat(cross(IntStream.of(2, 4, 6).boxed(), IntStream.of(5, 7).boxed(), (a, b) -> a * b))
                .containsExactly(10, 14, 20, 28, 30, 42);

        assertThat(cross(Stream.builder().add("ica").add("sum").build(),
                         Stream.builder().add("alt1").add("alt2").add("alt3").build(),
                         (s, s2) -> s + "-" + s2))
                .containsExactly("ica-alt1", "ica-alt2", "ica-alt3", "sum-alt1", "sum-alt2", "sum-alt3");
    }


    private Subject.Builder subject() {
        return Subject.builder()
                .code(SubjectCode)
                .assessmentTypes(ImmutableList.of(
                    assessmentType(ICA, 4, 4).build(),
                    assessmentType(AssessmentType.IAB, 3, 0).build(),
                    assessmentType(SUMMATIVE, 4, 3).build()
                ))
                .claims(ImmutableList.of(
                    Claim.builder().code("claim_a").displayOrder(1).dataOrder(1).build(),
                    Claim.builder().code("claim_b").displayOrder(2).dataOrder(2).build()
                ))
                .altScores(ImmutableList.of(
                    AltScore.builder().code("alt_score").displayOrder(1).dataOrder(1).build()
                ))
        ;
    }

    private SubjectAssessmentType.Builder assessmentType(final AssessmentType type,
                                                         final int perfLevels,
                                                         final int subPerfLevels) {
        final List<PerformanceLevel> levels = newArrayList();
        for (int i = 1; i <= perfLevels; i++) {
            levels.add(performanceLevel(i));
        }

        final List<PerformanceLevel> claimScoreLevels = newArrayList();
        for (int i = 1; i <= subPerfLevels; i++) {
            claimScoreLevels.add(performanceLevel(i));
        }

        return SubjectAssessmentType.builder()
                .type(type)
                .targetReport(type == SUMMATIVE)
                .traitReport(type == SUMMATIVE)
                .overallScoring(OverallScoring.builder()
                        .performanceLevels(PerformanceLevels.builder()
                                .performanceLevels(levels)
                                .standardCutoff(perfLevels > 3 ? 3 : null)
                                .build())
                        .build())
                .altScoring(type != SUMMATIVE ? null : AltScoring.builder()
                        .name("PassFail")
                        .performanceLevels(PerformanceLevels.builder()
                                .performanceLevels(ImmutableList.of(performanceLevel(1)))
                                .build())
                        .build())
                .claimScoring(claimScoreLevels.isEmpty() ? null : ClaimScoring.builder()
                        .performanceLevels(PerformanceLevels.builder()
                                .performanceLevels(claimScoreLevels)
                                .standardCutoff(claimScoreLevels.size() > 3 ? 3 : null)
                                .build())
                        .build());
    }

    private PerformanceLevel performanceLevel(final int level) {
        return PerformanceLevel.builder()
                .level(level)
                .build();
    }

    private WarehouseSubjectAssessmentType.Builder warehouseType(final AssessmentType type,
                                                                 final int perfLevels,
                                                                 final int subPerfLevels) {
        final WarehouseSubjectAssessmentType.Builder builder = WarehouseSubjectAssessmentType.builder()
                .assessmentType(type)
                .printedReport(true)
                .targetReport(type == SUMMATIVE)
                .traitReport(type == SUMMATIVE);
        if (perfLevels > 0) {
            builder.scoring(WarehouseSubjectAssessmentScoring.builder()
                    .type(ScoreType.OVERALL)
                    .performanceLevelCount(perfLevels)
                    .performanceLevelCutoff(perfLevels > 3 ? 3 : null)
                    .build());
        }
        if (subPerfLevels > 0) {
            builder.scoring(WarehouseSubjectAssessmentScoring.builder()
                    .type(ScoreType.CLAIM)
                    .performanceLevelCount(subPerfLevels)
                    .build());
        }
        // intentionally do this out of order to test equals/hash behavior
        if (type == SUMMATIVE) {
            builder.scoring(WarehouseSubjectAssessmentScoring.builder()
                    .type(ALT)
                    .performanceLevelCount(1)
                    .build());
        }
        return builder;
    }
}
