package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.subject.Claim;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.Target;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseTarget;
import org.opentestsystem.rdw.ingest.processor.repository.TargetRepository;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class DefaultSubjectTargetServiceTest {
    private static final String SubjectCode = "sub";

    @Mock
    private TargetRepository repository;

    @Captor
    private ArgumentCaptor<Collection<WarehouseTarget>> targetCaptor;

    @Captor
    private ArgumentCaptor<Collection<Integer>> targetIdCaptor;

    private DefaultSubjectTargetService service;
    private AtomicInteger targetIdx;

    @Before
    public void setup() {
        when(repository.isReferenced(any())).thenReturn(null);
        service = new DefaultSubjectTargetService(repository);
        targetIdx = new AtomicInteger(1);
    }

    @Test
    public void itShouldInsertNewTargets() {
        final Subject subject = subject().build();
        service.upsert(subject);

        verify(repository).create(eq(SubjectCode), targetCaptor.capture());

        assertThat(targetCaptor.getValue().stream().map(WarehouseTarget::getNaturalId))
                .containsOnly("claim_a_0", "claim_a_1", "claim_a_2", "claim_b_0", "claim_b_1");
    }

    @Test
    public void itShouldRemoveStaleTargets() {
        final List<WarehouseTarget> existing = ImmutableList.<WarehouseTarget>builder()
                .addAll(warehouseTargets("claim_a", 3))
                .addAll(warehouseTargets("claim_b", 2))
                .build();
        when(repository.findBySubject(SubjectCode)).thenReturn(existing);

        service.upsert(subject()
                .claims(ImmutableList.of(
                        claim("claim_a", 2).build(),
                        claim("claim_b", 2).build()
                ))
                .build());
        verify(repository, never()).create(any(), any());
        verify(repository).delete(targetIdCaptor.capture());
        final WarehouseTarget deleted = existing.stream()
                .filter(target -> targetIdCaptor.getValue().contains(target.getId()))
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Cannot find deleted target"));
        assertThat(deleted.getClaimCode()).isEqualTo("claim_a");
        assertThat(deleted.getNaturalId()).isEqualTo("claim_a_2");
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotRemoveStaleTargetsWithReferences() {
        final List<WarehouseTarget> existing = ImmutableList.<WarehouseTarget>builder()
                .addAll(warehouseTargets("claim_a", 3))
                .addAll(warehouseTargets("claim_b", 2))
                .build();
        when(repository.findBySubject(SubjectCode)).thenReturn(existing);
        when(repository.isReferenced(any())).thenAnswer(invocation -> {
            final Collection<Integer> ids = invocation.getArgument(0);
            return Iterables.getFirst(ids, null);
        });

        service.upsert(subject()
                .claims(ImmutableList.of(
                        claim("claim_a", 2).build(),
                        claim("claim_b", 2).build()
                ))
                .build());
    }

    private Subject.Builder subject() {
        return Subject.builder()
                .code(SubjectCode)
                .claims(ImmutableList.of(
                        claim("claim_a", 3).build(),
                        claim("claim_b", 2).build(),
                        claim("claim_c", 0).organizational(false).build()
                ));
    }

    private Claim.Builder claim(final String code, final int targetCount) {
        final Claim.Builder builder = Claim.builder()
                .code(code);
        if (targetCount == 0) return builder;

        final List<Target> targets = newArrayList();
        for (int i = 0; i < targetCount; i++) {
            targets.add(Target.builder().code(code + "_" + i).build());
        }
        builder.targets(targets);
        return builder;
    }

    private Collection<WarehouseTarget> warehouseTargets(final String claimCode, final int targetCount) {
        final List<WarehouseTarget> targets = newArrayList();
        for (int i = 0; i < targetCount; i++) {
            targets.add(WarehouseTarget.builder()
                    .id(targetIdx.getAndIncrement())
                    .claimCode(claimCode)
                    .naturalId(claimCode + "_" + i)
                    .build());
        }
        return targets;
    }
}
