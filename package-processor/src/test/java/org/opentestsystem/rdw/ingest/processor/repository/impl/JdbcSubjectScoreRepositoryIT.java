package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.ImmutableList;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.ingest.common.test.CachingTest;
import org.opentestsystem.rdw.ingest.processor.configuration.DataSourceConfiguration;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectScore;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectScoreRepository;
import org.opentestsystem.rdw.utils.YamlPropertiesConfigurator;

import static com.google.common.collect.ImmutableMultiset.of;
import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.data.MapEntry.entry;
import static org.opentestsystem.rdw.common.model.AssessmentType.ICA;
import static org.opentestsystem.rdw.common.model.AssessmentType.SUMMATIVE;
import static org.opentestsystem.rdw.common.model.ScoreType.ALT;
import static org.opentestsystem.rdw.common.model.ScoreType.CLAIM;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = {
        JdbcSubjectScoreRepository.class,
        DataSourceConfiguration.class,
        YamlPropertiesConfigurator.class
})
@Transactional
@CachingTest
@ActiveProfiles("test")
@Sql(statements = {
        "INSERT INTO subject (id, code, import_id, update_import_id) VALUES (-99, 'test1', 1, 1), (-88, 'test2', 1, 1);",
        "INSERT INTO subject_score (id, subject_id, asmt_type_id, score_type_id, code, display_order, data_order) VALUES (-1, -99, 1, 3, 'claim_a', 1, 2), (-2, -99, 1, 3, 'claim_b', 2, 1);",
        "INSERT INTO subject_score (id, subject_id, asmt_type_id, score_type_id, code, display_order, data_order) VALUES (-3, -99, 1, 2, 'alt_1', 1, 1);"
})
public class JdbcSubjectScoreRepositoryIT {

    @Autowired
    private SubjectScoreRepository repository;

    @Test
    public void itShouldFindAllForASubject() {
        assertThat(repository.findBySubjectId(-99))
                .usingRecursiveFieldByFieldElementComparator()
                .containsOnly(
                        WarehouseSubjectScore.builder().id(-1).scoreType(CLAIM).code("claim_a").assessmentType(ICA).displayOrder(1).dataOrder(2).build(),
                        WarehouseSubjectScore.builder().id(-2).scoreType(CLAIM).code("claim_b").assessmentType(ICA).displayOrder(2).dataOrder(1).build(),
                        WarehouseSubjectScore.builder().id(-3).scoreType(ALT).code("alt_1").assessmentType(ICA).displayOrder(1).dataOrder(1).build()
                );
        assertThat(repository.findBySubjectId(-88)).isEmpty();
    }

    @Test
    public void itShouldFindAllBySubjectAndAsmtTypeAndScoreType() {
        assertThat(repository.findBySubjectIdAndAsmtTypeIdAndScoreTypeId(-99, 1, 3).stream().map(WarehouseSubjectScore::getId))
                .containsExactlyInAnyOrder(-1, -2);
        assertThat(repository.findBySubjectIdAndAsmtTypeIdAndScoreTypeId(-99, 1, 2).stream().map(WarehouseSubjectScore::getId))
                .containsExactlyInAnyOrder(-3);
        // OVERALL will always be empty
        assertThat(repository.findBySubjectIdAndAsmtTypeIdAndScoreTypeId(-99, 1, 1).stream().map(WarehouseSubjectScore::getId))
                .isEmpty();
        // of course, empty subject will be empty
        assertThat(repository.findBySubjectIdAndAsmtTypeIdAndScoreTypeId(-88, 1, 2).stream().map(WarehouseSubjectScore::getId))
                .isEmpty();
    }

    @Test
    public void itShouldCreateClaims() {
        final List<WarehouseSubjectScore> claims = newArrayList();
        claims.add(WarehouseSubjectScore.builder().scoreType(CLAIM).code("claim_1").assessmentType(ICA).displayOrder(1).dataOrder(2).build());
        claims.add(WarehouseSubjectScore.builder().scoreType(CLAIM).code("claim_2").assessmentType(ICA).displayOrder(2).dataOrder(1).build());
        claims.add(WarehouseSubjectScore.builder().scoreType(CLAIM).code("claim_1").assessmentType(SUMMATIVE).displayOrder(1).dataOrder(2).build());
        claims.add(WarehouseSubjectScore.builder().scoreType(CLAIM).code("claim_2").assessmentType(SUMMATIVE).displayOrder(2).dataOrder(1).build());
        repository.create(-88, claims);

        assertThat(repository.findBySubjectId(-88).stream()
                .map(claim -> claim.getCode() + claim.getAssessmentType().code()))
                .containsOnly("claim_1ica", "claim_2ica", "claim_1sum", "claim_2sum");
    }

    @Test
    public void itShouldUpdateClaimDisplayOrderAndDataOrder() {
        final List<WarehouseSubjectScore> updatedClaims = newArrayList();
        updatedClaims.add(WarehouseSubjectScore.builder().id(-1).scoreType(CLAIM).code("claim_a").assessmentType(ICA).displayOrder(4).dataOrder(1).build());
        updatedClaims.add(WarehouseSubjectScore.builder().id(-2).scoreType(CLAIM).code("claim_b").assessmentType(ICA).displayOrder(5).dataOrder(2).build());
        repository.update(updatedClaims);

        final List<WarehouseSubjectScore> updated = repository.findBySubjectId(-99).stream()
                .filter(s -> s.getId() == -1 || s.getId() == -2).collect(Collectors.toList());
        assertThat(updated.stream()
                .map(WarehouseSubjectScore::getDisplayOrder))
                .containsOnly(4, 5);
        assertThat(updated.stream()
                .collect(Collectors.toMap(WarehouseSubjectScore::getId, WarehouseSubjectScore::getDataOrder))
                .entrySet())
                .containsOnly(entry(-1, 1), entry(-2, 2));
    }

    @Test
    public void itShouldDeleteClaims() {
        repository.delete(ImmutableList.of(-1, -2, -3));
        assertThat(repository.findBySubjectId(-99)).isEmpty();
    }

    @Test
    @Sql(scripts = "/PreloadAsmt.sql",
         statements = {
             "INSERT INTO subject (id, code, import_id, update_import_id) VALUES (-99, 'test1', 1, 1), (-88, 'test2', 1, 1);",
             "INSERT INTO subject_score (id, subject_id, asmt_type_id, score_type_id, code, display_order, data_order) VALUES (-1, -99, 1, 3, 'claim_a', 1, 2), (-2, -99, 1, 3, 'claim_b', 2, 1);"
         }
    )
    public void itShouldDetermineIfClaimsHaveAssessments() {
        assertThat(repository.isReferenced(of(-1, -2))).isNull();

        final Set<Integer> elaClaimIds = repository.findBySubjectId(2).stream()
                .map(WarehouseSubjectScore::getId)
                .collect(Collectors.toSet());
        assertThat(repository.isReferenced(elaClaimIds)).isNotNull();
    }
}
