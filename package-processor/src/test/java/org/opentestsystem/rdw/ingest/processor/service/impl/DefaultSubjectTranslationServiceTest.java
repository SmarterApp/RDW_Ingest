package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.subject.ClaimScoring;
import org.opentestsystem.rdw.common.model.subject.DepthOfKnowledge;
import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevels;
import org.opentestsystem.rdw.common.model.subject.ReportAssessmentType;
import org.opentestsystem.rdw.common.model.subject.ReportClaim;
import org.opentestsystem.rdw.common.model.subject.ReportGrade;
import org.opentestsystem.rdw.common.model.subject.ReportPerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.Standard;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.common.model.subject.SubjectMessage;
import org.opentestsystem.rdw.common.model.subject.Target;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectTranslationRepository;

import java.util.Collection;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Maps.newHashMap;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.entry;
import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class DefaultSubjectTranslationServiceTest {
    private static final String SubjectCode = "mysub";

    @Mock
    private SubjectTranslationRepository repository;

    @Captor
    private ArgumentCaptor<Map<String, String>> messageCaptor;

    @Captor
    private ArgumentCaptor<Collection<String>> messageKeyCaptor;

    private DefaultSubjectTranslationService service;

    @Before
    public void setup() {
        service = new DefaultSubjectTranslationService(repository);
    }

    @Test
    public void itShouldCreateNewMessages() {
        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(entry("subject.mysub.name", "mysub name"));
    }

    @Test
    public void itShouldUpdateExistingMessages() {
        final Map<String, String> existing = newHashMap();
        existing.put("subject.mysub.name", "old name");
        when(repository.findBySubject(SubjectCode)).thenReturn(existing);

        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).doesNotContain(entry("subject.mysub.name", "mysub name"));

        verify(repository).update(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(entry("subject.mysub.name", "mysub name"));
    }

    @Test
    public void itShouldRemoveStaleMessages() {
        final Map<String, String> existing = newHashMap();
        existing.put("subject.mysub.unkown", "old value");
        when(repository.findBySubject(SubjectCode)).thenReturn(existing);

        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(entry("subject.mysub.name", "mysub name"));

        verify(repository).update(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).doesNotContain(entry("subject.mysub.name", "mysub name"));

        verify(repository).delete(eq(SubjectCode), messageKeyCaptor.capture());
        assertThat(messageKeyCaptor.getValue()).containsOnly("subject.mysub.unkown");
    }

    @Test
    public void itShouldSetSubjectMessages() {
        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(
                entry("subject.mysub.some-msg", "msg 1"),
                entry("subject.mysub.another-msg", "msg 2")
        );
    }

    @Test
    public void itShouldSetAssessmentTypeMessages() {
        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(
                entry("subject.mysub.asmt-type.ica.name", "interim"),
                entry("subject.mysub.asmt-type.ica.long-name", "interim"),
                entry("subject.mysub.asmt-type.ica.level.1.name", "Level 1"),
                entry("subject.mysub.asmt-type.ica.level.1.short-name", "Level 1"),
                entry("subject.mysub.asmt-type.ica.level.1.suffix", ""),
                entry("subject.mysub.asmt-type.ica.level.1.color", "Color 1"),
                entry("subject.mysub.asmt-type.ica.level.2.name", "Level 2"),
                entry("subject.mysub.asmt-type.ica.level.2.short-name", "Short Level 2"),
                entry("subject.mysub.asmt-type.ica.level.2.suffix", "Suffix"),
                entry("subject.mysub.asmt-type.ica.level.2.color", "Color 2"),
                entry("subject.mysub.asmt-type.ica.level.3.name", "Level 3"),
                entry("subject.mysub.asmt-type.ica.level.3.color", "Color 3"),
                entry("subject.mysub.asmt-type.ica.claim-score.level.1.name", "Level 1"),
                entry("subject.mysub.asmt-type.ica.claim-score.level.1.short-name", "Level 1"),
                entry("subject.mysub.asmt-type.ica.claim-score.level.1.suffix", ""),
                entry("subject.mysub.asmt-type.ica.claim-score.level.1.color", "Color 1"),
                entry("subject.mysub.asmt-type.ica.claim-score.level.2.name", "Level 2"),
                entry("subject.mysub.asmt-type.ica.claim-score.level.2.short-name", "Short Level 2"),
                entry("subject.mysub.asmt-type.ica.claim-score.level.2.suffix", "Suffix"),
                entry("subject.mysub.asmt-type.ica.claim-score.level.2.color", "Color 2"),
                entry("subject.mysub.asmt-type.iab.name", "iab"),
                entry("subject.mysub.asmt-type.iab.long-name", "Long iab"),
                entry("subject.mysub.asmt-type.iab.level.1.name", "Level 1"),
                entry("subject.mysub.asmt-type.iab.level.1.short-name", "Level 1"),
                entry("subject.mysub.asmt-type.iab.level.1.suffix", ""),
                entry("subject.mysub.asmt-type.iab.level.1.color", "Color 1"),
                entry("subject.mysub.asmt-type.iab.level.2.name", "Level 2"),
                entry("subject.mysub.asmt-type.iab.level.2.short-name", "Short Level 2"),
                entry("subject.mysub.asmt-type.iab.level.2.suffix", "Suffix"),
                entry("subject.mysub.asmt-type.iab.level.2.color", "Color 2")
        );
    }

    @Test
    public void itShouldSetDepthOfKnowledgeMessages() {
        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(
                entry("subject.mysub.dok.1.name", "Depth 1"),
                entry("subject.mysub.dok.2.name", "Depth 2")
        );
    }

    @Test
    public void itShouldSetReportGradeMessages() {
        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(
                entry("subject.mysub.report-grade.03.asmt-type.ica.overall.title", "Overall ica"),
                entry("subject.mysub.report-grade.03.asmt-type.ica.overall.level.1", "Level 1"),
                entry("subject.mysub.report-grade.03.asmt-type.ica.overall.level.2", "Level 2"),
                entry("subject.mysub.report-grade.03.asmt-type.ica.claim.title", "Claim ica"),
                entry("subject.mysub.report-grade.03.asmt-type.ica.claim.claim_a.level.1", "Level 1"),
                entry("subject.mysub.report-grade.03.asmt-type.ica.claim.claim_a.level.2", "Level 2"),
                entry("subject.mysub.report-grade.03.asmt-type.ica.claim.claim_b.level.1", "Level 1"),
                entry("subject.mysub.report-grade.03.asmt-type.ica.claim.claim_b.level.2", "Level 2"),
                entry("subject.mysub.report-grade.03.asmt-type.sum.overall.title", "Overall sum"),
                entry("subject.mysub.report-grade.03.asmt-type.sum.claim.title", "Claim sum"),
                entry("subject.mysub.report-grade.04.asmt-type.ica.overall.title", "Overall ica"),
                entry("subject.mysub.report-grade.04.asmt-type.ica.claim.title", "Claim ica"),
                entry("subject.mysub.report-grade.04.asmt-type.sum.overall.title", "Overall sum"),
                entry("subject.mysub.report-grade.04.asmt-type.sum.claim.title", "Claim sum")
        );
    }

    @Test
    public void itShouldSetClaimAndTargetMessages() {
        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(
                entry("subject.mysub.claim.claim_a.name", "Name claim_a"),
                entry("subject.mysub.claim.claim_a.icon", "Icon claim_a"),
                entry("subject.mysub.claim.claim_a.description", "Description claim_a"),
                entry("subject.mysub.claim.claim_a.target.target_a.name", "Name target_a"),
                entry("subject.mysub.claim.claim_a.target.target_a.description", "Description target_a"),
                entry("subject.mysub.claim.claim_b.name", "Name claim_b"),
                entry("subject.mysub.claim.claim_b.target.target_a.description", "Description target_a")
        );
        assertThat(messageCaptor.getValue().keySet()).doesNotContain(
                "subject.mysub.claim.claim_b.icon",
                "subject.mysub.claim.claim_c.target.target_a.name"
        );
    }

    @Test
    public void itShouldSetStandardMessages() {
        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), messageCaptor.capture());
        assertThat(messageCaptor.getValue()).contains(
                entry("subject.mysub.standard.standard_a.description", "Description standard_a"),
                entry("subject.mysub.standard.standard_b.description", "Description standard_b")
        );
    }

    private Subject.Builder subject() {
        return Subject.builder()
                .code(SubjectCode)
                .name(SubjectCode + " name")
                .subjectMessages(ImmutableList.of(
                        SubjectMessage.builder().key("some-msg").value("msg 1").build(),
                        SubjectMessage.builder().key("another-msg").value("msg 2").build()
                ))
                .assessmentTypes(ImmutableList.of(
                        assessmentType("ica", "interim").build(),
                        assessmentType("iab", "iab").build()
                ))
                .depthsOfKnowledge(ImmutableList.of(
                        depth(1).build(),
                        depth(2).build()
                ))
                .reportGrades(ImmutableList.of(
                        reportGrade("03").build(),
                        reportGrade("04").build()
                ))
                .claims(ImmutableList.of(
                        claim("claim_a").build(),
                        claim("claim_b").icon(null).build(),
                        claim("claim_c").organizational(false).targets(null).build()
                ))
                .standards(ImmutableList.of(
                        Standard.builder().code("standard_a").description("Description standard_a").build(),
                        Standard.builder().code("standard_b").description("Description standard_b").build()
                ));
    }

    private SubjectAssessmentType.Builder assessmentType(final String type, final String name) {
        return SubjectAssessmentType.builder()
                .code(type)
                .name(name)
                .longName("iab".equals(type)? "Long " + name : null)
                .performanceLevels(PerformanceLevels.builder()
                        .performanceLevels("iab".equals(type) ? performanceLevels(2) : performanceLevels(3))
                        .build())
                .claimScoring("iab".equals(type) ? null : claimScoring().build());
    }

    private List<PerformanceLevel> performanceLevels(final int count) {
        final List<PerformanceLevel> levels = newArrayList(count);
        for (int i = 1; i <= count; i++) {
            levels.add(PerformanceLevel.builder()
                    .level(i)
                    .name("Level " + i)
                    .shortName(i == 1 ? null : "Short Level " + i)
                    .suffix(i == 1 ? null : "Suffix")
                    .color("Color " + i)
                    .build());
        }
        return levels;
    }

    private ClaimScoring.Builder claimScoring() {
        return ClaimScoring.builder()
                .performanceLevels(PerformanceLevels.builder()
                        .performanceLevels(performanceLevels(2))
                        .build());
    }

    private DepthOfKnowledge.Builder depth(final int depth) {
        return DepthOfKnowledge.builder()
                .level(depth)
                .name("Depth " + depth);
    }

    private ReportGrade.Builder reportGrade(final String gradeCode) {
        return ReportGrade.builder()
                .code(gradeCode)
                .reportAssessmentTypes(ImmutableList.of(
                        reportAsmtType("ica").build(),
                        reportAsmtType("sum").build()
                ));
    }

    private ReportAssessmentType.Builder reportAsmtType(final String type) {
        return ReportAssessmentType.builder()
                .code(type)
                .overallAchievementMessage("Overall " + type)
                .claimAchievementMessage("Claim " + type)
                .reportPerformanceLevels(reportPerformanceLevels(2))
                .reportClaims(ImmutableList.of(
                        reportClaim("claim_a").build(),
                        reportClaim("claim_b").build()
                ));
    }

    private ReportClaim.Builder reportClaim(final String claimCode) {
        return ReportClaim.builder()
                .code(claimCode)
                .performanceLevels(reportPerformanceLevels(2));
    }

    private List<ReportPerformanceLevel> reportPerformanceLevels(final int levelCount) {
        final List<ReportPerformanceLevel> levels = newArrayList(levelCount);
        for (int i = 1; i <= levelCount; i++) {
            levels.add(ReportPerformanceLevel.builder()
                    .level(i)
                    .description("Level " + i)
                    .build());
        }
        return levels;
    }

    private ItemClaim.Builder claim(final String code) {
        return ItemClaim.builder()
                .code(code)
                .name("Name " + code)
                .icon("Icon " + code)
                .description("Description " + code)
                .targets(ImmutableList.of(
                        target("target_a"),
                        target("target_b")
                ));
    }

    private Target target(final String targetCode) {
        return Target.builder()
                .code(targetCode)
                .name("Name " + targetCode)
                .description("Description " + targetCode)
                .build();
    }
}