package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.subject.ClaimScoring;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevels;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseSubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectAssessmentTypeRepository;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class DefaultSubjectAssessmentTypeServiceTest {
    private static final String SubjectCode = "test_sub";

    @Mock
    private SubjectAssessmentTypeRepository repository;

    @Captor
    private ArgumentCaptor<WarehouseSubjectAssessmentType> typeCaptor;

    private DefaultSubjectAssessmentTypeService service;

    @Before
    public void setup() {
        service = new DefaultSubjectAssessmentTypeService(repository);
    }

    @Test
    public void itShouldInsertNewTypes() {
        final Subject subject = subject().build();
        service.upsert(subject().build());

        verify(repository, times(3)).create(typeCaptor.capture());
        final Map<String, WarehouseSubjectAssessmentType> types = typeCaptor.getAllValues().stream()
                .collect(Collectors.toMap(
                        WarehouseSubjectAssessmentType::getAssessmentTypeCode,
                        type -> type
                ));
        final WarehouseSubjectAssessmentType ica = types.get("ica");
        assertThat(ica.getSubjectCode()).isEqualTo(subject.getCode());
        assertThat(ica.getPerformanceLevelCount()).isEqualTo(4);
        assertThat(ica.getPerformanceLevelCutoff()).isEqualTo(3);
        assertThat(ica.getClaimScorePerformanceLevelCount()).isEqualTo(4);

        final WarehouseSubjectAssessmentType iab = types.get("iab");
        assertThat(iab.getSubjectCode()).isEqualTo(subject.getCode());
        assertThat(iab.getPerformanceLevelCount()).isEqualTo(3);
        assertThat(iab.getPerformanceLevelCutoff()).isNull();
        assertThat(iab.getClaimScorePerformanceLevelCount()).isNull();

        final WarehouseSubjectAssessmentType sum = types.get("sum");
        assertThat(sum.getSubjectCode()).isEqualTo(subject.getCode());
        assertThat(sum.getPerformanceLevelCount()).isEqualTo(4);
        assertThat(sum.getPerformanceLevelCutoff()).isEqualTo(3);
        assertThat(sum.getClaimScorePerformanceLevelCount()).isEqualTo(3);
    }

    /**
     * Test an update of "ica", delete of "iab", and leave "sum" unchanged.
     */
    @Test
    public void itShouldUpdateAndRemoveExistingTypesWithoutAssessments() {
        final List<WarehouseSubjectAssessmentType> existingTypes = ImmutableList.of(
                warehouseType("ica", 4, 3).build(),
                warehouseType("iab", 3, 0).build(),
                warehouseType("sum", 4, 3).build()
        );
        when(repository.findBySubject(SubjectCode)).thenReturn(existingTypes);

        final Subject updated = subject()
                .assessmentTypes(ImmutableList.of(
                        assessmentType("ica", 5, 5).build(),
                        assessmentType("sum", 4, 3).build()
                ))
                .build();
        service.upsert(updated);
        verify(repository).delete(eq(updated.getCode()), eq("iab"));

        verify(repository, times(2)).isReferenced(typeCaptor.capture());
        assertThat(typeCaptor.getAllValues().stream()
                .map(WarehouseSubjectAssessmentType::getAssessmentTypeCode))
                .containsOnly("ica", "iab");

        verify(repository).update(typeCaptor.capture());
        assertThat(typeCaptor.getValue().getAssessmentTypeCode()).isEqualTo("ica");
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotAllowRemovingATypeWithExams() {
        final List<WarehouseSubjectAssessmentType> existingTypes = ImmutableList.of(
                warehouseType("ica", 4, 3).build()
        );
        when(repository.findBySubject(SubjectCode)).thenReturn(existingTypes);
        when(repository.isReferenced(eq(existingTypes.get(0)))).thenReturn(true);

        final Subject updated = subject()
                .assessmentTypes(ImmutableList.of())
                .build();
        service.upsert(updated);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotAllowUpdatingPerformanceLevelCountsForATypeWithExams() {
        final List<WarehouseSubjectAssessmentType> existingTypes = ImmutableList.of(
                warehouseType("ica", 4, 3).build()
        );
        when(repository.findBySubject(SubjectCode)).thenReturn(existingTypes);
        when(repository.isReferenced(eq(existingTypes.get(0)))).thenReturn(true);

        final Subject updated = subject()
                .assessmentTypes(ImmutableList.of(
                        assessmentType("ica", 5, 5).build()
                ))
                .build();
        service.upsert(updated);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotAllowUpdatingClaimScorePerformanceLevelCountsForATypeWithExams() {
        final List<WarehouseSubjectAssessmentType> existingTypes = ImmutableList.of(
                warehouseType("ica", 4, 3).build()
        );
        when(repository.findBySubject(SubjectCode)).thenReturn(existingTypes);
        when(repository.isReferenced(eq(existingTypes.get(0)))).thenReturn(true);

        final Subject updated = subject()
                .assessmentTypes(ImmutableList.of(
                        assessmentType("ica", 4, 5).build()
                ))
                .build();
        service.upsert(updated);
    }

    private Subject.Builder subject() {
        return Subject.builder()
                .code(SubjectCode)
                .assessmentTypes(ImmutableList.of(
                        assessmentType("ica", 4, 4).build(),
                        assessmentType("iab", 3, 0).build(),
                        assessmentType("sum", 4, 3).build()
                ));
    }

    private SubjectAssessmentType.Builder assessmentType(final String code,
                                                         final int perfLevels,
                                                         final int subPerfLevels) {
        final List<PerformanceLevel> levels = newArrayList();
        for (int i = 1; i <= perfLevels; i++) {
            levels.add(performanceLevel(i));
        }

        final List<PerformanceLevel> claimScoreLevels = newArrayList();
        for (int i = 1; i <= subPerfLevels; i++) {
            claimScoreLevels.add(performanceLevel(i));
        }

        return SubjectAssessmentType.builder()
                .code(code)
                .performanceLevels(PerformanceLevels.builder()
                        .performanceLevels(levels)
                        .standardCutoff(perfLevels > 3 ? 3 : null)
                        .build())
                .claimScoring(claimScoreLevels.isEmpty() ? null : ClaimScoring.builder()
                        .performanceLevels(PerformanceLevels.builder()
                                .performanceLevels(claimScoreLevels)
                                .standardCutoff(claimScoreLevels.size() > 3 ? 3 : null)
                                .build())
                        .build());

    }

    private PerformanceLevel performanceLevel(final int level) {
        return PerformanceLevel.builder()
                .level(level)
                .build();
    }

    private WarehouseSubjectAssessmentType.Builder warehouseType(final String code,
                                                                 final int perfLevels,
                                                                 final int subPerfLevels) {
        return WarehouseSubjectAssessmentType.builder()
                .subjectCode(SubjectCode)
                .assessmentTypeCode(code)
                .performanceLevelCount(perfLevels)
                .performanceLevelCutoff(perfLevels > 3 ? 3 : null)
                .claimScorePerformanceLevelCount(subPerfLevels > 0 ? subPerfLevels : null);
    }
}