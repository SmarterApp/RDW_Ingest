package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.ImmutableList;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.ingest.common.test.CachingTest;
import org.opentestsystem.rdw.ingest.processor.configuration.DataSourceConfiguration;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseDepthOfKnowledge;
import org.opentestsystem.rdw.ingest.processor.repository.DepthOfKnowledgeRepository;
import org.opentestsystem.rdw.utils.YamlPropertiesConfigurator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.net.URI;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = {
        JdbcDepthOfKnowledgeRepository.class,
        DataSourceConfiguration.class,
        YamlPropertiesConfigurator.class
})
@Transactional
@CachingTest
@ActiveProfiles("test")
@Sql(statements = {
        "INSERT INTO subject (id, code) VALUES (-99, 'sub_a');",
        "INSERT INTO depth_of_knowledge (id, level, subject_id, reference, description) VALUES (-1, 1, -99, 'http://somewhere.com/1', 'description 1'), (-2, 2, -99, 'http://somewhere.com/2', 'description 2');",
})
public class JdbcDepthOfKnowledgeRepositoryIT {

    @Autowired
    private DepthOfKnowledgeRepository repository;

    @Test
    public void itShouldReturnId() {
        assertThat(repository.findIdByLevelAndSubject(1, -99)).isEqualTo(-1);
        assertThat(repository.findIdByLevelAndSubject(2, -99)).isEqualTo(-2);
    }

    @Test
    public void itShouldReturnNullWhenCodeIsUnknown() {
        assertThat(repository.findIdByLevelAndSubject(3, -99)).isEqualTo(null);
    }

    @Test
    public void itShouldFindDepthsBySubject() {
        assertThat(repository.findBySubject("sub_a"))
                .usingRecursiveFieldByFieldElementComparator()
                .containsOnly(
                        WarehouseDepthOfKnowledge.builder()
                                .id(-1)
                                .level(1)
                                .reference(URI.create("http://somewhere.com/1"))
                                .build(),
                        WarehouseDepthOfKnowledge.builder()
                                .id(-2)
                                .level(2)
                                .reference(URI.create("http://somewhere.com/2"))
                                .build());
    }

    @Test
    @Sql(statements = {"INSERT INTO subject (id, code) VALUES (-100, 'sub_b');"})
    public void itShouldCreateDepthsOfKnowledge() {
        final List<WarehouseDepthOfKnowledge> newDepths = ImmutableList.of(
                WarehouseDepthOfKnowledge.builder().level(1).reference(URI.create("http://somewhere.com/1")).build(),
                WarehouseDepthOfKnowledge.builder().level(2).reference(URI.create("http://somewhere.com/2")).build()
        );
        repository.create("sub_b", newDepths);

        final Map<Integer, WarehouseDepthOfKnowledge> persisted = repository.findBySubject("sub_b").stream()
                .collect(Collectors.toMap(
                        WarehouseDepthOfKnowledge::getLevel,
                        dok -> dok
                ));
        assertThat(persisted).hasSize(2);
        assertThat(persisted.get(1).getReference()).isEqualTo(URI.create("http://somewhere.com/1"));
        assertThat(persisted.get(2).getReference()).isEqualTo(URI.create("http://somewhere.com/2"));
    }

    @Test
    @Sql(
            scripts = "/PreloadAsmt.sql",
            statements = {
                    "INSERT INTO subject (id, code) VALUES (-99, 'sub_a');",
                    "INSERT INTO depth_of_knowledge (id, level, subject_id, reference, description) VALUES (-1, 1, -99, 'http://somewhere.com/1', 'description 1'), (-2, 2, -99, 'http://somewhere.com/2', 'description 2');",
            }
    )
    public void itShouldDetermineIfADepthOfKnowledgeIsReferenced() {
        assertThat(repository.hasItems(ImmutableList.of(-1, -2))).isNull();
        assertThat(repository.hasItems(ImmutableList.of(-1, -2, 1))).isEqualTo(1);
    }

    @Test
    public void itShouldDeleteDepthsOfKnowledge() {
        repository.delete(ImmutableList.of(-1, -2));
        assertThat(repository.findBySubject("sub_a")).isEmpty();
    }

    @Test
    public void itShouldUpdateDepthsOfKnowledge() {
        final List<WarehouseDepthOfKnowledge> updatedDepths = repository.findBySubject("sub_a").stream()
                .map(dok -> dok.copy().reference(URI.create(dok.getReference().toASCIIString() + "/new")).build())
                .collect(Collectors.toList());
        repository.update(updatedDepths);

        final Collection<WarehouseDepthOfKnowledge> persisted = repository.findBySubject("sub_a");
        assertThat(persisted.stream().map(dok -> dok.getReference().toASCIIString()))
                .containsOnly("http://somewhere.com/1/new", "http://somewhere.com/2/new");
    }
}