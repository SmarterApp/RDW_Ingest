package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevel;
import org.opentestsystem.rdw.common.model.subject.PerformanceLevels;
import org.opentestsystem.rdw.common.model.subject.SubScoring;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.common.model.subject.SubjectAssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.WarehouseScorableClaim;
import org.opentestsystem.rdw.ingest.processor.repository.ScorableClaimRepository;

import java.util.Collection;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class DefaultSubjectScorableClaimServiceTest {
    private static final String SubjectCode = "subject";

    @Mock
    private ScorableClaimRepository repository;

    @Captor
    private ArgumentCaptor<Collection<WarehouseScorableClaim>> claimCaptor;

    @Captor
    private ArgumentCaptor<Collection<Integer>> idCaptor;

    private DefaultSubjectScorableClaimService service;

    @Before
    public void setup() {
        when(repository.hasAssessment(any())).thenReturn(null);
        service = new DefaultSubjectScorableClaimService(repository);
    }

    @Test
    public void itShouldCreateNewScorableClaims() {
        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), claimCaptor.capture());
        assertThat(claimCaptor.getValue())
                .usingRecursiveFieldByFieldElementComparator()
                .containsOnly(
                        WarehouseScorableClaim.builder().code("claim_a").asmtTypeCode("ica").displayOrder(1).build(),
                        WarehouseScorableClaim.builder().code("claim_b").asmtTypeCode("ica").displayOrder(2).build(),
                        WarehouseScorableClaim.builder().code("claim_a").asmtTypeCode("sum").displayOrder(1).build(),
                        WarehouseScorableClaim.builder().code("claim_b").asmtTypeCode("sum").displayOrder(2).build()
                );

        verify(repository).update(claimCaptor.capture());
        assertThat(claimCaptor.getValue()).isEmpty();

        verify(repository, never()).hasAssessment(any());
        verify(repository, never()).delete(any());
    }

    @Test
    public void itShouldUpdateExistingClaims() {
        final List<WarehouseScorableClaim> existing = newArrayList();
        existing.add(WarehouseScorableClaim.builder().id(1).code("claim_a").asmtTypeCode("ica").displayOrder(1).build());
        existing.add(WarehouseScorableClaim.builder().id(2).code("claim_b").asmtTypeCode("ica").displayOrder(3).build());
        existing.add(WarehouseScorableClaim.builder().id(3).code("claim_a").asmtTypeCode("sum").displayOrder(1).build());
        existing.add(WarehouseScorableClaim.builder().id(4).code("claim_b").asmtTypeCode("sum").displayOrder(3).build());
        when(repository.findBySubject(SubjectCode)).thenReturn(existing);

        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), claimCaptor.capture());
        assertThat(claimCaptor.getValue()).isEmpty();

        verify(repository).update(claimCaptor.capture());
        assertThat(claimCaptor.getValue().stream().map(WarehouseScorableClaim::getId))
                .containsOnly(2, 4);

        verify(repository, never()).hasAssessment(any());
        verify(repository, never()).delete(any());
    }

    @Test
    public void itShouldDeleteStaleClaims() {
        final List<WarehouseScorableClaim> existing = newArrayList();
        existing.add(WarehouseScorableClaim.builder().id(1).code("claim_a").asmtTypeCode("ica").displayOrder(1).build());
        existing.add(WarehouseScorableClaim.builder().id(2).code("claim_b").asmtTypeCode("ica").displayOrder(2).build());
        existing.add(WarehouseScorableClaim.builder().id(3).code("claim_c").asmtTypeCode("ica").displayOrder(3).build());
        existing.add(WarehouseScorableClaim.builder().id(4).code("claim_a").asmtTypeCode("sum").displayOrder(1).build());
        existing.add(WarehouseScorableClaim.builder().id(5).code("claim_b").asmtTypeCode("sum").displayOrder(2).build());
        existing.add(WarehouseScorableClaim.builder().id(6).code("claim_c").asmtTypeCode("sum").displayOrder(3).build());
        when(repository.findBySubject(SubjectCode)).thenReturn(existing);

        service.upsert(subject().build());

        verify(repository).create(eq(SubjectCode), claimCaptor.capture());
        assertThat(claimCaptor.getValue()).isEmpty();

        verify(repository).update(claimCaptor.capture());
        assertThat(claimCaptor.getValue()).isEmpty();

        verify(repository).hasAssessment(idCaptor.capture());
        assertThat(idCaptor.getValue()).containsOnly(3, 6);

        verify(repository).delete(idCaptor.capture());
        assertThat(idCaptor.getValue()).containsOnly(3, 6);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotDeleteAReferencedScorableClaim() {
        final List<WarehouseScorableClaim> existing = newArrayList();
        existing.add(WarehouseScorableClaim.builder().id(1).code("claim_a").asmtTypeCode("ica").displayOrder(1).build());
        existing.add(WarehouseScorableClaim.builder().id(2).code("claim_b").asmtTypeCode("ica").displayOrder(2).build());
        existing.add(WarehouseScorableClaim.builder().id(3).code("claim_c").asmtTypeCode("ica").displayOrder(3).build());
        existing.add(WarehouseScorableClaim.builder().id(4).code("claim_a").asmtTypeCode("sum").displayOrder(1).build());
        existing.add(WarehouseScorableClaim.builder().id(5).code("claim_b").asmtTypeCode("sum").displayOrder(2).build());
        existing.add(WarehouseScorableClaim.builder().id(6).code("claim_c").asmtTypeCode("sum").displayOrder(3).build());
        when(repository.findBySubject(SubjectCode)).thenReturn(existing);
        when(repository.hasAssessment(any())).thenAnswer(invocation -> {
            final Collection<Integer> ids = invocation.getArgument(0);
            return Iterables.getFirst(ids, null);
        });

        service.upsert(subject().build());
    }

    private Subject.Builder subject() {
        return Subject.builder()
                .code(SubjectCode)
                .assessmentTypes(ImmutableList.of(
                        asmtType("ica").build(),
                        asmtType("sum").build(),
                        asmtType("iab").subScoring(null).build()
                ))
                .claims(ImmutableList.of(
                        claim("claim_a").displayOrder(1).build(),
                        claim("claim_b").displayOrder(2).build(),
                        claim("claim_c").scorable(false).build()
                ));
    }

    private ItemClaim.Builder claim(final String code) {
        return ItemClaim.builder()
                .code(code);
    }

    private SubjectAssessmentType.Builder asmtType(final String code) {
        return SubjectAssessmentType.builder()
                .code(code)
                .subScoring(SubScoring.builder()
                        .performanceLevels(PerformanceLevels.builder()
                                .performanceLevels(ImmutableList.of(
                                        PerformanceLevel.builder().name("Level 1").level(1).build(),
                                        PerformanceLevel.builder().name("Level 2").level(2).build()
                                ))
                                .build())
                        .build());
    }
}