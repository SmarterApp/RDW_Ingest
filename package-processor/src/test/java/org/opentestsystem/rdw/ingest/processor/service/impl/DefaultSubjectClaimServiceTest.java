package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.common.model.subject.ItemClaim;
import org.opentestsystem.rdw.common.model.subject.Subject;
import org.opentestsystem.rdw.ingest.processor.repository.ClaimRepository;
import org.springframework.test.context.jdbc.Sql;

import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.util.Sets.newLinkedHashSet;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
@Sql("/LoadTestSubject.sql")
public class DefaultSubjectClaimServiceTest {
    private static final String SubjectCode = "test";

    @Mock
    private ClaimRepository repository;

    @Captor
    private ArgumentCaptor<String> codeCaptor;

    private DefaultSubjectClaimService service;

    @Before
    public void setup() {
        service = new DefaultSubjectClaimService(repository);
    }

    @Test
    public void itShouldInsertNewOrganizationalClaims() {
        final Subject subject = subject().build();
        service.upsert(subject);

        verify(repository, times(2)).create(eq(SubjectCode), codeCaptor.capture());
        assertThat(codeCaptor.getAllValues()).containsOnly("claim_a", "claim_b");
    }

    @Test
    public void itShouldRemoveExistingClaims() {
        final Set<String> existing = newLinkedHashSet("claim_a", "claim_x");
        when(repository.findCodesBySubject(eq(SubjectCode))).thenReturn(existing);

        service.upsert(subject().build());
        verify(repository).create(SubjectCode, "claim_b");
        verify(repository).isReferenced(SubjectCode, "claim_x");
        verify(repository).delete(SubjectCode, "claim_x");
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldNotRemoveExistingClaimsWithBoundAssessmentItems() {
        final Set<String> existing = newLinkedHashSet("claim_a", "claim_x");
        when(repository.findCodesBySubject(eq(SubjectCode))).thenReturn(existing);
        when(repository.isReferenced(SubjectCode, "claim_x")).thenReturn(true);

        service.upsert(subject().build());
    }

    private Subject.Builder subject() {
        return Subject.builder()
                .code(SubjectCode)
                .claims(ImmutableList.of(
                        itemClaim("claim_a").build(),
                        itemClaim("claim_b").build(),
                        itemClaim("claim_c").organizational(false).build()
                ));
    }

    private ItemClaim.Builder itemClaim(final String code) {
        return ItemClaim.builder()
                .code(code);
    }
}