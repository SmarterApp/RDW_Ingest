import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile

buildscript {
    repositories {
        mavenLocal()
        jcenter()
        maven { url 'http://repo.spring.io/plugins-release' }
    }
    dependencies {
        classpath("com.bmuschko:gradle-docker-plugin:3.0.7")
        classpath("io.spring.gradle:dependency-management-plugin:1.0.0.RELEASE")
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.5.2.RELEASE")
        classpath('org.springframework.build.gradle:propdeps-plugin:0.0.7')
    }
}

plugins {
    id 'com.jfrog.artifactory' version '4.4.18'
}

apply plugin: 'io.spring.dependency-management'

// Set version dependencies. This allows the cli to force version, e.g. `-Pcommon=0.0.1-SNAPSHOT`

String rdwCommonVersion = project.hasProperty("common") ? project.property("common") : "0.0.1-21"
String rdwSchemaVersion = project.hasProperty("schema") ? project.property("schema") : "0.0.1-87"


allprojects {
    group = 'org.opentestsystem.rdw.ingest'
    version = '0.0.1-SNAPSHOT'

    apply plugin: 'idea'
    apply plugin: 'propdeps'
    apply plugin: 'propdeps-maven'
    apply plugin: 'propdeps-idea'
    apply plugin: "com.jfrog.artifactory"

    if (project.hasProperty("buildNumber")) {
        project.setVersion(project.version.toString().replaceAll("SNAPSHOT", "${buildNumber}"))
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'maven'
    apply plugin: 'jacoco'
    apply plugin: 'io.spring.dependency-management'

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    repositories {
        mavenLocal()
        mavenCentral()
    }

    dependencyManagement {
        dependencies {
            dependency "org.opentestsystem.rdw.common:rdw-common-archive:${rdwCommonVersion}"
            dependency "org.opentestsystem.rdw.common:rdw-common-messaging:${rdwCommonVersion}"
            dependency "org.opentestsystem.rdw.common:rdw-common-model:${rdwCommonVersion}"
            dependency "org.opentestsystem.rdw.common:rdw-common-status:${rdwCommonVersion}"
            dependency "org.opentestsystem.rdw.common:rdw-common-utils:${rdwCommonVersion}"

            // commonly used libraries
            dependency 'com.google.code.gson:gson:2.8.0'
            dependency 'com.google.guava:guava:21.0'
            dependency 'org.slf4j:slf4j-api:1.7+'


            // commonly used test libraries
            dependency 'junit:junit:4.12+'
            dependency 'org.assertj:assertj-core:3.6+'
        }
        imports {
            // spring cloud Camden.SR5 includes spring cloud stream Brooklyn.SR2
            mavenBom 'org.springframework.cloud:spring-cloud-dependencies:Camden.SR5'
        }
    }

    dependencies {
        compile 'com.google.guava:guava'
        compile 'org.slf4j:slf4j-api'

        testCompile 'org.assertj:assertj-core'
        testCompile 'junit:junit'
    }

    // generate coverage report automatically (./build/reports/jacoco/test/html/index.html)
    test.finalizedBy(jacocoTestReport)

    // task to generate build-info.properties with build.version, build.timestamp
    // using this approach instead of resource filtering to avoid modifying source
    task createBuildInfoFile(dependsOn: processResources) {
        doLast {
            def buildInfoFile = new File("${buildDir}/resources/main/build-info.properties")
            buildInfoFile.parentFile.mkdirs()
            Properties props = new Properties()
            props.setProperty('build.version', project.version.toString())
            props.store(buildInfoFile.newWriter(), null)
        }
    }

    /***********************************************************
     * Docker setup for all subprojects except rdw-ingest-common,
     *  which doesn't have a docker image
     ***********************************************************/

    if (it.name != "rdw-ingest-common") {
        apply plugin: 'com.bmuschko.docker-remote-api'

        // this is for creating metadata
        compileJava.dependsOn(processResources)

        classes.dependsOn(createBuildInfoFile)

        docker {
            registryCredentials {
                username = dockerHubUser
                password = dockerHubPassword
                email = dockerHubEmail
            }
        }

        // task to create Dockerfile
        // (http://bmuschko.github.io/gradle-docker-plugin/docs/groovydoc/com/bmuschko/gradle/docker/tasks/image/Dockerfile.html)
        task createDockerfile(type: Dockerfile) {
            destFile = project.file('build/docker/Dockerfile')
            from('java:8-jre-alpine')
            volume('/tmp')
            label([maintainer: 'Fairway Technologies'])
            copyFile("${jar.archivePath.name}", "${jar.archivePath.name}")
            exposePort(8008, 8080)
            entryPoint("java", "-jar", "${jar.archivePath.name}")
        }

        task buildImage(type:DockerBuildImage, dependsOn:[build, createDockerfile]) {
            dockerFile = createDockerfile.destFile
            inputDir = project.file('build/docker/')
            tag = "fwsbac/${project.name}"
            doFirst {
                copy {
                    from jar
                    into inputDir
                }
            }
        }

        // to use this, you must use valid docker credentials, which can be set in the gradle.properties file
        task dockerPushImage(type: DockerPushImage, dependsOn: buildImage) {
            imageName = "fwsbac/${project.name}"
        }
    }

    //Skip running integration tests automatically, because integration tests can be long
    test.exclude '**/*IT.*'

    //This task for for manually running the integration tests without automatically cleaning and creating
    // the test database schemas
    task manualIT(type: Test) {
        outputs.upToDateWhen { false }
        doFirst {
            println "Running Manual Integration Tests..."
        }
    }

    //Specific integration test task that will automatially clean and migrate the test database schemas
    task IT(type: Test, dependsOn:[":cleanAllTest", ":migrateAllTest"]) {
        outputs.upToDateWhen { false }
        doFirst {
            println "Running Integration Tests..."
        }
    }

    tasks.withType(Test) {
        reports.html.destination = file("${reporting.baseDir}/${name}")
    }
}

/********************************************
 * RDW_Schema artifact dependency setup
 *******************************************/

//Initializing some properties for use in extracting schema dependency and finding schema tasks
project.ext.schemaBaseDir =  "$buildDir/schema/"

//Creating a schema configuration for facilitating unzipping and copying sql scripts
configurations {
    rdwSchema
    repositories {
        mavenLocal()
    }
}

//Declaring root project dependency on RDW_Schema for running integration tests
dependencies {
    rdwSchema("org.opentestsystem.rdw.schema:rdw-schema:${rdwSchemaVersion}@zip")
}


// Helper function to get the unzipped schema directory path at runtime.
def schemaDir() {
    schemaBaseDir + configurations.rdwSchema.singleFile.name.take(configurations.rdwSchema.singleFile.name.lastIndexOf('.'))
}

//Schema extraction task
task extractSchema(type: Sync) {
    dependsOn configurations.rdwSchema

    from { // use of closure defers evaluation until execution time
        zipTree(configurations.rdwSchema.singleFile)
    }
    into schemaBaseDir
}

/**********************************************************************
 * Dynamically creating the tasks to run against the database schema
 * The rdw-schema dependency contains a build.gradle file that defines
 *   specific tasks related to the schemas
 *********************************************************************/

//These are the tasks available in the Schema dependency that we would want to use in this project
def taskMap = ["migrateAll": "Migrates the schemas that are required for running locally",
               "cleanAll": "Cleans the schemas that are required for running locally",
               "migrateAll_test": "Migrates the schemas that integration tests depend on",
               "cleanAll_test": "Cleans the schemas that integration tests depend on"]

taskMap.keySet().each { key ->
    task(key.contains("_test")?"${key.take(key.lastIndexOf('_test'))}Test":"${key}Prod", type: GradleBuild, dependsOn: extractSchema) {
        group = "Schema"
        description = taskMap[key]
        doFirst {
            dir { schemaDir() }
        }
        tasks = [key]
    }
}

/****************************
* JFrog Artifactory setup
*****************************/
artifactory {
    contextUrl = "https://airdev.jfrog.io/airdev"
    resolve {
        repository {
            repoKey = 'libs-releases'
            maven = true
        }
    }
}
