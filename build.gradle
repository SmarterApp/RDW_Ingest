import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile

buildscript {
    repositories {
        mavenLocal()
        jcenter()
        maven { url 'http://repo.spring.io/plugins-release' }
    }
    dependencies {
        classpath("com.bmuschko:gradle-docker-plugin:3.0.11")
        classpath("io.spring.gradle:dependency-management-plugin:1.0.0.RELEASE")
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.5.2.RELEASE")
        classpath('org.springframework.build.gradle:propdeps-plugin:0.0.7')
    }
}

plugins {
    id 'com.jfrog.artifactory' version '4.4.18'
}

apply plugin: 'io.spring.dependency-management'

// Set version dependencies. This allows the cli to force version, e.g. `-Pcommon=1.1.0-SNAPSHOT`

String rdwCommonVersion = project.hasProperty("common") ? project.property("common") : "1.1.0-52"
String rdwSchemaVersion = project.hasProperty("schema") ? project.property("schema") : "1.1.0-241"
String dockerPrefix = "smarterbalanced"

allprojects {
    group = 'org.opentestsystem.rdw.ingest'
    version = '1.1.0-SNAPSHOT'

    apply plugin: 'idea'
    apply plugin: 'propdeps'
    apply plugin: 'propdeps-maven'
    apply plugin: 'propdeps-idea'
    apply plugin: "com.jfrog.artifactory"

    if (project.hasProperty("buildNumber")) {
        project.setVersion(project.version.toString().replaceAll("SNAPSHOT", "${buildNumber}"))
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'maven'
    apply plugin: 'jacoco'
    apply plugin: 'io.spring.dependency-management'

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    repositories {
        mavenLocal()
        mavenCentral()
        maven { url 'http://redshift-maven-repository.s3-website-us-east-1.amazonaws.com/release' }
    }

    dependencyManagement {
        dependencies {
            dependency "org.opentestsystem.rdw.common:rdw-common-archive:${rdwCommonVersion}"
            dependency "org.opentestsystem.rdw.common:rdw-common-messaging:${rdwCommonVersion}"
            dependency "org.opentestsystem.rdw.common:rdw-common-model:${rdwCommonVersion}"
            dependency "org.opentestsystem.rdw.common:rdw-common-status:${rdwCommonVersion}"
            dependency "org.opentestsystem.rdw.common:rdw-common-utils:${rdwCommonVersion}"

            // commonly used libraries
            dependency 'com.google.code.gson:gson:2.8.0'
            dependency 'com.google.guava:guava:21.0'
            dependency 'org.slf4j:slf4j-api:1.7+'

            // commonly used test libraries
            dependency 'junit:junit:4.12+'
            dependency 'org.assertj:assertj-core:3.6+'
        }
        imports {
            // spring cloud Camden.SR5 includes spring cloud stream Brooklyn.SR2
            mavenBom 'org.springframework.cloud:spring-cloud-dependencies:Camden.SR5'
        }
    }

    dependencies {
        compile 'com.google.guava:guava'
        compile 'org.slf4j:slf4j-api'

        testCompile 'org.assertj:assertj-core'
        testCompile 'junit:junit'
    }

    // task to generate build-info.properties with build.version, build.timestamp
    // using this approach instead of resource filtering to avoid modifying source
    task createBuildInfoFile(dependsOn: processResources) {
        doLast {
            def buildInfoFile = new File("${buildDir}/resources/main/build-info.properties")
            buildInfoFile.parentFile.mkdirs()
            Properties props = new Properties()
            props.setProperty('build.version', project.version.toString())
            props.store(buildInfoFile.newWriter(), null)
        }
    }

    /***********************************************************
     * Docker setup for all sub-projects that need it
     ***********************************************************/
    if (!it.hasProperty('skipDocker')) {
        apply plugin: 'com.bmuschko.docker-remote-api'

        // this is for creating metadata
        compileJava.dependsOn(processResources)

        classes.dependsOn(createBuildInfoFile)

        docker {
            registryCredentials {
                username = dockerHubUser
                password = dockerHubPassword
                email = dockerHubEmail
            }
        }

        // Task to create Dockerfile based on (http://bmuschko.github.io/gradle-docker-plugin/docs/groovydoc/com/bmuschko/gradle/docker/tasks/image/Dockerfile.html)
        // We prefer to use a non-shell entry point so that signals get passed through properly. But that precludes
        // the use of environment variables for setting JAVA_OPTS. So, we include the critical ones here, allowing
        // subprojects to override them like this:
        // createDockerfile {
        //   ext.java_opts = ["-Xmx512m"]
        // }
        // The orchestration environment can completely override the entry point if necessary.
        task createDockerfile(type: Dockerfile) {
            destFile = project.file('build/docker/Dockerfile')
            from('openjdk:8-jre-alpine')
            volume('/tmp')
            label([maintainer: 'Fairway Technologies'])
            copyFile("${jar.archivePath.name}", "${jar.archivePath.name}")
            exposePort(8008, 8080)
            ext.java_opts = ["-Xmx256m"]
            entryPoint {
                List<String> entryPointArgs = ["java"]
                entryPointArgs.addAll(ext.java_opts)
                entryPointArgs.add("-jar")
                entryPointArgs.add("${jar.archivePath.name}")
                entryPointArgs.toArray()
            }
        }

        task buildImage(type:DockerBuildImage, dependsOn:[build, createDockerfile]) {
            dockerFile = createDockerfile.destFile
            inputDir = project.file('build/docker/')
            tag = "${dockerPrefix}/${project.name}" + (project.hasProperty("release") ? ":${project.version}" : "")
            doFirst {
                copy {
                    from jar
                    into inputDir
                }
            }
        }

        // to use this, you must use valid docker credentials, which can be set in the gradle.properties file
        task dockerPushImage(type: DockerPushImage, dependsOn: buildImage) {
            imageName = "${dockerPrefix}/${project.name}" + (project.hasProperty("release") ? ":${project.version}" : "")
        }
    }

    // Skip running integration and system tests automatically, because they take a long time
    test.exclude '**/*IT.*', '**/*RST.*'

    // This task for for manually running the integration tests without automatically cleaning and creating
    // the test database schemas
    task manualIT(type: Test) {
        include '**/*IT.*'
        outputs.upToDateWhen { false }
        doFirst {
            println "Running Manual Integration Tests..."
        }
    }

    // Specific integration test task that will automatically clean and migrate the test database schemas
    task IT(type: Test, dependsOn:[":cleanAllTest", ":migrateAllTest"]) {
        include '**/*IT.*'
        outputs.upToDateWhen { false }
        doFirst {
            println "Running Integration Tests..."
        }
    }

    // Specific integration test task that will automatically migrate the test database schemas
    task moIT(type: Test, dependsOn:[":migrateAllTest"]) {
        include '**/*IT.*'
        outputs.upToDateWhen { false }
        doFirst {
            println "Running Integration Tests without cleaning database (flyway migrate only)..."
        }
    }

    task coverage(type: Task, dependsOn: [test, IT]) {
        doFirst {
            jacocoTestReport.executionData(test, IT)
            jacocoTestReport.reports.html.destination = file("${reporting.baseDir}/${name}")

            // Only include execution data that exists (handle projects without integration tests)
            jacocoTestReport {
                executionData = files(executionData.findAll {
                    it.exists()
                })
            }
        }
        finalizedBy(jacocoTestReport)
    }
}

/********************************************
 * RDW_Schema artifact dependency setup
 *******************************************/

//Initializing some properties for use in extracting schema dependency and finding schema tasks
project.ext.schemaBaseDir =  "$buildDir/schema/"

//Creating a schema configuration for facilitating unzipping and copying sql scripts
configurations {
    rdwSchema
    repositories {
        mavenLocal()
    }
}

//Declaring root project dependency on RDW_Schema for running integration tests
dependencies {
    rdwSchema("org.opentestsystem.rdw.schema:rdw-schema:${rdwSchemaVersion}@zip")
}


// Helper function to get the unzipped schema directory path at runtime.
def schemaDir() {
    schemaBaseDir + configurations.rdwSchema.singleFile.name.take(configurations.rdwSchema.singleFile.name.lastIndexOf('.'))
}

//Schema extraction task
task extractSchema(type: Sync) {
    dependsOn configurations.rdwSchema

    from { // use of closure defers evaluation until execution time
        zipTree(configurations.rdwSchema.singleFile)
    }
    into schemaBaseDir
}

/**********************************************************************
 * Dynamically creating the tasks to run against the database schema
 * The rdw-schema dependency contains a build.gradle file that defines
 *   specific tasks related to the schemas
 *********************************************************************/

//These are the tasks available in the Schema dependency that we would want to use in this project
def taskMap = ["migrateAll": "Migrates the schemas that are required for running locally",
               "cleanAll": "Cleans the schemas that are required for running locally",
               "migrateAll_test": "Migrates the schemas that integration tests depend on",
               "cleanAll_test": "Cleans the schemas that integration tests depend on"]

taskMap.keySet().each { key ->
    task(key.contains("_test")?"${key.take(key.lastIndexOf('_test'))}Test":"${key}Prod", type: GradleBuild, dependsOn: extractSchema) {
        group = "Schema"
        description = taskMap[key]
        doFirst {
            dir { schemaDir() }
        }
        tasks = [key]
    }
}

/****************************
* JFrog Artifactory setup
*****************************/
artifactory {
    contextUrl = "https://airdev.jfrog.io/airdev"
    resolve {
        repository {
            repoKey = 'libs-releases'
            maven = true
        }
    }
}
