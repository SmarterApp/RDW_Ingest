package org.opentestsystem.rdw.ingest.impsvc.auth;

import com.okta.jwt.AccessTokenVerifier;
import com.okta.jwt.Jwt;
import com.okta.jwt.JwtVerificationException;
import org.junit.Before;
import org.junit.Test;
import org.springframework.security.oauth2.common.exceptions.InvalidTokenException;

import java.util.Map;

import static java.lang.Thread.sleep;
import static org.mockito.Mockito.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.ingest.impsvc.auth.SbacTokenConverterTest.assertPasswordGrantAuth;
import static org.opentestsystem.rdw.ingest.impsvc.auth.SbacTokenConverterTest.oktaPasswordGrantTokenMap;
import static org.opentestsystem.rdw.ingest.impsvc.auth.SbacTokenConverterTest.testConverter;
import static org.springframework.security.oauth2.common.OAuth2AccessToken.EXPIRES_IN;

public class OktaTokenServicesTest {
    private static final String AccessToken = "abc123";

    private OktaJwtHelper jwtHelper;
    private AccessTokenVerifier jwtVerifier;
    private Jwt jwt;

    // Class under test
    private OktaTokenServices services;

    @Before
    public void createServices() throws Exception {
        jwtHelper = mock(OktaJwtHelper.class);
        jwtVerifier = mock(AccessTokenVerifier.class);
        jwt = mock(Jwt.class);

        when(jwtHelper.getJwtVerifier()).thenReturn(jwtVerifier);
        when(jwtVerifier.decode(AccessToken)).thenReturn(jwt);
        when(jwt.getClaims()).thenReturn(oktaPasswordGrantTokenMap(AccessToken));

        services = new OktaTokenServices(testConverter());
        services.setJwtHelper(jwtHelper);
    }

    @Test
    public void itShouldLoadAuthentication() {
        assertPasswordGrantAuth(services.loadAuthentication(AccessToken));
    }

    @Test
    public void itShouldCacheAuthentication() throws Exception {
        assertPasswordGrantAuth(services.loadAuthentication(AccessToken));
        assertPasswordGrantAuth(services.loadAuthentication(AccessToken));
        assertPasswordGrantAuth(services.loadAuthentication(AccessToken));

        verify(jwtVerifier, times(1)).decode(anyString());
    }

    @Test
    public void itShouldInvalidateBasedOnExpiresInValue() throws Exception {
        final Map<String, Object> map = oktaPasswordGrantTokenMap(AccessToken);
        map.put(EXPIRES_IN, 1);
        when(jwt.getClaims()).thenReturn(map);

        assertPasswordGrantAuth(services.loadAuthentication(AccessToken));
        assertPasswordGrantAuth(services.loadAuthentication(AccessToken));

        verify(jwtVerifier, times(1)).decode(anyString());

        sleep(1200);
        assertPasswordGrantAuth(services.loadAuthentication(AccessToken));

        verify(jwtVerifier, times(2)).decode(anyString());
    }

    @Test
    public void itShouldUseConfiguredProperites() {
        final String url = "http://myserver/tokenInfo";
        final String audience = "api://test";
        final Long timeout = 1000L;

        services.setTokenInfoUrl(url);
        verify(jwtHelper).setIssuer(url);

        services.setAudience(audience);
        verify(jwtHelper).setAudience(audience);

        services.setConnectionTimeout(timeout);
        verify(jwtHelper).setConnectionTimeout(timeout);
    }

    @Test(expected = InvalidTokenException.class)
    public void itShouldPropagateCheckedException() throws Exception {
        when(jwtVerifier.decode(AccessToken)).thenThrow(JwtVerificationException.class);
        services.loadAuthentication(AccessToken);
    }
}