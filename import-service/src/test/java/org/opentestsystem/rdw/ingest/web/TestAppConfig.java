package org.opentestsystem.rdw.ingest.web;

import org.opentestsystem.rdw.ingest.auth.ForgeRockTokenServices;
import org.opentestsystem.rdw.ingest.auth.SecurityConfigurer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.test.web.servlet.request.RequestPostProcessor;
import org.springframework.web.client.RestOperations;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

import javax.annotation.PostConstruct;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * This configures an application context that has just enough to test controllers.
 * <p>
 * The commented out code was an initial attempt to fake out OAuth2 behavior. Basically,
 * it mocked the RestOperations for the token services. The bearerToken() helper injects
 * the required OAuth2 header (which is summarily ignored). This felt messy. Perhaps we
 * could figure out a more elegant solution where a placeholder token is used to encode
 * information so specific user info could tested (e.g. tenancy chain).
 * </p>
 */
@Configuration
@ComponentScan({"org.opentestsystem.rdw.ingest.web", "org.opentestsystem.rdw.ingest.auth"})
//@Import(SecurityConfigurer.class)
@EnableWebMvc
class TestAppConfig {

//    @Autowired
//    private ForgeRockTokenServices tokenServices;
//
//    @PostConstruct
//    public void mockRestOperations() {
//        final RestOperations restTemplate = mock(RestOperations.class);
//        when(restTemplate.getForObject(any(), any(), any(Map.class))).thenAnswer(invocation -> {
//            final String accessToken = ((Map<String,String>)invocation.getArguments()[2]).get("access_token");
//            final Map<String, Object> map = newHashMap();
//            map.put("sbacUUID", "57e3ed3de4b0e3b75702f3a0");
//            map.put("mail", "dwtest@example.com");
//            map.put("scope", newArrayList("sbacUUID", "mail", "sbacTenancyChain"));
//            map.put("grant_type", "password");
//            map.put("realm", "/sbac");
//            map.put("sbacTenancyChain", "|CA|ASMTDATALOAD|STATE|98765|CA98765|||CA|CALIFORNIA|||||||||");
//            map.put("token_type", "Bearer");
//            map.put("expires_in", 34479);
//            map.put("access_token", accessToken);
//            return map;
//
//        });
//        tokenServices.setRestTemplate(restTemplate);
//    }
//
//    public static RequestPostProcessor bearerToken(final String accessToken) {
//        return request -> {
//            request.addHeader("Authorization", "Bearer " + accessToken);
//            return request;
//        };
//    }

}
