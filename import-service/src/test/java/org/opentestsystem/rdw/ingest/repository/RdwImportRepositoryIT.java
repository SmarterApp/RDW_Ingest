package org.opentestsystem.rdw.ingest.repository;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.auth.SbacUserTest;
import org.opentestsystem.rdw.ingest.common.model.RdwImport;
import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.authentication.TestingAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Maps.newHashMap;
import static java.lang.Thread.sleep;
import static org.assertj.core.api.Assertions.assertThat;

@Ignore("won't run with multi-tenant changes; i'll revisit after")
@RunWith(SpringRunner.class)
@SpringBootTest
@Transactional
@ActiveProfiles("test")
public class RdwImportRepositoryIT {

    @Autowired
    private RdwImportRepository repository;

    @Before
    public void setTenantContext() {
        // avoid the No tenantKey fallback exception
        SecurityContextHolder.getContext()
                .setAuthentication(new TestingAuthenticationToken(SbacUserTest.testUser(), null));
    }

    @Test
    public void itShouldCreateAnImport() {
        final RdwImport saved = repository.create(RdwImport.builder()
                .status(ImportStatus.ACCEPTED)
                .content(ImportContent.PROBE)
                .contentType("text/plain")
                .creator("dwtest@example.com")
                .digest("DEADBEEF")
                .message("simple create test")
                .batch("abc")
                .created(Instant.now().minus(1000, ChronoUnit.HOURS))
                .updated(Instant.now().minus(800, ChronoUnit.HOURS))
                .build());
        assertThat(saved.getContent()).isEqualTo(ImportContent.PROBE);
        assertThat(saved.getCreator()).isEqualTo("dwtest@example.com");
        // check the values that are set by the repository
        assertThat(saved.getId()).isNotNull();
        assertThat(saved.getCreated()).isBetween(Instant.now().minus(1, ChronoUnit.MINUTES), Instant.now().plus(1, ChronoUnit.MINUTES));
        assertThat(saved.getUpdated()).isBetween(Instant.now().minus(1, ChronoUnit.MINUTES), Instant.now().plus(1, ChronoUnit.MINUTES));
    }

    @Test
    public void itShouldUpdateAnImport() throws InterruptedException {
        final Map<String, Long> map = createTestData();

        final RdwImport alice = repository.findOne(map.get("alice"));

        sleep(100); // guarantee updated timestamp is different

        final RdwImport updated = repository.update(alice.copy()
                .status(ImportStatus.INVALID)
                .digest("DEADBEEF")
                .message("updated message")
                .batch("updated")
            .build());

        assertThat(updated.getStatus()).isEqualTo(ImportStatus.INVALID);
        assertThat(updated.getDigest()).isEqualTo("DEADBEEF");
        assertThat(updated.getMessage()).isEqualTo("updated message");
        assertThat(updated.getBatch()).isEqualTo("updated");
        assertThat(updated.getCreated()).isEqualTo(alice.getCreated());
        // updated should be different
        assertThat(updated.getUpdated()).isAfter(alice.getUpdated());
    }

    @Test(expected = IllegalArgumentException.class)
    public void updateRequiresId() {
        repository.update(RdwImport.builder()
                .status(ImportStatus.ACCEPTED)
                .content(ImportContent.PROBE)
                .contentType("text/plain")
                .creator("dwtest@example.com")
                .digest("DEADBEEF")
                .build());
    }

    @Test
    public void itShouldCreateAndFindImports() {
        final long initialCount = repository.count();

        final Map<String, Long> map = createTestData();

        final RdwImport alice = repository.findOne(map.get("alice"));
        assertThat(alice.getCreator()).isEqualTo("alice");
        assertThat(alice.getDigest()).isEqualTo("alice");
        assertThat(alice.getMessage()).isEqualTo("Hi alice");

        assertThat(repository.findOneByContentAndDigest(ImportContent.EXAM, "bob").getCreator()).isEqualTo("bob");
        // but not if content doesn't match
        assertThat(repository.findOneByContentAndDigest(ImportContent.PACKAGE, "bob")).isNull();

        assertThat(repository.exists(map.get("alice"))).isTrue();
        assertThat(repository.exists(map.get("charlie") + 1234)).isFalse();

        assertThat(repository.count()).isEqualTo(initialCount+3);
    }

    @Test
    public void itShouldFindByBatch() {
        createTestData();
        final RdwImportQuery query = RdwImportQuery.builder().batch("abc").build();
        assertThat(repository.findBy(query)).hasSize(3);
    }

    @Test
    public void itShouldFindByStatus() {
        final RdwImportQuery query = RdwImportQuery.builder().status(ImportStatus.ACCEPTED).build();
        final int initialCount = repository.findBy(query).size();
        createTestData();
        assertThat(repository.findBy(query)).hasSize(initialCount+3);
    }

    @Test
    @Sql(statements = {
            "INSERT INTO import (id,status,content,contentType,digest,created,updated) VALUES " +
                    "(-1,0,1,'application/xml','1D849A91956B74350FF895F067F115E6',(CURRENT_TIMESTAMP - INTERVAL 12 HOUR),(CURRENT_TIMESTAMP - INTERVAL 1 HOUR))," +
                    "(-2,0,1,'application/xml','1D849A91956B74350FF895F067F115E7',(CURRENT_TIMESTAMP - INTERVAL 12 HOUR),(CURRENT_TIMESTAMP - INTERVAL 3 HOUR))," +
                    "(-3,0,1,'application/xml','1D849A91956B74350FF895F067F125E6',(CURRENT_TIMESTAMP - INTERVAL 12 HOUR),(CURRENT_TIMESTAMP - INTERVAL 10 HOUR));"
    })
    public void itShouldFindByUpdated() {
        // there was a bug where AFTER/BEFORE values were compared against created instead of updated
        // because of the way things work, we have to directly inject the data to test the query
        final RdwImportQuery query = RdwImportQuery.builder().after(Instant.now().minus(6, ChronoUnit.HOURS)).build();
        assertThat(repository.findBy(query).stream().map(RdwImport::getId).collect(Collectors.toSet())).contains(-1L, -2L);
    }

    @Test
    public void itShouldDelete() {
        final Map<String, Long> map = createTestData();
        final long count = repository.count();
        repository.delete(map.get("alice"));
        assertThat(repository.count()).isEqualTo(count-1);
    }

    @Test
    public void itShouldLetDatabaseSetCreated() {
        // this establishes that the database generates microsecond precision
        // and that the repo lets it do so, and preserves the result
        // (in theory, this test will fail 1/1000 times)
        final RdwImport alice = repository.findOne(createTestData().get("alice"));
        final Instant created = alice.getCreated();
        assertThat(created).isNotEqualTo(created.truncatedTo(ChronoUnit.MILLIS));
    }

    @Test
    public void itShouldNotFindUnknownImport() {
        assertThat(repository.findOne(-123)).isNull();
    }

    @Test
    public void itShouldNotFindUnknownImportByDigest() {
        assertThat(repository.findOneByContentAndDigest(ImportContent.EXAM, "probablyNotARealDigest")).isNull();
    }

    @Test
    public void itShouldFindAllStatuses() {
        final List<ImportStatus> statuses = repository.findAllStatuses();
        assertThat(statuses).contains(ImportStatus.values());
    }

    @Test(expected = IllegalStateException.class)
    @Sql(statements = {"INSERT INTO import_status (id, name) VALUES (-42, 'SKY_IS_FALLING')"})
    public void itShouldThrowIfUnknownStatus() {
        repository.findAllStatuses();
    }

    @Test(expected = IllegalStateException.class)
    @Sql(statements = {"UPDATE import_status SET name='SKY_IS_FALLING' WHERE id=-5"})
    public void itShouldThrowIfStatusNameIsWrong() {
        repository.findAllStatuses();
    }

    private Map<String, Long> createTestData() {
        final RdwImport.Builder builder = RdwImport.builder()
                .status(ImportStatus.ACCEPTED)
                .content(ImportContent.EXAM)
                .contentType("text/plain")
                .batch("abc");

        final Map<String, Long> result = newHashMap();
        for (final String creator : new String[]{"alice","bob","charlie"}) {
            final RdwImport saved = repository.create(builder
                    .creator(creator)
                    .digest(creator)
                    .message("Hi " + creator)
                    .build());
            result.put(creator, saved.getId());
        }
        return result;
    }
}
