package org.opentestsystem.rdw.ingest.impsvc.web;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.model.RdwImport;
import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.opentestsystem.rdw.ingest.impsvc.service.ImportService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.mock.mockito.MockReset;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalTo;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.ingest.impsvc.web.TestAppConfig.AuthHeader;
import static org.opentestsystem.rdw.ingest.impsvc.web.TestAppConfig.AuthHeaderForClient;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.fileUpload;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Base suite for integration tests of {@link ScopedImportController}s.
 * This has tests for the common functionality.
 */
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = TestAppConfig.class)
@WebAppConfiguration
abstract class ScopedControllerTestSuite {

    @Configuration
    public static class ServiceConfiguration {
        // This trick is necessary because there are two ImportService beans required but they
        // both should be the same mock object (so this base test suite can be shared). All of
        // this acts like a clever @MockBean annotation.
        @Bean(name={"defaultImportService", "groupImportService"})
        public ImportService importService() {
            return mock(ImportService.class, MockReset.after());
        }
    }

    protected final String uri;
    protected final ImportContent content;
    protected final String authHeader;

    @Autowired
    protected MockMvc mvc;

    @Autowired
    protected ImportService importService;

    protected ScopedControllerTestSuite(final String uri, final ImportContent content, final String authHeader) {
        this.uri = uri;
        this.content = content;
        this.authHeader = authHeader;
    }

    @Test
    public void itShouldReturnBadRequestForUploadWithNoFile() throws Exception {
        mvc.perform(fileUpload(uri).header(AuthHeader, authHeader))
                .andExpect(status().is(HttpStatus.BAD_REQUEST.value()));
    }

    @Test
    public void itShouldUseServiceToGetImportsByBatch() throws Exception {
        final String batch = "abc";
        when(importService.getImports(any(RdwImportQuery.class)))
                .thenReturn(newArrayList(RdwImport.builder().id(123L).batch(batch).build()));
        mvc.perform(get(uri + "?batch=" + batch).header(AuthHeader, authHeader))
                .andExpect(status().isOk())
                .andExpect(content().string(containsString(batch)))
                .andExpect(content().string(containsString("123")));
    }

    @Test
    public void itShouldUseServiceToGetImportsByStatus() throws Exception {
        final ImportStatus status = ImportStatus.BAD_FORMAT;
        when(importService.getImports(any(RdwImportQuery.class)))
                .thenReturn(newArrayList(RdwImport.builder().id(123L).status(status).build()));
        mvc.perform(get(uri + "?status=" + status.toString()).header(AuthHeader, authHeader))
                .andExpect(status().isOk())
                .andExpect(content().string(containsString(status.toString())))
                .andExpect(content().string(containsString("123")));
    }

    @Test
    public void itShouldReturnBadRequestForInvalidStatus() throws Exception {
        mvc.perform(get(uri + "?status=fubar").header(AuthHeader, authHeader))
                .andExpect(status().is(HttpStatus.BAD_REQUEST.value()));
    }

    @Test
    public void itShouldReturnBadRequestWhenNoCriteria() throws Exception {
        mvc.perform(get(uri).header(AuthHeader, authHeader))
                .andExpect(status().is(HttpStatus.BAD_REQUEST.value()));
    }

    @Test
    public void itShouldReturnUnauthorizedIfNoAuthToken() throws Exception {
        mvc.perform(get(uri + "?status=ACCEPTED"))
                .andExpect(status().is(HttpStatus.UNAUTHORIZED.value()));
    }

    @Test
    public void itShouldReturnForbiddenIfNoAuthority() throws Exception {
        mvc.perform(get(uri + "?status=ACCEPTED").header(AuthHeader, AuthHeaderForClient))
                .andExpect(status().is(HttpStatus.FORBIDDEN.value()));
    }

    @Test
    public void itShouldReturnForbiddenIfWrongAuthority() throws Exception {
        mvc.perform(get(uri + "?status=ACCEPTED").header(AuthHeader, "Bearer sbac;alice;|CA|GENERAL|STATE|98765|CA98765|||CA|CALIFORNIA|||||||||"))
                .andExpect(status().is(HttpStatus.FORBIDDEN.value()));
    }

    @Test
    public void itShouldResubmitImports() throws Exception {
        when(importService.resubmitImports(any(RdwImportQuery.class))).thenReturn(1L);
        mvc.perform(post(uri + "/resubmit").header(AuthHeader, authHeader).param("status", "BAD_DATA"))
                .andExpect(status().is2xxSuccessful())
                .andExpect(content().string(equalTo("1")));
        final ArgumentCaptor<RdwImportQuery> argumentCaptor = ArgumentCaptor.forClass(RdwImportQuery.class);
        verify(importService).resubmitImports(argumentCaptor.capture());
        final RdwImportQuery query = argumentCaptor.getValue();
        assertThat(query.getContent()).isEqualTo(content);
        assertThat(query.getStatus()).isEqualTo(ImportStatus.BAD_DATA);
    }

    @Test
    public void itShouldDenyResubmitIfNoAuthority() throws Exception {
        mvc.perform(post(uri + "/resubmit").header(AuthHeader, AuthHeaderForClient).param("status", "BAD_DATA"))
                .andExpect(status().is(HttpStatus.FORBIDDEN.value()));
    }

    @Test
    public void itShouldDenyResubmitIfNoAuthToken() throws Exception {
        mvc.perform(post(uri + "/resubmit").param("status", "BAD_DATA"))
                .andExpect(status().is(HttpStatus.UNAUTHORIZED.value()));
    }

    @Test
    public void itShouldResubmitImportsWithDefaultQuery() throws Exception {
        when(importService.resubmitImports(any(RdwImportQuery.class))).thenReturn(1L);
        mvc.perform(post(uri + "/resubmit").header(AuthHeader, authHeader))
                .andExpect(status().is2xxSuccessful())
                .andExpect(content().string(equalTo("1")));
        final ArgumentCaptor<RdwImportQuery> argumentCaptor = ArgumentCaptor.forClass(RdwImportQuery.class);
        verify(importService).resubmitImports(argumentCaptor.capture());
        final RdwImportQuery query = argumentCaptor.getValue();
        assertThat(query.getContent()).isEqualTo(content);
        assertThat(query.getStatus()).isEqualTo(ImportStatus.ACCEPTED);
    }
}
