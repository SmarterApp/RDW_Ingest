package org.opentestsystem.rdw.ingest.repository;

import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.model.RdwImport;
import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.List;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.collect.Lists.newArrayList;

/**
 * JDBC implementation of {@link RdwImportRepository}.
 */
@Repository
class JdbcRdwImportRepository implements RdwImportRepository {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.import.count}")
    private String sqlCount;

    @Value("${sql.import.create}")
    private String sqlCreate;

    @Value("${sql.import.update}")
    private String sqlUpdate;

    @Value("${sql.import.delete}")
    private String sqlDelete;

    @Value("${sql.import.exists}")
    private String sqlExists;

    @Value("${sql.import.findOne}")
    private String sqlFindOne;

    @Value("${sql.import.findOneByContentAndDigest}")
    private String sqlFindOneByContentAndDigest;

    @Value("${sql.import.findBy}")
    private String sqlFindBy;

    @Value("${sql.importStatus.findAll}")
    private String sqlImportStatusFindAll;

    @Autowired
    JdbcRdwImportRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Transactional
    @Override
    public RdwImport create(final RdwImport rdwImport) {
        final KeyHolder keyHolder = new GeneratedKeyHolder();
        jdbcTemplate.update(sqlCreate, mapToSqlParameterSource(rdwImport), keyHolder);

        // get saved copy so id, created, updated are set properly
        return findOne(keyHolder.getKey().longValue());
    }

    @Transactional
    @Override
    public RdwImport update(final RdwImport rdwImport) {
        checkArgument(rdwImport.getId() != null, "id required for update");

        jdbcTemplate.update(sqlUpdate, mapToSqlParameterSource(rdwImport).addValue("id", rdwImport.getId()));

        // get saved copy so updated is set properly
        return findOne(rdwImport.getId());
    }

    @Override
    public RdwImport findOne(final long id) {
        final MapSqlParameterSource parameterSource = new MapSqlParameterSource().addValue("id", id);
        try {
            return jdbcTemplate.queryForObject(sqlFindOne, parameterSource, RdwImportRowMapper);
        } catch (final EmptyResultDataAccessException ignored) {
            return null;
        }
    }

    @Override
    public RdwImport findOneByContentAndDigest(final ImportContent content, final String digest) {
        final MapSqlParameterSource parameterSource = new MapSqlParameterSource()
                .addValue("content", content.getValue())
                .addValue("digest", digest);
        try {
            return jdbcTemplate.queryForObject(sqlFindOneByContentAndDigest, parameterSource, RdwImportRowMapper);
        } catch (final EmptyResultDataAccessException ignored) {
            return null;
        }
    }

    @Override
    public boolean exists(final long id) {
        final MapSqlParameterSource parameterSource = new MapSqlParameterSource().addValue("id", id);
        return jdbcTemplate.queryForObject(sqlExists, parameterSource, Boolean.class);
    }

    @Override
    public long count() {
        return jdbcTemplate.getJdbcOperations().queryForObject(sqlCount, Long.class);
    }

    @Override
    public void delete(final long id) {
        final MapSqlParameterSource parameterSource = new MapSqlParameterSource().addValue("id", id);
        jdbcTemplate.update(sqlDelete, parameterSource);
    }

    @Override
    public List<RdwImport> findBy(final RdwImportQuery query) {
        final MapSqlParameterSource parameterSource = mapQueryToSqlParameterSource(query);
        try {
            return jdbcTemplate.query(sqlFindBy, parameterSource, RdwImportRowMapper);
        } catch (final EmptyResultDataAccessException ignored) {
            return newArrayList();
        }
    }

    @Override
    public List<ImportStatus> findAllStatuses() {
        try {
            return jdbcTemplate.query(sqlImportStatusFindAll, (rs, rowNum) -> {
                final ImportStatus status;
                try {
                    status = ImportStatus.fromValue(rs.getInt("id"));
                } catch (final IllegalArgumentException e) {
                    throw new IllegalStateException("Unknown ImportStatus id: " + rs.getInt("id") + ", name:" + rs.getString("name"));
                }
                if (!status.name().equals(rs.getString("name"))) {
                    throw new IllegalStateException("Bad ImportStatus name " + rs.getString("name"));
                }
                return status;
            });
        } catch (final EmptyResultDataAccessException ignored) {
            return newArrayList();
        }
    }

    private static final RowMapper<RdwImport> RdwImportRowMapper = (rs, rowNum) -> RdwImport.builder()
            .id(rs.getLong("id"))
            .content(ImportContent.fromValue(rs.getInt("content")))
            .contentType(rs.getString("contentType"))
            .digest(rs.getString("digest"))
            .status(ImportStatus.fromValue(rs.getInt("status")))
            .batch(rs.getString("batch"))
            .creator(rs.getString("creator"))
            .created(rs.getTimestamp("created").toInstant())
            .updated(rs.getTimestamp("updated").toInstant())
            .message(rs.getString("message"))
            .build();

    private MapSqlParameterSource mapToSqlParameterSource(final RdwImport rdwImport) {
        return new MapSqlParameterSource()
                .addValue("status", rdwImport.getStatus().getValue())
                .addValue("content", rdwImport.getContent().getValue())
                .addValue("contentType", rdwImport.getContentType())
                .addValue("digest", rdwImport.getDigest())
                .addValue("batch", rdwImport.getBatch())
                .addValue("creator", rdwImport.getCreator())
                .addValue("message", rdwImport.getMessage());
    }

    private MapSqlParameterSource mapQueryToSqlParameterSource(final RdwImportQuery query) {
        return new MapSqlParameterSource()
                .addValue("content", query.getContent() == null ? null : query.getContent().getValue())
                .addValue("status", query.getStatus() == null ? null : query.getStatus().getValue())
                .addValue("batch", query.getBatch())
                .addValue("creator", query.getCreator())
                .addValue("before", query.getBefore() == null ? null : Timestamp.from(query.getBefore()))
                .addValue("after", query.getAfter() == null ? null : Timestamp.from(query.getAfter()))
                .addValue("limit", query.getLimit() == null ? Integer.MAX_VALUE : query.getLimit());
    }
}
