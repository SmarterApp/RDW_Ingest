package org.opentestsystem.rdw.ingest.impsvc.auth;

import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.utils.Grant;
import org.opentestsystem.rdw.utils.TenancyChain;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;
import org.springframework.security.oauth2.provider.token.AccessTokenConverter;
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;

/**
 * A {@link AccessTokenConverter} that is aware of SBAC fields. Used by {@link ForgeRockTokenServices}.
 * Uses the {@link AuthorityService} to convert tenancy chain grants to spring security authorities.
 * Note that the auth request will have the "expires_in" value offset from now as a request param;
 * this is used by {@link ExpiringAuthenticationCache}.
 *
 * @see SecurityConfigurer
 */
@Component
class SbacTokenConverter implements AccessTokenConverter {
    private static final String EXPIRES_IN = "expires_in";
    private static final int DEFAULT_EXPIRES_IN = 3600;

    private final AuthorityService authorityService;
    private final TenantProperties tenantProperties;

    @Autowired
    SbacTokenConverter(final AuthorityService authorityService, final TenantProperties tenantProperties) {
        this.authorityService = authorityService;
        this.tenantProperties = tenantProperties;
    }

    @Override
    public Map<String, ?> convertAccessToken(final OAuth2AccessToken token, final OAuth2Authentication authentication) {
        // this method will only be called in response to GET check_token and
        // some JWT handling neither of which is supported
        throw new UnsupportedOperationException();
    }

    @Override
    public OAuth2AccessToken extractAccessToken(final String value, final Map<String, ?> map) {
        // this method will only be called in response to GET check_token which isn't supported
        throw new UnsupportedOperationException();
    }

    @Override
    public OAuth2Authentication extractAuthentication(final Map<String, ?> map) {
        final String username = (String) map.get("mail");
        final List<GrantedAuthority> authorities = newArrayList();
        final Authentication authentication;
        if (username == null || username.equals("")) {
            authentication = null;
        } else {
            // reduce the tenancy chain to just those roles that matter to ingest
            // (this is required because some tenancy chains are VERY long and irrelevant)
            TenancyChain tenancyChain = TenancyChain.fromString((String) map.get("sbacTenancyChain"))
                    .filter(grant -> Authorities.IngestRoles.contains(grant.getRole()));

            // further reduce the tenancy chain to grants for known tenants (states)
            tenancyChain = tenancyChain.filter(grant -> grant.getStateId() == null ||
                    tenantProperties.findTenantById(grant.getStateId()).isPresent());

            // find the first tenant in the chain and further reduce the chain to those
            // grants that match that tenant (or are client level)
            final Optional<String> tenant = tenancyChain.getGrants().stream()
                    .map(Grant::getStateId)
                    .filter(StringUtils::isNotBlank)
                    .findFirst();
            if (tenant.isPresent()) {
                tenancyChain = tenancyChain.filter(grant -> grant.getStateId() == null ||
                        tenant.get().equalsIgnoreCase(grant.getStateId()));
            }

            // if the tenancy chain is empty at this point, then the user is not authenticated
            // otherwise, set authorities and permissions based on reduced tenancy chain
            if (tenancyChain.isEmpty()) {
                authentication = null;
            } else {
                TenantContextHolder.setTenantId(tenant.orElse(null));

                authorities.addAll(authorityService.getAuthorities(tenancyChain));
                final SbacUser user = SbacUser.builderExt()
                        .username(username)
                        .authorities(newArrayList(authorities))
                        .uid((String) map.get("uid"))
                        .sbacUuid((String) map.get("sbacUUID"))
                        .tenantId(tenant.orElse(null))
                        .tenancyChain(tenancyChain)
                        .permissions(authorityService.getPermissions(tenancyChain))
                        .build();

                TenantContextHolder.clear();

                authentication = new PreAuthenticatedAuthenticationToken(user, null, authorities);
            }
        }

        final Map<String, String> params = newHashMap();
        params.put(GRANT_TYPE, (String) map.get(GRANT_TYPE));
        params.put(EXPIRES_IN, extractExpirationAsTime(map).toString());
        final OAuth2Request request = new OAuth2Request(params, null, authorities, true, extractScope(map), null, null, null, null);

        return new OAuth2Authentication(request, authentication);
    }

    private static Set<String> extractScope(final Map<String, ?> map) {
        return map.containsKey(SCOPE) ? newHashSet((List<String>) map.get(SCOPE)) : null;
    }

    private static Long extractExpirationAsTime(final Map<String, ?> map) {
        final int expiresInSeconds = map.containsKey(EXPIRES_IN) ? (Integer) map.get(EXPIRES_IN) : DEFAULT_EXPIRES_IN;
        return System.currentTimeMillis() + 1000 * expiresInSeconds;
    }
}
