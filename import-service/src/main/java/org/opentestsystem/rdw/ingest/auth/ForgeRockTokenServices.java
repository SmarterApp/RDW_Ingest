package org.opentestsystem.rdw.ingest.auth;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.ForwardingCache;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.ImmutableMap;
import com.google.common.util.concurrent.UncheckedExecutionException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.authentication.AuthenticationServiceException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.common.exceptions.InvalidTokenException;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.AccessTokenConverter;
import org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestOperations;
import org.springframework.web.client.RestTemplate;

import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

import static com.google.common.collect.Maps.newHashMap;
import static org.springframework.security.oauth2.common.OAuth2AccessToken.ACCESS_TOKEN;
import static org.springframework.security.oauth2.common.OAuth2AccessToken.EXPIRES_IN;

/**
 * An implementation of {@link ResourceServerTokenServices} backed by ForgeRock's OpenAM, which doesn't provide
 * the POST /oauth2/check_token end-point. Instead it has GET /oauth2/tokeninfo. And it doesn't require client info.
 *
 * @see SecurityConfigurer
 * @see SbacTokenConverter
 */
public class ForgeRockTokenServices implements ResourceServerTokenServices {
    private static final Logger logger = LoggerFactory.getLogger(ForgeRockTokenServices.class);

    private String tokenInfoUrl;
    private RestOperations restTemplate;
    private final AccessTokenConverter tokenConverter;
    private final LoadingCache<String, OAuth2Authentication> cache;

    public ForgeRockTokenServices() {
        restTemplate = new RestTemplate();
        tokenConverter = new SbacTokenConverter();
        cache = new ExpiringAuthenticationCache();
    }

    public void setRestTemplate(final RestOperations restTemplate) {
        this.restTemplate = restTemplate;
    }

    public void setTokenInfoUrl(final String tokenInfoUrl) {
        this.tokenInfoUrl = tokenInfoUrl;
    }

    @Override
    public OAuth2Authentication loadAuthentication(final String accessToken) throws AuthenticationException, InvalidTokenException {
        try {
            return cache.get(accessToken);
        } catch (final ExecutionException | UncheckedExecutionException e) {
            // propagate the cause if we can, otherwise wrap in generic auth exception
            throw e.getCause() instanceof RuntimeException ? (RuntimeException)e.getCause()
                    : new AuthenticationServiceException(e.getMessage());
        }
    }

    @Override
    public OAuth2AccessToken readAccessToken(final String accessToken) {
        return tokenConverter.extractAccessToken(accessToken, getTokenInfo(accessToken));
    }

    private Map<String, Object> getTokenInfo(final String token) {
        final Map<String,String> params = newHashMap();
        params.put(ACCESS_TOKEN, token);
        final Map result;
        try {
            result = restTemplate.getForObject(tokenInfoUrl, Map.class, params);
        } catch (final RestClientException e) {
            logger.debug("getTokenInfo exception: {}", e.getMessage());
            throw new InvalidTokenException(token + ": " + e.getMessage());
        }

        if (result.containsKey("error")) {
            logger.debug("getTokenInfo returned error: {}", result.get("error"));
            throw new InvalidTokenException(token + ": " + result.get("error"));
        }

        return (Map<String, Object>) result;
    }

    /**
     * Wrap a LoadingCache to invalidate any entries where the expires_in value has passed.
     * This requires that the loader set the "expires_in" request parameter in the auth request.
     *
     * @see SbacTokenConverter
     */
    private class ExpiringAuthenticationCache
            extends ForwardingCache<String, OAuth2Authentication>
            implements LoadingCache<String, OAuth2Authentication> {

        private final LoadingCache<String, OAuth2Authentication> delegate;

        ExpiringAuthenticationCache() {
            delegate = CacheBuilder.newBuilder()
                    .maximumSize(100)
                    .expireAfterWrite(15, TimeUnit.MINUTES)
                    .build(new CacheLoader<String, OAuth2Authentication>() {
                        @Override
                        public OAuth2Authentication load(final String key) throws Exception {
                            return tokenConverter.extractAuthentication(getTokenInfo(key));
                        }
                    });
        }

        @Override
        protected Cache<String, OAuth2Authentication> delegate() {
            return delegate;
        }

        @Override
        public OAuth2Authentication get(final String key) throws ExecutionException {
            final String now = Long.toString(System.currentTimeMillis());
            final OAuth2Authentication authentication = delegate.get(key);
            if (authentication.getOAuth2Request().getRequestParameters().get(EXPIRES_IN).compareTo(now) > 0) {
                return authentication;
            }
            // token has probably expired, so invalidate to force a reload
            delegate.invalidate(key);
            return delegate.get(key);
        }

        @Override
        public OAuth2Authentication getUnchecked(final String key) {
            return delegate.getUnchecked(key);
        }

        @Override
        public ImmutableMap<String, OAuth2Authentication> getAll(final Iterable<? extends String> keys) throws ExecutionException {
            return delegate.getAll(keys);
        }

        @Override
        public OAuth2Authentication apply(final String key) {
            return delegate.apply(key);
        }

        @Override
        public void refresh(final String key) {
            delegate.refresh(key);
        }
    }
}
