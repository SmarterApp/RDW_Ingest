package org.opentestsystem.rdw.ingest.auth;

import org.opentestsystem.rdw.utils.TenancyChain;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;
import org.springframework.security.oauth2.provider.token.AccessTokenConverter;
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;

import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.ingest.auth.SecurityConfigurer.DataLoadAuthority;

/**
 * A {@link AccessTokenConverter} that is aware of SBAC fields. Used by {@link ForgeRockTokenServices}.
 * Note that the auth request will have the "expires_in" value offset from now as a request param;
 * this is used by {@link ForgeRockTokenServices.ExpiringAuthenticationCache}.
 */
public class SbacTokenConverter implements AccessTokenConverter {
    private static final Logger logger = LoggerFactory.getLogger(SbacTokenConverter.class);

    private static final String EXPIRES_IN = "expires_in";

    @Override
    public Map<String, ?> convertAccessToken(final OAuth2AccessToken token, final OAuth2Authentication authentication) {
        // this method will only be called in response to GET check_token and
        // some JWT handling neither of which is supported
        throw new UnsupportedOperationException();
    }

    @Override
    public OAuth2AccessToken extractAccessToken(final String value, final Map<String, ?> map) {
        // this method will only be called in response to GET check_token which isn't supported
        throw new UnsupportedOperationException();
    }

    @Override
    public OAuth2Authentication extractAuthentication(final Map<String, ?> map) {
        final String username = (String) map.get("mail");
        final TenancyChain tenancyChain = TenancyChain.fromString((String) map.get("sbacTenancyChain"));
        final List<SimpleGrantedAuthority> authorities = newArrayList();
        if (tenancyChain.hasRole(DataLoadAuthority)) {
            authorities.add(new SimpleGrantedAuthority(DataLoadAuthority));
        } else {
            logger.info("User {} doesn't have data load authority: {}", username, tenancyChain.toString());
        }
        final SbacUser user = SbacUser.builder()
                .username(username)
                .authorities(newArrayList(authorities))
                .uid((String) map.get("uid"))
                .sbacUuid((String) map.get("sbacUUID"))
                .tenancyChain(tenancyChain)
                .build();
        final Authentication authentication = new PreAuthenticatedAuthenticationToken(user, null, authorities);

        final Map<String, String> params = newHashMap();
        params.put(GRANT_TYPE, (String) map.get(GRANT_TYPE));
        params.put(EXPIRES_IN, extractExpirationAsTime(map).toString());
        final OAuth2Request request = new OAuth2Request(params, null, authorities, true, extractScope(map), null, null, null, null);

        return new OAuth2Authentication(request, authentication);
    }

    private static Set<String> extractScope(final Map<String, ?> map) {
        return map.containsKey(SCOPE) ? newHashSet((List<String>) map.get(SCOPE)) : null;
    }

    private static Long extractExpirationAsTime(final Map<String, ?> map) {
        return System.currentTimeMillis() + 1000 * (map.containsKey(EXPIRES_IN) ? (Integer) map.get(EXPIRES_IN) : 3600);
    }
}
