package org.opentestsystem.rdw.ingest.auth;

import com.google.common.collect.ImmutableSet;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.opentestsystem.rdw.security.service.PermissionServiceException;
import org.opentestsystem.rdw.utils.Grant;
import org.opentestsystem.rdw.utils.TenancyChain;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static org.opentestsystem.rdw.ingest.auth.SecurityConfigurer.permissionToAuthorityName;
import static org.opentestsystem.rdw.ingest.auth.SecurityConfigurer.roleToAuthorityName;
import static org.springframework.util.StringUtils.hasText;

/**
 * This service is responsible for converting tenancy chain grants to spring authorities.
 */
@Service
class DefaultAuthorityService implements AuthorityService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAuthorityService.class);

    private final PermissionService permissionService;
    private final String client;
    private final String state;

    @Autowired
    public DefaultAuthorityService(final PermissionService permissionService,
                                   final @Value("${app.client}") String client,
                                   final @Value("${app.state.code}") String state) {
        this.permissionService = permissionService;
        this.client = client;
        this.state = state;
    }

    /**
     * Extract roles from tenancy chain, convert to permissions and create granted authorities using
     * default mappers that apply prefixes "ROLE_"/"PERM_" and create a {@link SimpleGrantedAuthority}.
     *
     * @param tenancyChain tenancy chain with grants
     * @return set of authorities granted by the tenancy chain
     * @see DefaultAuthorityService#getAuthorities(Collection, Function, Function)
     */
    public Set<GrantedAuthority> getAuthorities(final TenancyChain tenancyChain) {
        return getAuthorities(tenancyChain.getGrants(), simpleRoleAuthorityMapper, simplePermissionAuthorityMapper);
    }

    /**
     * Extract roles from grants, convert to permissions and create granted authorities using
     * the provided mappers. Only roles and permissions associated with this component are
     * converted, other roles/permissions in the grants are ignored.
     *
     * @param grants grants to convert to authorities
     * @param roleMapper function to convert role string to granted authority
     * @param permissionMapper function to convert permission string to granted authority
     * @return set of authorities granted by the grants
     * @see DefaultAuthorityService#getAuthorities(TenancyChain)
     */
    public Set<GrantedAuthority> getAuthorities(final Collection<Grant> grants,
                                                final Function<String, ? extends GrantedAuthority> roleMapper,
                                                final Function<String, ? extends GrantedAuthority> permissionMapper) {
        final ImmutableSet.Builder<GrantedAuthority> authorities = ImmutableSet.builder();

        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();
        for (final Grant grant : grants) {
            // skip grants that don't match client and state
            if ((hasText(client) && hasText(grant.getClientId()) && !client.equalsIgnoreCase(grant.getClientId()))
             || (hasText(state) && hasText(grant.getStateId()) && !state.equalsIgnoreCase(grant.getStateId()))) {
                logger.debug("Skipping grant for other client/state {}", grant.toString());
                continue;
            }

            if (permissionsByRole.containsKey(grant.getRole())) {
                authorities.add(roleMapper.apply(grant.getRole()));
                for (final String permission : permissionsByRole.get(grant.getRole())) {
                    authorities.add(permissionMapper.apply(permission));
                }
            }
        }

        return authorities.build();
    }

    /**
     * A role mapper that prepends "ROLE_" and creates a {@link SimpleGrantedAuthority}
     */
    public static Function<String, SimpleGrantedAuthority> simpleRoleAuthorityMapper =
            role -> new SimpleGrantedAuthority(roleToAuthorityName(role));

    /**
     * A permission mapper that prepends "PERM_" and creates a {@link SimpleGrantedAuthority}
     */
    public static Function<String, SimpleGrantedAuthority> simplePermissionAuthorityMapper =
            permission -> new SimpleGrantedAuthority(permissionToAuthorityName(permission));


    private Map<String, Collection<String>> getPermissionsByRole() {
        try {
            return permissionService.getPermissionsByRole();
        } catch (final PermissionServiceException exception) {
            throw new RuntimeException("Failed to get permissions", exception);
        }
    }
}
