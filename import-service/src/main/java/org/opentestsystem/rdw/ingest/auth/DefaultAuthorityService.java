package org.opentestsystem.rdw.ingest.auth;

import com.google.common.collect.ImmutableSet;
import org.opentestsystem.rdw.security.Permission;
import org.opentestsystem.rdw.security.PermissionScope;
import org.opentestsystem.rdw.security.service.PermissionService;
import org.opentestsystem.rdw.security.service.PermissionServiceException;
import org.opentestsystem.rdw.utils.Grant;
import org.opentestsystem.rdw.utils.TenancyChain;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.auth.Authorities.permissionToAuthorityName;
import static org.opentestsystem.rdw.ingest.auth.Authorities.roleToAuthorityName;
import static org.springframework.util.StringUtils.hasText;

/**
 * This service is responsible for converting tenancy chain grants to spring authorities.
 * TODO - unit tests
 */
@Service
class DefaultAuthorityService implements AuthorityService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAuthorityService.class);

    private final PermissionService permissionService;
    private final String client;
    private final String state;

    @Autowired
    public DefaultAuthorityService(final PermissionService permissionService,
                                   final @Value("${app.client:}") String client,
                                   final @Value("${app.state.code}") String state) {
        this.permissionService = permissionService;
        this.client = client;
        this.state = state;
    }

    @Override
    public Set<GrantedAuthority> getAuthorities(final TenancyChain tenancyChain) {
        final ImmutableSet.Builder<GrantedAuthority> authorities = ImmutableSet.builder();

        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();
        for (final Grant grant : getGrants(tenancyChain)) {
            authorities.add(simpleRoleAuthorityMapper.apply(grant.getRole()));
            for (final String permission : permissionsByRole.get(grant.getRole())) {
                authorities.add(simplePermissionAuthorityMapper.apply(permission));
            }
        }

        return authorities.build();
    }

    @Override
    public Set<Permission> getPermissions(final TenancyChain tenancyChain) {
        final Map<String, PermissionScope.Builder> builders = newHashMap();

        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();
        for (final Grant grant : getGrants(tenancyChain)) {
            // TODO - should we stick role into set as well? don't think it is needed/expected

            for (final String permission : permissionsByRole.get(grant.getRole())) {
                final PermissionScope.Builder builder = builders.computeIfAbsent(permission, p -> PermissionScope.builder());

                switch(grant.getLevel()) {
                    case CLIENT:
                    case STATE:
                        builder.statewide(true);
                        break;
                    // TODO - deal with all organization levels, not just client/state
                    // TODO   need an organization repository
                    default:
                        break;
                }
            }
        }

        return builders.entrySet().stream()
                .filter(entry -> entry.getValue().isValid())
                .map(entry -> new Permission(entry.getKey(), entry.getValue().build()))
                .collect(toImmutableSet());
    }

    @Override
    public List<Grant> getGrants(final TenancyChain tenancyChain) {
        final List<Grant> grants = newArrayList();

        final Map<String, Collection<String>> permissionsByRole = getPermissionsByRole();
        for (final Grant grant : tenancyChain.getGrants()) {
            // skip grants that don't match client and state
            if ((hasText(client) && hasText(grant.getClientId()) && !client.equalsIgnoreCase(grant.getClientId()))
             || (hasText(state) && hasText(grant.getStateId()) && !state.equalsIgnoreCase(grant.getStateId()))) {
                logger.debug("Skipping grant for other client/state {}", grant.toString());
                continue;
            }

            if (permissionsByRole.containsKey(grant.getRole())) {
                grants.add(grant);
            }
        }

        return grants;
    }

    /**
     * A role mapper that prepends "ROLE_" and creates a {@link SimpleGrantedAuthority}
     */
    private static final Function<String, SimpleGrantedAuthority> simpleRoleAuthorityMapper =
            role -> new SimpleGrantedAuthority(roleToAuthorityName(role));

    /**
     * A permission mapper that prepends "PERM_" and creates a {@link SimpleGrantedAuthority}
     */
    private static final Function<String, SimpleGrantedAuthority> simplePermissionAuthorityMapper =
            permission -> new SimpleGrantedAuthority(permissionToAuthorityName(permission));

    private Map<String, Collection<String>> getPermissionsByRole() {
        try {
            return permissionService.getPermissionsByRole();
        } catch (final PermissionServiceException exception) {
            throw new RuntimeException("Failed to get permissions", exception);
        }
    }
}
