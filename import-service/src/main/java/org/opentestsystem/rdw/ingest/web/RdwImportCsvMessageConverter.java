package org.opentestsystem.rdw.ingest.web;

import org.opentestsystem.rdw.ingest.common.model.RdwImportContent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.AbstractHttpMessageConverter;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.stereotype.Component;
import org.supercsv.cellprocessor.CellProcessorAdaptor;
import org.supercsv.cellprocessor.ift.CellProcessor;
import org.supercsv.io.CsvBeanWriter;
import org.supercsv.io.ICsvBeanWriter;
import org.supercsv.prefs.CsvPreference;
import org.supercsv.util.CsvContext;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.text.MessageFormat;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.Date;

@Component
public class RdwImportCsvMessageConverter extends AbstractHttpMessageConverter<RdwImportReconciliation> {
    private static final Logger logger = LoggerFactory.getLogger(RdwImportCsvMessageConverter.class);
    private static final MediaType MEDIA_TYPE = new MediaType("text", "csv", Charset.forName("utf-8"));

    private static final String[] DefaultHeaders = new String[]{"student_id", "asmt_guid", "date_taken"};
    private static final String[] DefaultFields = new String[]{"studentId", "assessmentNaturalId", "completedAt"};

    public RdwImportCsvMessageConverter() {
        super(MEDIA_TYPE);
    }

    @Override
    protected boolean supports(Class<?> clazz) {
        return RdwImportReconciliation.class.equals(clazz);
    }

    @Override
    protected RdwImportReconciliation readInternal(Class<? extends RdwImportReconciliation> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {
        return null;
    }

    @Override
    protected void writeInternal(RdwImportReconciliation rdwImportCsv, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
        outputMessage.getHeaders().setContentType(MEDIA_TYPE);

        String contentDisposition = MessageFormat.format("attachment; filename=\"rdw_import_{0}.csv\"", new SimpleDateFormat("yyyy-MM-dd").format(new Date()));
        outputMessage.getHeaders().set("Content-Disposition", contentDisposition);

        OutputStream bodyStream = outputMessage.getBody();

        try (ICsvBeanWriter csvWriter = new CsvBeanWriter(new OutputStreamWriter(bodyStream), CsvPreference.STANDARD_PREFERENCE)) {

            csvWriter.writeHeader(DefaultHeaders);
            CellProcessor[] processors = getProcessors();

            for (final RdwImportContent rdwImport : rdwImportCsv.getRdwImports()) {
                csvWriter.write(rdwImport, DefaultFields, processors);
            }

        } catch (Exception e) {
            logger.error("Error creating Rdw Import Reconciliation CSV report.", e);
        }
    }

    private static CellProcessor[] getProcessors() {
        return new CellProcessor[]{
                null,
                null,
                new ParseInstant()
        };
    }

    private static class ParseInstant extends CellProcessorAdaptor {

        public ParseInstant() {
            super();
        }

        public ParseInstant(CellProcessor next) {
            super(next);
        }

        @Override
        public Object execute(Object value, CsvContext context) {
            validateInputNotNull(value, context);

            Instant instant = (Instant) value;
            DateTimeFormatter formatter = DateTimeFormatter
                    .ofPattern("yyyyMMdd")
                    .withZone(ZoneOffset.UTC);

            String output = formatter.format(instant);
            return output;
        }
    }
}
