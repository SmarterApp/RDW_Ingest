package org.opentestsystem.rdw.ingest.status;

import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.status.AbstractStatusIndicator;
import org.opentestsystem.rdw.common.status.DiagnosticLevel;
import org.opentestsystem.rdw.common.status.Rating;
import org.opentestsystem.rdw.common.status.Status;
import org.opentestsystem.rdw.common.status.StatusIndicator;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.model.RdwImport;
import org.opentestsystem.rdw.ingest.repository.RdwImportRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;

/**
 * A {@link StatusIndicator} for database status.
 * <p>
 * Slightly different than web diagnostic spec this add "databaseOperations",
 * each being a Status with "schema", "type" (READ/WRITE), and "responseTime".
 * </p>
 */
@Component
public class DatabaseStatusIndicator extends AbstractStatusIndicator {

    private final RdwImportRepository repository;
    private final ArchiveService archiveService;

    @Autowired
    public DatabaseStatusIndicator(final RdwImportRepository repository,
                                   final ArchiveService archiveService) {
        this.repository = repository;
        this.archiveService = archiveService;
    }

    @Override
    public String name() {
        return "database";
    }

    @Override
    protected boolean doLevelCheck(final int level) {
        return DiagnosticLevel.ReadDatabase.isLessThanOrEqualTo(level);
    }

    @Override
    protected void doStatusCheck(final Status.Builder builder, final int level) {
        final List<Status> databaseOperations = newArrayList();
        databaseOperations.addAll(doImportStatusCheck(level));
        databaseOperations.addAll(doArchiveStatusCheck(level));
        builder.detail("databaseOperations", databaseOperations);
        builder.worstRating(databaseOperations);
    }

    private List<Status> doImportStatusCheck(final int level) {
        final List<Status> ops = newArrayList();

        // import, READ
        if (DiagnosticLevel.ReadDatabase.isLessThanOrEqualTo(level)) {
            final Status.Builder opBuilder = Status.builder().detail("schema", "import").detail("type", "READ");
            final List<ImportStatus> importStatuses = responseTime(opBuilder, 50, repository::findAllStatuses);
            if (importStatuses.size() != ImportStatus.values().length) {
                opBuilder.rating(Rating.Warning);
                opBuilder.detail("error", "import_status table not loaded properly");
            }
            ops.add(opBuilder.build());
        }

        // import, WRITE
        if (DiagnosticLevel.WriteDatabase.isLessThanOrEqualTo(level)) {
            final Status.Builder opBuilder = Status.builder().detail("schema", "import").detail("type", "WRITE");
            final RdwImport rdwImport = responseTime(opBuilder, 200, () ->
                    repository.create(RdwImport.builder()
                            .content(ImportContent.PROBE)
                            .contentType("text/plain+probe")
                            .digest("probe")
                            .status(ImportStatus.INVALID)
                            .build()));
            if (rdwImport.getId() == null) {
                opBuilder.rating(Rating.Warning);
            } else {
                repository.delete(rdwImport.getId());
            }
            ops.add(opBuilder.build());
        }

        return ops;
    }

    private List<Status> doArchiveStatusCheck(final int level) {
        final List<Status> ops = newArrayList();

        final String location = "status";
        final byte[] content = "status check".getBytes();

        // no matter what we have to write a file to the archive because we need to read something
        // and if level >= 4, we want to report on the performance of that write
        final Status.Builder opWrite = Status.builder().detail("schema", "archive").detail("type", "WRITE");
        responseTime(opWrite, 400, () -> {
            archiveService.writeResource(location, content, null);
            return null;
        });

        final Status.Builder opRead = Status.builder().detail("schema", "archive").detail("type", "READ");
        final byte[] response = responseTime(opRead, 80, () -> archiveService.readResource(location));
        if (!Arrays.equals(content, response)) {
            opRead.rating(Rating.Failed);
        }
        ops.add(opRead.build());

        if (DiagnosticLevel.WriteDatabase.isLessThanOrEqualTo(level)) {
            ops.add(opWrite.build());
        }

        return ops;
    }
}
