package org.opentestsystem.rdw.ingest.tasking.service.impl;

import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.opentestsystem.rdw.ingest.tasking.repository.ReportRepository;
import org.opentestsystem.rdw.ingest.tasking.service.ReconciliationService;
import org.opentestsystem.rdw.ingest.tasking.service.ReportSender;
import org.opentestsystem.rdw.ingest.tasking.ReconciliationReportConfiguration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.Date;

import static com.google.common.base.Preconditions.checkArgument;

/**
 * Default implementation of the {@link ReconciliationService}.<br/>
 * This is not an autowired component since it should only be created if there is a configured task that uses it.
 *
 * @see ReconciliationReportConfiguration
 */
public class DefaultReconciliationService implements ReconciliationService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultReconciliationService.class);
    private final ReportRepository reportRepository;

    public DefaultReconciliationService(final ReportRepository reportRepository) {
        this.reportRepository = reportRepository;
    }

    @Override
    public void sendReport(final RdwImportQuery query, final Iterable<ReportSender> senders) {
        // because it is a configuration option (and not user input), assume query is set properly
        checkArgument(!query.isEmpty(), "Report query must not be empty");

        if (!anyImportActivity(query)) {
            logger.info("No import activity, skipping reconciliation report");
            return;
        }

        // create named file in temporary directory
        final Path file;
        try {
            final String filename = "reconciliation_" + new SimpleDateFormat("yyyyMMddHHmmss").format(new Date()) + ".csv";
            final Path dir = Files.createTempDirectory("report");
            file = dir.resolve(filename);
        } catch (final IOException e) {
            throw new RuntimeException("Failed to create temporary file for reconciliation report", e);
        }

        // write report to file
        try (final FileOutputStream fos = new FileOutputStream(file.toFile())) {
            reportRepository.writeReconciliationReport(query, fos);
        } catch (final IOException e) {
            cleanupReportFile(file);
            throw new RuntimeException("Failed to write reconciliation report", e);
        }

        // send the report file
        final File report = file.toFile();
        final long reportLength = report.length();
        final String reportName = file.getFileName().toString();
        for (final ReportSender sender : senders) {
            try (final FileInputStream fis = new FileInputStream(report)) {
                sender.sendReport(fis, reportLength, reportName);
            } catch (final Exception e) {
                logger.warn("Failed to send reconciliation report to {}: {}", sender.toString(), e.getMessage());
            }
        }
        cleanupReportFile(file);
    }

    /**
     * Determine if there as been any import activity by querying for all import records
     * that match the query parameters while ignoring any status criterium.
     *
     * @param query query for generating report
     * @return true if any import records exist matching query while ignoring status
     */
    private boolean anyImportActivity(final RdwImportQuery query) {
        return reportRepository.countExamImports(query.copy().status((String) null).build()) > 0;
    }

    private void cleanupReportFile(final Path file) {
        try {
            Files.delete(file);
            Files.delete(file.getParent());
        } catch (final IOException e) {
            logger.warn("Failed to clean up report file {}: {}", file.toString(), e.getMessage());
        }
    }
}
