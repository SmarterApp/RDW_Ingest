package org.opentestsystem.rdw.ingest.tasking;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.endpoint.AbstractEndpoint;
import org.springframework.boot.actuate.endpoint.mvc.MvcEndpoint;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cloud.endpoint.GenericPostableMvcEndpoint;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.scheduling.annotation.Scheduled;

import java.util.List;
import org.opentestsystem.rdw.archive.ArchivePropertiesTenant;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.archive.LocalArchiveService;
import org.opentestsystem.rdw.archive.S3ArchiveService;
import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.opentestsystem.rdw.ingest.tasking.repository.ReportRepository;
import org.opentestsystem.rdw.ingest.tasking.service.ReconciliationService;
import org.opentestsystem.rdw.ingest.tasking.service.ReportSender;
import org.opentestsystem.rdw.ingest.tasking.service.impl.ArchiveReportSender;
import org.opentestsystem.rdw.ingest.tasking.service.impl.DefaultReconciliationService;
import org.opentestsystem.rdw.ingest.tasking.service.impl.FtpReportSender;
import org.opentestsystem.rdw.ingest.tasking.service.impl.LoggingReportSender;
import org.opentestsystem.rdw.ingest.tasking.status.ReconciliationReportStatusIndicator;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.multitenant.TenantProperties;

import static com.google.common.collect.Lists.newArrayList;

/**
 * Configuration and implementation for reconciliation report task.<br/>
 * The goal is to avoid creating the scheduled bean and any of its helpers if the system
 * is configured to not run the task. So there is a bit of deep knowledge in here.<br/>
 * To enable this task, the following properties must be defined:<ul>
 *     <li>task.send-reconciliation-report.cron</li>
 *     <li>task.send-reconciliation-report.query</li>
 * </ul>
 * One or more senders should be configured under task.send-reconciliation-report.senders.
 * For example, to enable FTP, the following properties must be defined:<ul>
 *     <li>type:ftp</li>
 *     <li>server</li>
 *     <li>username</li>
 *     <li>password</li>
 * </ul>
 * To properly disable this task, remove task.send-reconciliation-report.
 * <p>
 * This is a hack to make this work iff there is exactly one tenant in the system.
 * TODO - make this properly multi-tenant aware.
 * </p>
 */
@Configuration
@ConditionalOnProperty(prefix = "task.send-reconciliation-report", name = { "cron", "query" })
public class ReconciliationReportConfiguration {
    private static final Logger logger = LoggerFactory.getLogger(ReconciliationReportConfiguration.class);

    @Bean
    public ReconciliationReportTask reconciliationReportTask(
            final TenantProperties tenantProperties,
            final ReconciliationService reconciliationService,
            final List<ReportSender> reportSenders,
            @Value("${task.send-reconciliation-report.query}") final String query) {

        final String tenantId = TenantConfiguration.extractSingleTenantIdOrThrow(tenantProperties);
        return new ReconciliationReportTask(tenantId, reconciliationService, reportSenders, query);
    }

    @Bean
    public ReconciliationService reconciliationService(final ReportRepository reportRepository) {
        return new DefaultReconciliationService(reportRepository);
    }

    /**
     * This configuration can have multiple {@link ReportSender}'s. To support the polymorphism of
     * report senders while keeping the yml readable, this factory parses the senders' properties
     * and instantiates the appropriate objects.
     *
     * @param env environment
     * @return list of report senders
     */
    @Bean
    public List<ReportSender> reportSender(final Environment env) {
        final List<ReportSender> senders = newArrayList();
        for (int i = 0; ; ++i) {
            final String senderPrefix = "task.send-reconciliation-report.senders["+i+"].";
            final String type = env.getProperty(senderPrefix + "type");
            if (type == null) break;

            switch (type.toLowerCase()) {
                case "archive": {
                    // generate ArchiveProperties from configuration
                    try {
                        // TODO - probably a more elegant way to do this, deal with it when truly multi-tenant
                        final ArchivePropertiesTenant archiveProperties = new ArchivePropertiesTenant();
                        archiveProperties.setPathPrefix(null);
                        archiveProperties.setUriRoot(env.getRequiredProperty(senderPrefix + "uri-root"));

                        final ArchiveService archiveService;
                        if (archiveProperties.isConfiguredS3()) {
                            archiveProperties.setS3AccessKey(env.getRequiredProperty(senderPrefix + "s3-access-key"));
                            archiveProperties.setS3SecretKey(env.getRequiredProperty(senderPrefix + "s3-secret-key"));
                            archiveProperties.setS3RegionStatic(env.getRequiredProperty(senderPrefix + "s3-region-static"));
                            archiveProperties.setS3Sse(env.getProperty(senderPrefix + "s3-ss3"));
                            archiveService = new S3ArchiveService(archiveProperties);
                        } else {
                            archiveService = new LocalArchiveService(archiveProperties);
                        }

                        senders.add(new ArchiveReportSender(archiveService));

                    } catch (final IllegalArgumentException e) {
                        logger.warn("Ignoring archive report sender: {}", e.getMessage());
                    }
                    break;
                }

                case "ftp": {
                    senders.add(new FtpReportSender(env.getRequiredProperty(senderPrefix + "server"),
                            env.getRequiredProperty(senderPrefix + "username"),
                            env.getRequiredProperty(senderPrefix + "password")));
                    break;
                }

                case "log":
                case "logging": {
                    senders.add(new LoggingReportSender());
                    break;
                }

                default: {
                    logger.info("Ignoring unknown report sender type [{}]", type);
                    break;
                }

            }
        }
        return senders;
    }

    @Bean
    public ReconciliationReportStatusIndicator reconciliationReportStatusIndicator(final ReportRepository reportRepository,
                                                                                   final List<ReportSender> reportSenders) {
        return new ReconciliationReportStatusIndicator(reportRepository, reportSenders);
    }

    /**
     * Bean for actuator end-point to manually trigger reconciliation report task.
     * It supports POST instead of GET, e.g.:<pre>
     * curl -X POST http://localhost:8008/reconciliationReport
     * </pre>
     *
     * @param tenantProperties tenant properties
     * @param reconciliationService service
     * @param reportSenders senders
     * @param query import query
     * @return reconciliation report end-point
     */
    @Bean
    public MvcEndpoint reconciliationReportEndpoint(
            final TenantProperties tenantProperties,
            final ReconciliationService reconciliationService,
            final List<ReportSender> reportSenders,
            @Value("${task.send-reconciliation-report.query}") final String query) {

        final String tenantId = TenantConfiguration.extractSingleTenantIdOrThrow(tenantProperties);
        return new GenericPostableMvcEndpoint(
                new ReconciliationReportEndpoint(tenantId, reconciliationService, reportSenders, query));
    }


    static class ReconciliationReportTask {
        private final String tenantId;
        private final ReconciliationService reconciliationService;
        private final List<ReportSender> senders;
        private final String query;

        ReconciliationReportTask(final String tenantId,
                                 final ReconciliationService reconciliationService,
                                 final List<ReportSender> senders,
                                 final String query) {
            this.tenantId = tenantId;
            this.reconciliationService = reconciliationService;
            this.senders = senders;
            this.query = query;
            // fast fail on bad query
            RdwImportQuery.builder().params(query).build();
        }

        @Scheduled(cron = "${task.send-reconciliation-report.cron}", zone = "GMT")
        public void sendReconciliationReport() {
            logger.info("Scheduled task triggered: Send Reconciliation Report");
            try {
                TenantContextHolder.setTenantId(tenantId);
                reconciliationService.sendReport(RdwImportQuery.builder().params(query).build(), senders);
                logger.debug("Scheduled task completed: Send Reconciliation Report");
            } catch (final Exception e) {
                logger.warn("Error sending reconciliation report", e);
            }
        }
    }

    static class ReconciliationReportEndpoint extends AbstractEndpoint<Boolean> {
        private final String tenantId;
        private final ReconciliationService reconciliationService;
        private final List<ReportSender> senders;
        private final String query;

        ReconciliationReportEndpoint(final String tenantId,
                                     final ReconciliationService reconciliationService,
                                     final List<ReportSender> senders,
                                     final String query) {
            super("reconciliationReport", true, true);
            this.tenantId = tenantId;
            this.reconciliationService = reconciliationService;
            this.senders = senders;
            this.query = query;
            // fast fail on bad query
            RdwImportQuery.builder().params(query).build();
        }

        @Override
        public Boolean invoke() {
            logger.info("Manual task triggered: Send Reconciliation Report");
            try {
                TenantContextHolder.setTenantId(tenantId);
                reconciliationService.sendReport(RdwImportQuery.builder().params(query).build(), senders);
                return true;
            } catch (final Exception e) {
                logger.warn("Error sending reconciliation report", e);
                return false;
            }
        }
    }
}
