package org.opentestsystem.rdw.ingest.tasking;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;

import java.util.List;
import org.opentestsystem.rdw.archive.ArchiveProperties;
import org.opentestsystem.rdw.archive.ArchiveServiceDecorator;
import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.opentestsystem.rdw.ingest.tasking.service.ReconciliationService;
import org.opentestsystem.rdw.ingest.tasking.service.ReportSender;
import org.opentestsystem.rdw.ingest.tasking.service.impl.ArchiveReportSender;
import org.opentestsystem.rdw.ingest.tasking.service.impl.LoggingReportSender;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.task.SendReconciliationReportPropertiesRoot;
import org.opentestsystem.rdw.multitenant.task.SendReconciliationReportPropertiesTenant;

import static com.google.common.collect.Lists.newArrayList;

/**
 * Scheduled task to run the reconciliation report for all tenants that have it configured.
 */
public class ReconciliationReportTask {
    private static final Logger logger = LoggerFactory.getLogger(ReconciliationReportTask.class);

    private final TenantProperties tenantProperties;
    private final ReconciliationService reconciliationService;
    private final SendReconciliationReportPropertiesRoot reconciliationReportPropertiesRoot;

    ReconciliationReportTask(final TenantProperties tenantProperties,
                             final ReconciliationService reconciliationService,
                             final SendReconciliationReportPropertiesRoot reconciliationReportPropertiesRoot) {
        this.tenantProperties = tenantProperties;
        this.reconciliationService = reconciliationService;
        this.reconciliationReportPropertiesRoot = reconciliationReportPropertiesRoot;

        // if no tenants are configured for this task, log a warning
        if (reconciliationReportPropertiesRoot.getTenants().isEmpty()) {
            logger.warn("ReconciliationReport task enabled but there are no tenants are configured for it");
        }
    }

    @Scheduled(cron = "${task.send-reconciliation-report.cron}", zone = "GMT")
    public void sendReconciliationReport() {
        doReport(tenantProperties, reconciliationReportPropertiesRoot, reconciliationService, null);
    }

    /**
     * Helper to do the actual report work; used by task and end-point (to avoid code duplication).
     *
     * @param tenantProperties all known tenants (and sandboxes)
     * @param reconciliationReportPropertiesRoot used to find tenants with this task configured
     * @param reconciliationService service for generating and sending the report
     * @param tenantId (optional) tenant id to restrict report to just one tenant
     * @return informational text
     */
    public static String doReport(final TenantProperties tenantProperties,
                                  final SendReconciliationReportPropertiesRoot reconciliationReportPropertiesRoot,
                                  final ReconciliationService reconciliationService,
                                  final String tenantId) {
        if (tenantId == null) {
            // send for all tenants
            final StringBuilder builder = new StringBuilder("Task triggered: SendReconciliationReport");
            for (final Tenant tenant : tenantProperties.getTenants().values()) {
                final SendReconciliationReportPropertiesTenant properties =
                        reconciliationReportPropertiesRoot.getTenants().get(tenant.getKey());
                if (tenant.isSandbox() || properties == null) {
                    continue;
                }
                builder.append("\n").append(doReport(reconciliationService, properties, tenant));
            }
            return builder.toString();
        } else {
            final Tenant tenant = tenantProperties.findTenantById(tenantId).orElse(null);
            if (tenant == null) {
                return "Ignoring SendReconciliationReport request for unknown tenant " + tenantId;
            } else if (tenant.isSandbox()) {
                return "Ignoring SendReconciliationReport request for sandbox " + tenantId;
            } else if (!reconciliationReportPropertiesRoot.getTenants().containsKey(tenant.getKey())) {
                return "Ignoring SendReconciliationReport request because task is not configured for tenant " + tenantId;
            }
            final SendReconciliationReportPropertiesTenant properties =
                    reconciliationReportPropertiesRoot.getTenants().get(tenant.getKey());
            return doReport(reconciliationService, properties, tenant);
        }
    }

    private static String doReport(final ReconciliationService reconciliationService,
                                   final SendReconciliationReportPropertiesTenant properties,
                                   final Tenant tenant) {
        // it would be more efficient to create these once upfront but for now ...
        final List<ReportSender> senders = propertiesToReportSenders(properties);

        TenantContextHolder.setTenantId(tenant.getId());
        try {
            final RdwImportQuery query = RdwImportQuery.builder().params(properties.getQuery()).build();
            reconciliationService.sendReport(query, senders);
            return "UpdateOrganizations succeeded for tenant " + tenant.getId();
        } catch (final Exception e) {
            logger.warn("Failed to update organizations for {}: {}", tenant.toString(), e.getMessage());
            return "Failed UpdateOrganizations for tenant " + tenant.getId();
        } finally {
            TenantContextHolder.clear();
        }
    }

    /**
     * A helper to shim reconciliation report properties to appropriate report senders.
     * Used by the task the status indicator (to avoid code duplication).
     *
     * @param properties reconciliation report properties (should be an interface but this is what we have)
     * @return list of senders; may be empty, won't be null
     */
    public static List<ReportSender> propertiesToReportSenders(final SendReconciliationReportPropertiesTenant properties) {
        // it would be more efficient to create these once upfront but for now ...
        final List<ReportSender> senders = newArrayList();
        if (properties.isLog()) {
            senders.add(new LoggingReportSender());
        }
        for (final ArchiveProperties archive : properties.getArchives()) {
            senders.add(new ArchiveReportSender(new ArchiveServiceDecorator(archive)));
        }
        return senders;
    }
}
