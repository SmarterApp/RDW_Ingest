package org.opentestsystem.rdw.ingest.tasking;

import org.opentestsystem.rdw.archive.ArchiveProperties;
import org.opentestsystem.rdw.archive.ArchiveServiceDecorator;
import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.opentestsystem.rdw.ingest.tasking.service.ReconciliationService;
import org.opentestsystem.rdw.ingest.tasking.service.ReportSender;
import org.opentestsystem.rdw.ingest.tasking.service.impl.ArchiveReportSender;
import org.opentestsystem.rdw.ingest.tasking.service.impl.LoggingReportSender;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.multitenant.TenantProperties;
import org.opentestsystem.rdw.multitenant.task.SendReconciliationReportPropertiesResolver;
import org.opentestsystem.rdw.multitenant.task.SendReconciliationReportPropertiesRoot;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;

import java.util.List;

import static com.google.common.collect.Lists.newArrayList;

/**
 * Scheduled task to run the reconciliation report for all tenants that have it configured.
 */
public class ReconciliationReportTask {
    private static final Logger logger = LoggerFactory.getLogger(ReconciliationReportTask.class);

    private final TenantProperties tenantProperties;
    private final ReconciliationService reconciliationService;
    private final SendReconciliationReportPropertiesResolver reconciliationReportPropertiesResolver;

    ReconciliationReportTask(final TenantProperties tenantProperties,
                             final ReconciliationService reconciliationService,
                             final SendReconciliationReportPropertiesResolver reconciliationReportPropertiesResolver) {
        this.tenantProperties = tenantProperties;
        this.reconciliationService = reconciliationService;
        this.reconciliationReportPropertiesResolver = reconciliationReportPropertiesResolver;

        // if no tenants are configured for this task, log a warning
        if (reconciliationReportPropertiesResolver.getPropertiesRoot().getTenants().isEmpty()) {
            logger.warn("ReconciliationReport task enabled but there are no tenants are configured for it");
        }
    }

    @Scheduled(cron = "${task.send-reconciliation-report.cron}", zone = "GMT")
    public void sendReconciliationReport() {
        doReport(tenantProperties, reconciliationReportPropertiesResolver, reconciliationService, null);
    }

    /**
     * Helper to do the actual report work; used by task and end-point (to avoid code duplication).
     *
     * @param tenantProperties                       all known tenants (and sandboxes)
     * @param reconciliationReportPropertiesResolver used to find tenants with this task configured
     * @param reconciliationService                  service for generating and sending the report
     * @param tenantId                               (optional) tenant id to restrict report to just one tenant
     * @return informational text
     */
    public static String doReport(final TenantProperties tenantProperties,
                                  final SendReconciliationReportPropertiesResolver reconciliationReportPropertiesResolver,
                                  final ReconciliationService reconciliationService,
                                  final String tenantId) {
        if (tenantId == null) {
            // send for all tenants
            final StringBuilder builder = new StringBuilder("Task triggered: SendReconciliationReport");
            for (final Tenant tenant : tenantProperties.getTenants().values()) {
                final SendReconciliationReportPropertiesRoot propertiesRoot =
                        reconciliationReportPropertiesResolver.getPropertiesRoot();
                if (tenant.isSandbox() || !propertiesRoot.getTenants().containsKey(tenant.getKey())) {
                    continue;
                }
                builder.append("\n").append(doReport(reconciliationService, reconciliationReportPropertiesResolver, tenant));
            }
            return builder.toString();
        } else {
            final Tenant tenant = tenantProperties.findTenantById(tenantId).orElse(null);
            if (tenant == null) {
                return "Ignoring SendReconciliationReport request for unknown tenant " + tenantId;
            } else if (tenant.isSandbox()) {
                return "Ignoring SendReconciliationReport request for sandbox " + tenantId;
            } else if (!reconciliationReportPropertiesResolver.getPropertiesRoot().getTenants().containsKey(tenant.getKey())) {
                return "Ignoring SendReconciliationReport request because task is not configured for tenant " + tenantId;
            }
            return doReport(reconciliationService, reconciliationReportPropertiesResolver, tenant);
        }
    }

    private static String doReport(final ReconciliationService reconciliationService,
                                   final SendReconciliationReportPropertiesResolver reconciliationReportPropertiesResolver,
                                   final Tenant tenant) {
        // it would be more efficient to create these once upfront but for now ...
        final List<ReportSender> senders = propertiesToReportSenders(reconciliationReportPropertiesResolver, tenant);

        TenantContextHolder.setTenantId(tenant.getId());
        try {
            logger.info("Starting ReconciliationReport task for tenant {}", tenant.getId());
            final RdwImportQuery query = RdwImportQuery.builder().params(reconciliationReportPropertiesResolver.getQuery()).build();
            reconciliationService.sendReport(query, senders);
            return "ReconciliationReport succeeded for tenant " + tenant.getId();
        } catch (final Exception e) {
            logger.warn("Failed to send reconciliation report for {}: {}", tenant.toString(), e.getMessage());
            return "Failed ReconciliationReport for tenant " + tenant.getId();
        } finally {
            TenantContextHolder.clear();
        }
    }

    /**
     * A helper to shim reconciliation report properties to appropriate report senders.
     * Used by the task and the status indicator (to avoid code duplication).
     *
     * @param reconciliationReportPropertiesResolver reconciliation report properties (should be an interface but this is what we have)
     * @return list of senders; may be empty, won't be null
     */
    public static List<ReportSender> propertiesToReportSenders(final SendReconciliationReportPropertiesResolver reconciliationReportPropertiesResolver,
                                                               Tenant tenant) {
        // it would be more efficient to create these once upfront but for now ...
        TenantContextHolder.setTenantId(tenant.getId());
        final List<ReportSender> senders = newArrayList();
        if (reconciliationReportPropertiesResolver.isLog()) {
            senders.add(new LoggingReportSender());
        }
        for (final ArchiveProperties archive : reconciliationReportPropertiesResolver.getArchives()) {
            senders.add(new ArchiveReportSender(new ArchiveServiceDecorator(archive)));
        }
        TenantContextHolder.clear();
        return senders;
    }
}
