package org.opentestsystem.rdw.ingest.tasking.service.impl;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.opentestsystem.rdw.ingest.tasking.model.ReconciliationReport;
import org.opentestsystem.rdw.ingest.tasking.repository.ReportRepository;
import org.opentestsystem.rdw.ingest.tasking.service.ReconciliationService;
import org.opentestsystem.rdw.ingest.tasking.task.ReconciliationReportProperties;
import org.springframework.mail.javamail.JavaMailSender;

import javax.mail.MessagingException;
import javax.mail.Session;
import javax.mail.internet.MimeMessage;
import java.util.Properties;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;

public class ReconciliationServiceTest {
    private ReconciliationService reconciliationService;
    private ReportRepository reportRepository;
    private JavaMailSender javaMailSender;
    private MimeMessage messageSpy;
    private String querySpy;

    @Before
    public void setup() {
        reportRepository = mock(ReportRepository.class);
        javaMailSender = mock(JavaMailSender.class);

        messageSpy = new MimeMessage(Session.getInstance(new Properties()));
        when(javaMailSender.createMimeMessage()).thenReturn(messageSpy);
        when(reportRepository.countExamImports(any(RdwImportQuery.class))).thenReturn(5L);
        when(reportRepository.getReconciliationReport(isA(RdwImportQuery.class))).thenAnswer(invocation -> {
                    querySpy = ((RdwImportQuery)invocation.getArguments()[0]).asParamString();
                    return new ReconciliationReport("sample.csv", new byte[20]);
                }
        );

        reconciliationService = new DefaultReconciliationService(reportRepository, javaMailSender);
    }

    @Test
    public void itShouldSendReportWithConfiguredValues() throws MessagingException {
        final ReconciliationReportProperties props = createProperties();

        reconciliationService.sendReport(props);

        assertThat(messageSpy.getAllRecipients()[0].toString()).isEqualTo(props.getEmail().getTo()[0]);
        assertThat(messageSpy.getFrom()[0].toString()).isEqualTo(props.getEmail().getFrom());
        assertThat(messageSpy.getSubject()).isEqualTo(props.getEmail().getSubject());
        assertThat(querySpy).isEqualTo(props.getQuery());
    }

    @Test
    public void itShouldNotSendAReportIfThereHaveBeenNoImports() {
        when(reportRepository.countExamImports(any(RdwImportQuery.class))).thenReturn(0L);

        reconciliationService.sendReport(createProperties());

        verify(reportRepository).countExamImports(any(RdwImportQuery.class));
        verifyNoMoreInteractions(reportRepository, javaMailSender);
    }

    private ReconciliationReportProperties createProperties() {
        final String from = "ops@example.com";
        final String[] to = new String[]{"customer@example.com"};
        final String subject = "This is the subject";
        final String message = "This is the body";
        final String query = "status=PROCESSED";

        final ReconciliationReportProperties.Email email = new ReconciliationReportProperties.Email();
        email.setFrom(from);
        email.setTo(to);
        email.setSubject(subject);
        email.setMessage(message);

        final ReconciliationReportProperties props = new ReconciliationReportProperties();
        props.setEmail(email);
        props.setQuery(query);

        return props;
    }
}
