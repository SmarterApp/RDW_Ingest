package org.opentestsystem.rdw.ingest.tasking.service.impl;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.model.RdwImportQuery;
import org.opentestsystem.rdw.ingest.tasking.repository.ReportRepository;
import org.opentestsystem.rdw.ingest.tasking.service.ReconciliationService;
import org.opentestsystem.rdw.ingest.tasking.service.ReportSender;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.startsWith;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

public class ReconciliationServiceTest {
    private ReconciliationService reconciliationService;
    private ReportRepository reportRepository;

    private final RdwImportQuery query = RdwImportQuery.builder().status(ImportStatus.PROCESSED).build();
    private final byte[] report = "Sample Report".getBytes();

    @Before
    public void setup() {
        reportRepository = mock(ReportRepository.class);
        when(reportRepository.exists(any(RdwImportQuery.class))).thenReturn(true);
        doAnswer(invocation -> {
            ((OutputStream) invocation.getArguments()[1]).write(report);
            return null;
        }).when(reportRepository).writeReconciliationReport(any(RdwImportQuery.class), any(OutputStream.class));

        reconciliationService = new DefaultReconciliationService(reportRepository);
    }

    @Test
    public void itShouldSendReport() {
        final ReportSender sender = mock(ReportSender.class);
        doAnswer(invocation -> {
            final byte[] recv = new byte[100];
            assertThat(((InputStream)invocation.getArguments()[0]).read(recv)).isEqualTo(report.length);
            assertThat(recv).startsWith(report);
            return null;
        }).when(sender).sendReport(any(InputStream.class), anyLong(), anyString());

        reconciliationService.sendReport(query, newArrayList(sender));
        verify(sender).sendReport(any(InputStream.class), eq((long)report.length), startsWith("reconciliation"));
    }

    @Test
    public void itShouldNotSendAReportIfThereHaveBeenNoImports() {
        when(reportRepository.exists(any(RdwImportQuery.class))).thenReturn(false);
        final ReportSender sender = mock(ReportSender.class);

        reconciliationService.sendReport(query, newArrayList(sender));
        verify(reportRepository).exists(any(RdwImportQuery.class));
        verifyZeroInteractions(sender);
    }

    @Test(expected = IllegalArgumentException.class)
    public void itRequiresANonEmptyQuery() {
        reconciliationService.sendReport(RdwImportQuery.builder().build(), newArrayList(mock(ReportSender.class)));
    }

    @Test(expected = RuntimeException.class)
    public void itShouldPropagateRepositoryIOException() {
        doThrow(IOException.class).when(reportRepository).writeReconciliationReport(any(RdwImportQuery.class), any(OutputStream.class));
        final ReportSender sender = mock(ReportSender.class);
        reconciliationService.sendReport(query, newArrayList(sender));
        verifyZeroInteractions(sender);
    }

    @Test
    public void itShouldIgnoreIndividualSenderExceptions() {
        final ReportSender sender1 = mock(ReportSender.class);
        final ReportSender sender2 = mock(ReportSender.class);
        doThrow(RuntimeException.class).when(sender1).sendReport(any(InputStream.class), anyLong(), anyString());
        reconciliationService.sendReport(query, newArrayList(sender1, sender2));
        verify(sender2).sendReport(any(InputStream.class), anyLong(), anyString());
    }
}
