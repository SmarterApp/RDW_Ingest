package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Accommodation;
import org.opentestsystem.rdw.ingest.processor.repository.AccommodationTranslationRepository;
import org.opentestsystem.rdw.ingest.processor.repository.LanguageRepository;
import org.opentestsystem.rdw.ingest.processor.service.AccessibilityProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_DATA;
import static org.opentestsystem.rdw.ingest.common.model.ImportStatus.BAD_FORMAT;

/**
 * DefaultAccessibilityProcessor
 */
@Service
public class DefaultAccessibilityProcessor implements AccessibilityProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultAccessibilityProcessor.class);

    private final AccommodationTranslationRepository translationRepository;
    private final LanguageRepository languageRepository;

    @Autowired
    public DefaultAccessibilityProcessor(AccommodationTranslationRepository translationRepository,
                                         LanguageRepository languageRepository) {
        this.translationRepository = translationRepository;
        this.languageRepository = languageRepository;
    }

    /**
     * @param accessibilityConfig An Accessibility Config File as referenced at https://github.com/SmarterApp/AccessibilityAccommodationConfigurations
     * @throws ImportException if any errors are encountered during processing
     */
    @Override
    public void process(String accessibilityConfig) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper( errorCollector );
        List<Accommodation> accommodations = new ArrayList<>();

        try {
            validate(accessibilityConfig);
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(new ByteArrayInputStream(accessibilityConfig.getBytes(StandardCharsets.UTF_8)));
            //Document doc = builder.parse("https://github.com/SmarterApp/AccessibilityAccommodationConfigurations/raw/RDW_DataWarehouse/AccessibilityConfig.xml");
            XPathFactory xPathfactory = XPathFactory.newInstance();
            XPath xpath = xPathfactory.newXPath();

            XPathExpression accessibilityGroup = xpath.compile("/Accessibility/MasterResourceFamily/*[starts-with(ResourceType,'Accom')]/Selection");
            XPathExpression accessibilityCode = xpath.compile("Code");
            XPathExpression accessibilityLanguageGroups = xpath.compile("Text");
            XPathExpression accessibilityLanguage = xpath.compile("Language");
            XPathExpression accessibilityLabel = xpath.compile("Label");
            NodeList accGroup = (NodeList) accessibilityGroup.evaluate(doc, XPathConstants.NODESET);

            for (int i =0; i< accGroup.getLength(); i++) {
                Node code = (Node) accessibilityCode.evaluate(accGroup.item(i), XPathConstants.NODE);
                NodeList langGroup = (NodeList) accessibilityLanguageGroups.evaluate(accGroup.item(i), XPathConstants.NODESET);
                for(int j = 0; j < langGroup.getLength(); j++) {
                    Node lang = (Node) accessibilityLanguage.evaluate(langGroup.item(j), XPathConstants.NODE);
                    Node label = (Node) accessibilityLabel.evaluate(langGroup.item(j), XPathConstants.NODE);
                    accommodations.add(Accommodation.builder()
                            .code(code.getTextContent())
                            .addTranslation(languageRepository.findIdByCode(lang.getTextContent()),label.getTextContent())
                            .build());
                    logger.debug(code.getTextContent() + " = [" + lang.getTextContent() + "] " + label.getTextContent());
                }
            }
            //Insert into database
            translationRepository.batchCreate(accommodations);

            logger.info(String.format("Processed %d codes", accommodations.size()));
        } catch (final IllegalArgumentException e) {
            throw new ImportException(BAD_DATA, e.toString());
        } catch (final IOException ioe) {
            throw new ImportException(BAD_FORMAT, ioe.toString());
        } catch (final Exception e){}
    }

    private boolean validate(String accessibilityConfig) {

// or File schemaFile = new File("/location/to/xsd"); // etc.

        Source xmlFile = new StreamSource(new StringReader(accessibilityConfig));
        SchemaFactory schemaFactory = SchemaFactory
                .newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
        try {
            Schema schema = schemaFactory.newSchema(this.getClass().getResource("/AccessibilityConfig.xsd"));
            Validator validator = schema.newValidator();

            validator.validate(xmlFile);
            return true;

        } catch (SAXException e) {
            System.out.println(xmlFile.getSystemId() + " is NOT valid reason:" + e);
        } catch (IOException e) {}
        return false;
    }
}
