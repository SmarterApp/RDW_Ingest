package org.opentestsystem.rdw.migrate.common;

import org.junit.Before;
import org.junit.Test;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecutionException;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.messaging.support.GenericMessage;
import org.springframework.messaging.support.MessageBuilder;

import java.time.Instant;
import java.util.Collections;
import java.util.Map;
import java.util.Optional;
import org.opentestsystem.rdw.migrate.common.repository.MigrateRepository;
import org.opentestsystem.rdw.migrate.common.repository.WarehouseImportRepository;
import org.opentestsystem.rdw.multitenant.TenantIdResolver;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.isA;
import static org.mockito.ArgumentMatchers.same;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.never;

public class TenantAwareMigrateJobHandlerTest {
    // Class under test
    private TenantAwareMigrateJobHandler handler;

    private SubscribableChannel migrateJobInput;
    private MessageChannel migrateJobOutput;
    private MigrateJobProcessor migrateJobProcessor;

    private final Instant firstAt = Instant.parse("2017-05-18T19:06:34.966Z");
    private final Instant lastAt = Instant.parse("2017-05-20T19:06:34.966Z");
    private final Instant nextLastAt = Instant.parse("2017-05-20T21:06:34.966Z");
    private final int batchSize = 10;

    private MigrateRepository migrateRepository;
    private WarehouseImportRepository importRepository;
    private TenantIdResolver tenantIdResolver;
    private JobLauncher jobLauncher;
    private Job job;
    private Message message;

    @Before
    public void setUp() {
        migrateRepository = mock(MigrateRepository.class);
        when(migrateRepository.findLastStatus()).thenReturn(MigrateStatus.COMPLETED);
        when(migrateRepository.findLastMigratedAt()).thenReturn(null);

        // simulate two chunks of work
        importRepository = mock(WarehouseImportRepository.class);
        when(importRepository.getMigrateImportValues(null, batchSize))
                .thenReturn(MigrateImportValues.builder().firstAt(firstAt).lastAt(lastAt).migrateCodes(true).importCount(batchSize).build())
                .thenReturn(MigrateImportValues.builder().firstAt(lastAt).lastAt(nextLastAt).migrateCodes(true).importCount(batchSize).build())
                .thenReturn(MigrateImportValues.builder().firstAt(null).lastAt(null).migrateCodes(true).importCount(0).build());

        tenantIdResolver = mock(TenantIdResolver.class);
        when(tenantIdResolver.getTenantId()).thenReturn(Optional.of("CA"));

        jobLauncher = mock(JobLauncher.class);
        job = mock(Job.class);

        migrateJobInput = mock(SubscribableChannel.class);
        migrateJobOutput = mock(MessageChannel.class);

        migrateJobProcessor = new MigrateJobProcessor() {

            @Override
            public SubscribableChannel migrateJobInput() {
                return migrateJobInput;
            }

            @Override
            public MessageChannel migrateJobOutput() {
                return migrateJobOutput;
            }
        };

        message = mock(Message.class);

        handler = new TenantAwareMigrateJobHandler(
                migrateRepository,
                importRepository,
                tenantIdResolver,
                jobLauncher,
                job,
                batchSize,
                migrateJobProcessor);
    }

    @Test
    public void itShouldQueueMigrateJob() {
        handler.run("CA");
        verify(migrateJobOutput).send(isA(GenericMessage.class));
    }

    @Test
    public void isShouldLaunchJobInLoop() throws JobExecutionException {
        handler.migrateJobDispatcher(message);

        verify(importRepository, times(3)).getMigrateImportValues(null, batchSize);
        verify(jobLauncher, times(2)).run(same(job), any(JobParameters.class));
    }

    @Test
    public void isShouldDoOneMoreWhenNotFullBatchFoundOnSubsequentCall() throws JobExecutionException {
        when(importRepository.getMigrateImportValues(null, batchSize))
                .thenReturn(MigrateImportValues.builder().firstAt(firstAt).lastAt(lastAt).migrateCodes(true).importCount(batchSize).build())
                .thenReturn(MigrateImportValues.builder().firstAt(lastAt).lastAt(nextLastAt).migrateCodes(true).importCount(batchSize - 1).build())
                .thenReturn(MigrateImportValues.builder().firstAt(lastAt).lastAt(nextLastAt).migrateCodes(true).importCount(1).build());

        handler.migrateJobDispatcher(message);

        verify(importRepository, times(2)).getMigrateImportValues(null, batchSize);
        verify(jobLauncher, times(2)).run(same(job), any(JobParameters.class));
    }

    @Test
    public void isShouldHandleExceptionsInRepository() throws JobExecutionException {
        when(importRepository.getMigrateImportValues(null, batchSize)).thenThrow(new RuntimeException());

        handler.migrateJobDispatcher(message);

        verify(jobLauncher, never()).run(same(job), any(JobParameters.class));
    }

    @Test
    public void isShouldHandleExceptionsInJobAndStopTheLoop() throws JobExecutionException {
        when(jobLauncher.run(same(job), any(JobParameters.class))).thenThrow(new RuntimeException());

        handler.migrateJobDispatcher(message);

        verify(importRepository, times(1)).getMigrateImportValues(null, batchSize);
        verify(jobLauncher, times(1)).run(same(job), any(JobParameters.class));
    }

    @Test
    public void itShouldNotLaunchJobIfPaused() throws JobExecutionException {
        handler.setRunning(false);
        assertThat(handler.isRunning()).isFalse();

        handler.migrateJobDispatcher(message);
        verify(jobLauncher, never()).run(same(job), any(JobParameters.class));

        // and test that start gets it running again
        handler.setRunning(true);
        assertThat(handler.isRunning()).isTrue();
    }

    @Test
    public void itShouldNotLaunchJobIfDisabled() throws JobExecutionException {
        when(migrateRepository.findLastStatus())
                .thenReturn(MigrateStatus.FAILED)
                .thenReturn(MigrateStatus.ABANDONED);

        final Map<String, Object> properties = Collections.emptyMap();
        final Message<Map<String, Object>> message = MessageBuilder.withPayload(properties).build();

        handler.migrateJobDispatcher(message);

        assertThat(handler.isEnabled()).isFalse();
        verifyZeroInteractions(jobLauncher);

        // and test that it re-enables itself
        handler.migrateJobDispatcher(message);
        assertThat(handler.isEnabled()).isTrue();
    }

    @Test(expected = IllegalStateException.class)
    public void enableShouldThrowIfTenantIdNotSet() {
        when(tenantIdResolver.getTenantId()).thenReturn(Optional.empty());

        // note that run() will silently eat the exception, log a message
        handler.migrateJobDispatcher(message);

        // direct calls to setEnabled or isEnabled will fail however
        handler.isEnabled();
    }
}

