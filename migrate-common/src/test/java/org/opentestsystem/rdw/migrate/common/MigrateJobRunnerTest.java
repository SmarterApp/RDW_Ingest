package org.opentestsystem.rdw.migrate.common;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.migrate.common.repository.MigrateRepository;
import org.opentestsystem.rdw.migrate.common.repository.WarehouseImportRepository;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecutionException;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.launch.JobLauncher;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.same;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class MigrateJobRunnerTest {
    private final Instant firstAt = Instant.parse("2017-05-18T19:06:34.966Z");
    private final Instant lastAt = Instant.parse("2017-05-20T19:06:34.966Z");
    private final Instant nextLastAt = Instant.parse("2017-05-20T21:06:34.966Z");
    private final int batchSize = 10;

    private MigrateRepository migrateRepository;
    private WarehouseImportRepository importRepository;
    private JobLauncher jobLauncher;
    private Job job;
    private MigrateJobRunner reportingJobRunner;


    @Before
    public void setUp() {
        migrateRepository = mock(MigrateRepository.class);
        when(migrateRepository.findLastStatus()).thenReturn(MigrateStatus.COMPLETED);
        when(migrateRepository.findLastMigratedAt()).thenReturn(null);

        // simulate two chunks of work
        importRepository = mock(WarehouseImportRepository.class);
        when(importRepository.getMigrateImportValues(null, batchSize))
                .thenReturn(MigrateImportValues.builder().firstAt(firstAt).lastAt(lastAt).migrateCodes(true).importCount(batchSize).build())
                .thenReturn(MigrateImportValues.builder().firstAt(lastAt).lastAt(nextLastAt).migrateCodes(true).importCount(batchSize).build())
                .thenReturn(MigrateImportValues.builder().firstAt(null).lastAt(null).migrateCodes(true).importCount(0).build());

        jobLauncher = mock(JobLauncher.class);
        job = mock(Job.class);

        reportingJobRunner = new MigrateJobRunner(migrateRepository, importRepository, jobLauncher, job, batchSize);
    }

    @Test
    public void isShouldLaunchJobInLoop() throws JobExecutionException {
        reportingJobRunner.run();

        verify(importRepository, times(3)).getMigrateImportValues(null, batchSize);
        verify(jobLauncher, times(2)).run(same(job), any(JobParameters.class));
    }

    @Test
    public void isShouldDoOneMoreWhenNotFullBatchFoundOnSubsequentCall() throws JobExecutionException {
        when(importRepository.getMigrateImportValues(null, batchSize))
                .thenReturn(MigrateImportValues.builder().firstAt(firstAt).lastAt(lastAt).migrateCodes(true).importCount(batchSize).build())
                .thenReturn(MigrateImportValues.builder().firstAt(lastAt).lastAt(nextLastAt).migrateCodes(true).importCount(batchSize - 1).build())
                .thenReturn(MigrateImportValues.builder().firstAt(lastAt).lastAt(nextLastAt).migrateCodes(true).importCount(1).build());

        reportingJobRunner.run();

        verify(importRepository, times(2)).getMigrateImportValues(null, batchSize);
        verify(jobLauncher, times(2)).run(same(job), any(JobParameters.class));
    }

    @Test
    public void isShouldHandleExceptionsInRepository() throws JobExecutionException {
        when(importRepository.getMigrateImportValues(null, batchSize)).thenThrow(new RuntimeException());

        reportingJobRunner.run();
        verify(jobLauncher, never()).run(same(job), any(JobParameters.class));
    }

    @Test
    public void isShouldHandleExceptionsInJobAndStopTheLoop() throws JobExecutionException {
        when(jobLauncher.run(same(job), any(JobParameters.class))).thenThrow(new RuntimeException());

        reportingJobRunner.run();

        verify(importRepository, times(1)).getMigrateImportValues(null, batchSize);
        verify(jobLauncher, times(1)).run(same(job), any(JobParameters.class));
    }

    @Test
    public void itShouldNotLaunchJobIfPaused() throws JobExecutionException {
        reportingJobRunner.stop();
        assertThat(reportingJobRunner.isRunning()).isFalse();

        reportingJobRunner.run();
        verify(jobLauncher, never()).run(same(job), any(JobParameters.class));

        // and test that start gets it running again
        reportingJobRunner.start();
        assertThat(reportingJobRunner.isRunning()).isTrue();
    }

    @Test
    public void itShouldNotLaunchJobIfDisabled() throws JobExecutionException {
        when(migrateRepository.findLastStatus())
                .thenReturn(MigrateStatus.FAILED)
                .thenReturn(MigrateStatus.ABANDONED);

        reportingJobRunner.run();
        assertThat(reportingJobRunner.isEnabled()).isFalse();
        verify(jobLauncher, never()).run(same(job), any(JobParameters.class));

        // and test that it re-enables itself
        reportingJobRunner.run();
        assertThat(reportingJobRunner.isEnabled()).isTrue();
    }
}