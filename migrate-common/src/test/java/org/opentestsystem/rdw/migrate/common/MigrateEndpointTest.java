package org.opentestsystem.rdw.migrate.common;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;

import java.time.Instant;
import org.opentestsystem.rdw.migrate.common.repository.MigrateRepository;
import org.opentestsystem.rdw.multitenant.Tenant;
import org.opentestsystem.rdw.multitenant.TenantProperties;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class MigrateEndpointTest {

    private MigrateLifecycle jobRunner;
    private MigrateRepository repository;
    private MigrateEndpoint endpoint;

    @Before
    public void createEndpoint() {
        jobRunner = mock(MigrateLifecycle.class);
        repository = mock(MigrateRepository.class);

        final Tenant tenant = new Tenant("CA", "CA", "California");
        final TenantProperties tenantProperties = new TenantProperties();
        tenantProperties.setTenants(ImmutableMap.of(tenant.getId(), tenant));

        endpoint = new MigrateEndpoint(jobRunner, repository, tenantProperties);
    }

    @Test
    public void itShouldGetGoodMigrateInfo() {
        final Migrate lastMigrate = mock(Migrate.class);
        when(lastMigrate.getStatus()).thenReturn(MigrateStatus.COMPLETED);
        when(lastMigrate.getLastAt()).thenReturn(Instant.now());
        when(repository.findLast()).thenReturn(lastMigrate);

        when(jobRunner.isRunning()).thenReturn(true);
        when(jobRunner.isEnabled()).thenReturn(true);

        assertThat(endpoint.invoke())
                .contains("Migrate: running")
                .contains("CA: enabled")
                .contains("COMPLETED")
                .doesNotContain("Last successful");
    }

    @Test
    public void itShouldGetBadMigrateInfo() {
        final Migrate lastMigrate = mock(Migrate.class);
        when(lastMigrate.getStatus()).thenReturn(MigrateStatus.FAILED);
        when(lastMigrate.getLastAt()).thenReturn(Instant.now());
        when(repository.findLast()).thenReturn(lastMigrate);
        when(repository.findLastMigratedAt()).thenReturn(Instant.now());

        when(jobRunner.isRunning()).thenReturn(true);
        when(jobRunner.isEnabled()).thenReturn(false);

        assertThat(endpoint.invoke())
                .contains("Migrate: running")
                .contains("CA: disabled")
                .contains("FAILED")
                .contains("last successful");
    }

    @Test
    public void itShouldNotMigrateForUnknownTenant() {
        assertThat(endpoint.migrate("MI")).isEqualTo("Ignoring /migrate request for unknown tenant id MI");
    }

    @Test
    public void itShouldNotMigrateIfDisabled() {
        when(jobRunner.isEnabled()).thenReturn(false);
        assertThat(endpoint.migrate("CA")).isEqualTo("Ignoring /migrate request since migrate is disabled for tenant CA");
    }

    @Test
    public void itShouldNotMigrateIfPaused() {
        when(jobRunner.isEnabled()).thenReturn(true);
        when(jobRunner.isRunning()).thenReturn(false);
        assertThat(endpoint.migrate("CA")).isEqualTo("Ignoring /migrate request since migrate is not running");
    }

    @Test
    public void itShouldMigrate() throws InterruptedException {
        when(jobRunner.isEnabled()).thenReturn(true);
        when(jobRunner.isRunning()).thenReturn(true);
        assertThat(endpoint.migrate("CA")).isEqualTo("Migrate triggered by /migrate request for tenant CA");
        // yeah, this sucks; not sure what else to do that doesn't involve
        // modifying MigrateEndpoint to allow a test hook ...
        Thread.sleep(200);
        verify(jobRunner).run();
    }

    @Test
    public void itShouldNotEnableForUnknownTenant() {
        assertThat(endpoint.enable("MI")).isEqualTo("Ignoring /migrate/enable request for unknown tenant id MI");
    }

    @Test
    public void itShouldNotEnableIfEnabled() {
        when(jobRunner.isEnabled()).thenReturn(true);
        assertThat(endpoint.enable("CA")).isEqualTo("Ignoring /migrate/enable request since migrate is already enabled for tenant CA");
    }

    @Test
    public void itShouldNotEnableIfLastMigrateIsNotFailed() {
        when(jobRunner.isEnabled()).thenReturn(false);

        final Migrate lastMigrate = mock(Migrate.class);
        when(lastMigrate.getStatus()).thenReturn(MigrateStatus.COMPLETED);
        when(repository.findLast()).thenReturn(lastMigrate);

        assertThat(endpoint.enable("CA")).isEqualTo("Ignoring /migrate/enable request since last migrate is not FAILED for tenant CA");
    }

    @Test
    public void itShouldEnable() {
        when(jobRunner.isEnabled()).thenReturn(false);

        final Migrate lastMigrate = mock(Migrate.class);
        when(lastMigrate.getId()).thenReturn(42L);
        when(lastMigrate.getStatus()).thenReturn(MigrateStatus.FAILED);
        when(repository.findLast()).thenReturn(lastMigrate);

        assertThat(endpoint.enable("CA")).isEqualTo("Marking migrate 42 as ABANDONED for tenant CA");
        verify(repository).updateStatusById(42L, MigrateStatus.ABANDONED);
        verify(jobRunner).enable(true);
    }
}
