package org.opentestsystem.rdw.ingest.migrate.reporting.service;


import org.opentestsystem.rdw.ingest.migrate.reporting.MigrateBatchId;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.MigrateImportRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class DefaultNextJobService implements NextJobService {

    private static final Logger logger = LoggerFactory.getLogger(DefaultNextJobService.class);

    // todo: move this to properties.
    private static final Long BatchSizeLimit = 10L;

    private final MigrateImportRepository migrateImportRepository;

    public DefaultNextJobService(MigrateImportRepository migrateImportRepository) {
        this.migrateImportRepository = migrateImportRepository;
    }

    public Optional<MigrateBatchId> getNextJobImportId() {

        // If there are no imports there is no work to migrate.
        Optional<Long> max = migrateImportRepository.findMaxImportId();
        if (!max.isPresent()) {
            return Optional.empty();
        }

        // Get the last migrated import id.
        Optional<Long> last = migrateImportRepository.findLastMigratedImportId();

        if (last.isPresent()) {
            // If there is a last return the appropriate range based on batch size.
            return Optional.of(new MigrateBatchId(last.get() + 1,
                    (max.get() - last.get()) <= BatchSizeLimit ? max.get() : last.get() + BatchSizeLimit));
        } else {
            // If there has been no migration start with the first.
            Optional<Long> first = migrateImportRepository.findMinImportId();
            if (!first.isPresent()) {
                return Optional.empty();
            } else {
                return Optional.of(new MigrateBatchId(first.get(),
                        (max.get() - first.get()) < BatchSizeLimit ? max.get() : first.get() + (BatchSizeLimit - 1)));
            }
        }
    }

}
