package org.opentestsystem.rdw.ingest.migrate.reporting.service;


import org.opentestsystem.rdw.ingest.migrate.reporting.JobParams;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.ReportingMigrateRepository;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.WarehouseImportRepository;
import org.springframework.batch.core.JobParameter;
import org.springframework.batch.core.JobParameters;
import org.springframework.dao.DataRetrievalFailureException;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Optional;

import static com.google.common.collect.Maps.newHashMap;

/**
 *  Default implementation of NextJobParamService to find the first and last import ID's for a migrate batch.
 */
@Service
class DefaultNextJobParamService implements NextJobParamsService {

    private final WarehouseImportRepository warehouseImportRepository;
    private final ReportingMigrateRepository reportingMigrateRepository;

    DefaultNextJobParamService(final WarehouseImportRepository warehouseImportRepository,
                               final ReportingMigrateRepository reportingMigrateRepository) {
        this.warehouseImportRepository = warehouseImportRepository;
        this.reportingMigrateRepository = reportingMigrateRepository;
    }

    /**
     * getNextJobParams by querying {@link ReportingMigrateRepository} and {@link WarehouseImportRepository}.
     * <p>
     * <ul>
     *     <li>Checks reporting repository for last migrated import id.</li>
     *     <li>Checks warehouse repository for import id's not migrated.</li>
     *     <li>Accounts for first migration.</li>
     *     <li>Limits {@link JobParameters} lastImportId based of batchSize.</li>
     * </ul>
     * </p>
     *
     * @param batchSize the size of the migrate batch
     * @return optional of {@link JobParameters} for the migrate {@link org.springframework.batch.core.Job},
     *         empty when no work to do.
     * @throws org.springframework.dao.DataRetrievalFailureException when {@link WarehouseImportRepository} returns unexpected results.
     */
    public Optional<JobParameters> getNextJobParams(final int batchSize) {

        final Long last = reportingMigrateRepository.findLastMigratedImportId();

        if (last != null) {
            Optional<Long> maxFromLastMigrate = warehouseImportRepository.findMaxImportIdNotMigrated(last, batchSize);
            if (maxFromLastMigrate.isPresent()) {
                return createJobParams(batchSize, last + 1, maxFromLastMigrate.get());
            } else {
                return Optional.empty(); // Expected result when outstanding work is complete.
            }
        } else {
            Optional<Long> first = warehouseImportRepository.findMinImportId();
            if (!first.isPresent()) {
                return Optional.empty(); // If there are no migrate and no import records.
            } else {
                Optional<Long> maxFromImport = warehouseImportRepository.findMaxImportIdNotMigrated(first.get() - 1, batchSize);
                if (maxFromImport.isPresent()) {
                    return createJobParams(batchSize, first.get(), maxFromImport.get());
                } else {
                    throw new DataRetrievalFailureException("findMaxImportIdNotMigrated returned no results after returning findMinImportId");
                }
            }
        }
    }

    private Optional<JobParameters> createJobParams(final int batchSize, long firstImportId, long lastImportId) {
        final Map<String, JobParameter> jobParams = newHashMap();
        jobParams.put(JobParams.batchSize, new JobParameter((long) batchSize));
        //this is an identifying parameter for the job instance
        jobParams.put("jobIdentifier", new JobParameter(System.currentTimeMillis(), true));
        jobParams.put(JobParams.fistImportId, new JobParameter(firstImportId));
        jobParams.put(JobParams.lastImportId, new JobParameter(lastImportId));
        return Optional.of(new JobParameters(jobParams));
    }


}
