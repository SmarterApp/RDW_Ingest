package org.opentestsystem.rdw.ingest.migrate.reporting.repository.impl;

import org.opentestsystem.rdw.migrate.common.config.ReportingSystemProperties;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.SqlCopyWarehouseToStagingRepository;
import org.opentestsystem.rdw.ingest.migrate.reporting.step.SqlCopyStatements;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcOperations;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.core.SqlParameterValue;
import org.springframework.jdbc.core.SqlProvider;
import org.springframework.jdbc.core.StatementCreatorUtils;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.NamedParameterUtils;
import org.springframework.jdbc.core.namedparam.ParsedSql;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.JdbcUtils;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static org.springframework.jdbc.core.namedparam.NamedParameterBatchUpdateUtils.executeBatchUpdateWithNamedParameters;

/**
 * Jdbc implementation of {@link SqlCopyWarehouseToStagingRepository}.
 */
@Repository
class JdbcSqlCopyWarehouseToStagingRepository implements SqlCopyWarehouseToStagingRepository {
    private final NamedParameterJdbcTemplate reportingJdbcTemplate;
    private final NamedParameterJdbcTemplate warehouseJdbcTemplate;
    private final int streamingBatchSize;
    private final ReportingSystemProperties reportingSystemProperties;

    @Autowired
    public JdbcSqlCopyWarehouseToStagingRepository(final NamedParameterJdbcTemplate reportingJdbcTemplate,
                                                   final NamedParameterJdbcTemplate warehouseJdbcTemplate,
                                                   @Value("${migrate.batch.size:1000}") final int streamingBatchSize,
                                                   @Qualifier("reportingSystemPropertiesResolver") final ReportingSystemProperties reportingSystemProperties) {
        this.reportingJdbcTemplate = reportingJdbcTemplate;
        this.warehouseJdbcTemplate = warehouseJdbcTemplate;
        this.streamingBatchSize = streamingBatchSize;
        this.reportingSystemProperties = reportingSystemProperties;
    }

    @Override
    @Transactional
    public void execute(final List<SqlCopyStatements> copyStatementsList, final Instant firstAt, final Instant lastAt, final long migrateId) {
        execute(copyStatementsList, migrateId, createParameterSource()
                .addValue("first_at", Timestamp.from(firstAt))
                .addValue("last_at", Timestamp.from(lastAt)));
    }

    @Override
    @Transactional
    public void execute(final List<SqlCopyStatements> copyStatementsList) {
        execute(copyStatementsList, null, createParameterSource());
    }

    @Override
    @Transactional
    public void execute(final List<SqlCopyStatements> copyStatementsList,
                        final Long migrateId) {
        execute(copyStatementsList, migrateId, createParameterSource());
    }

    private void execute(final List<SqlCopyStatements> copyStatementsList,
                         final Long migrateId,
                         final MapSqlParameterSource queryParams) {
        // for whatever reason, the method we need is on JdbcTemplate so coerce what we have ...
        final JdbcTemplate jdbcTemplate = (JdbcTemplate)warehouseJdbcTemplate.getJdbcOperations();

        for (final SqlCopyStatements statements : copyStatementsList) {
            final StreamingStatementCreator reader = new StreamingStatementCreator(statements.getWarehouseRead(), queryParams);
            final StreamingBatchCopier copier = new StreamingBatchCopier(statements.getStagingInsert(), migrateId);

            jdbcTemplate.query(reader, reader, copier);
        }
    }

    /**
     * This class is responsible for reading a result set in chunks. For each chunk, it collects
     * the result set columns as parameters and does a batch update with them.
     */
    class StreamingBatchCopier implements ResultSetExtractor<Object> {
        private final ParsedSql parsedSql;
        private final Long migrateId;

        StreamingBatchCopier(final String rawSql, final Long migrateId) {
            this.parsedSql = NamedParameterUtils.parseSqlStatement(rawSql);
            this.migrateId = migrateId;
        }

        @Override
        public Object extractData(final ResultSet rs) throws SQLException, DataAccessException {
            final JdbcOperations jdbcOperations = reportingJdbcTemplate.getJdbcOperations();

            final String[] columnNames = readColumnNames(rs);

            final List<SqlParameterSource> batchParams = newArrayList();
            while (true) {
                batchParams.clear();
                for (int batch = 0; batch < streamingBatchSize && rs.next(); ++batch) {
                    final MapSqlParameterSource parameterSource = createParameterSource();
                    if (migrateId != null) {
                        parameterSource.addValue("migrate_id", migrateId);
                    }
                    for (int i = 1; i < columnNames.length; ++i) {
                        parameterSource.addValue(columnNames[i], JdbcUtils.getResultSetValue(rs, i));
                    }
                    batchParams.add(parameterSource);
                }
                if (batchParams.isEmpty()) break;

                executeBatchUpdateWithNamedParameters(parsedSql, batchParams.toArray(new SqlParameterSource[0]), jdbcOperations);
            }
            return null;
        }

        private String[] readColumnNames(final ResultSet rs) throws SQLException {
            final ResultSetMetaData rsmd = rs.getMetaData();
            final int columnCount = rsmd.getColumnCount();
            final String[] names = new String[columnCount+1];
            for (int i = 1; i <= columnCount; ++i) {
                names[i] = JdbcUtils.lookupColumnName(rsmd, i);
            }
            return names;
        }
    }

    /**
     * This class creates a streaming statement so that large result sets can be read in chunks to
     * avoid blowing heap. The logic is derived from code in NamedParamterJdbcTemplate.
     */
    static class StreamingStatementCreator implements PreparedStatementCreator, SqlProvider, PreparedStatementSetter {
        private final String sql;
        private final Object[] params;

        StreamingStatementCreator(final String rawSql, final SqlParameterSource paramSource) {
            final ParsedSql parsedSql = NamedParameterUtils.parseSqlStatement(rawSql);
            sql = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);
            final List<SqlParameter> sqlParams = NamedParameterUtils.buildSqlParameterList(parsedSql, paramSource);
            params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, sqlParams);
        }

        @Override
        public PreparedStatement createPreparedStatement(final Connection connection) throws SQLException {
            // this enables streaming results
            final PreparedStatement statement = connection.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
            statement.setFetchSize(Integer.MIN_VALUE);
            return statement;
        }

        @Override
        public String getSql() {
            return sql;
        }

        @Override
        public void setValues(final PreparedStatement ps) throws SQLException {
            // This was derived from PreparedStatementCreatorFactory#PreparedStatementCreatorImpl
            // but this can be much simpler because we have the SqlParameterValues and we don't
            // have to deal with different parameter types, collections, etc.
            int idx = 0;
            for (final Object o : params) {
                final SqlParameterValue param = (SqlParameterValue) o;
                StatementCreatorUtils.setParameterValue(ps, ++idx, param, param.getValue());
            }
        }
    }

    private MapSqlParameterSource createParameterSource() {
        return new MapSqlParameterSource("system_school_year", reportingSystemProperties.getSchoolYear());
    }
}
