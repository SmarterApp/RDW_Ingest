package org.opentestsystem.rdw.ingest.migrate.reporting.step;

import org.opentestsystem.rdw.ingest.common.model.ImportContent;
import org.opentestsystem.rdw.ingest.migrate.reporting.ExecutionParams;
import org.opentestsystem.rdw.ingest.migrate.reporting.JobParams;
import org.opentestsystem.rdw.ingest.migrate.reporting.Migrate;
import org.opentestsystem.rdw.ingest.migrate.reporting.MigrateBatch;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.WarehouseToStageRepository;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.List;

import static com.google.common.collect.Lists.newArrayList;

/**
 *  This step uses the {@link Migrate} param set by the {@link org.opentestsystem.rdw.ingest.migrate.reporting.MigrateJobExecutionListener}
 *  to query the warehouse.import table and determine the {@link ImportContent}.
 *  This is save for next steps in the {@link MigrateBatch} param.
 */
@Component
public class Warehouse extends StepTasklet {

    @Value("${sql.warehouseToStage.findMaxExamImportId}")
    private String findMaxExamImportId;

    private final WarehouseToStageRepository warehouseToStageRepository;

    public Warehouse(final WarehouseToStageRepository warehouseToStageRepository) {
        this.warehouseToStageRepository = warehouseToStageRepository;
    }

    @Override
    public RepeatStatus execute(final StepContribution contribution, final ChunkContext chunkContext) throws Exception {

        final Migrate migrate = (Migrate) chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext().get(ExecutionParams.migrate);
        final List<ImportContent> contentList = getContentInBatch(migrate);

        if ( contentList.isEmpty() ) {
            throw new UnsupportedOperationException("A job was started with no available ImportContent to process.");
        } else {
            setJobBatch(chunkContext, new MigrateBatch(migrate, contentList));
            return RepeatStatus.FINISHED;
        }
    }

    private List<ImportContent> getContentInBatch(final Migrate migrate) {

        List<Integer> contentNumberList = warehouseToStageRepository.findImportContentForBatch(migrate.getFirstImportId(), migrate.getLastImportId());

        // Build a list of enumerated import content in the batch.
        final List<ImportContent> contentList = newArrayList();
        for (Integer number : contentNumberList) {
            contentList.add(ImportContent.fromValue(number));
        }

        return contentList;
    }
}
