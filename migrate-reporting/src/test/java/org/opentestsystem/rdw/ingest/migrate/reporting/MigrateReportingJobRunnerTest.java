package org.opentestsystem.rdw.ingest.migrate.reporting;

import org.junit.Before;
import org.junit.Test;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.ReportingMigrateRepository;
import org.opentestsystem.rdw.ingest.migrate.reporting.service.NextJobParamsService;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecutionException;
import org.springframework.batch.core.JobParameter;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.launch.JobLauncher;

import java.util.Optional;

import static com.google.common.collect.Maps.newHashMap;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class MigrateReportingJobRunnerTest {
    private ReportingMigrateRepository migrateRepository;
    private JobLauncher jobLauncher;
    private Job job;
    private MigrateReportingJobRunner reportingJobRunner;
    private NextJobParamsService nextJobParamsService;
    private JobParameters jobParameters;

    @Before
    public void setUp() throws JobExecutionException {
        migrateRepository = mock(ReportingMigrateRepository.class);
        when(migrateRepository.findLastStatus()).thenReturn(MigrateStatus.COMPLETED);

        jobLauncher = mock(JobLauncher.class);
        job = mock(Job.class);
        nextJobParamsService = mock(NextJobParamsService.class);

        jobParameters = new JobParameters(newHashMap());
        jobParameters.getParameters().put("jobIdentifier", new JobParameter(System.currentTimeMillis(), true));

        final Answer<Optional<JobParameters>> answer = new Answer<Optional<JobParameters>>() {
            int numOfCalls = 0;

            public Optional<JobParameters> answer(final InvocationOnMock invocation) throws Throwable {
                if (numOfCalls > 1) return Optional.empty();

                numOfCalls++;
                jobParameters.getParameters().put("jobIdentifier", new JobParameter("test" + System.currentTimeMillis(), true));
                return Optional.of(jobParameters);
            }
        };

        when(nextJobParamsService.getNextJobParams(10)).then(answer);
        reportingJobRunner = new MigrateReportingJobRunner(migrateRepository, jobLauncher, job, nextJobParamsService, 10);
    }

    @Test
    public void isShouldLaunchJobInLoop() throws JobExecutionException {
        reportingJobRunner.run();

        verify(nextJobParamsService, times(3)).getNextJobParams(10);
        verify(jobLauncher, times(2)).run(job, jobParameters);
    }

    @Test
    public void isShouldHandleExceptionsInNextJobParamService() throws JobExecutionException {
        when(nextJobParamsService.getNextJobParams(10)).thenThrow(new RuntimeException());

        reportingJobRunner.run();
        verify(jobLauncher, never()).run(job, jobParameters);
    }

    @Test
    public void isShouldHandleExceptionsInJobAndStopTheLoop() throws JobExecutionException {
        when(jobLauncher.run(job, jobParameters)).thenThrow(new RuntimeException());

        reportingJobRunner.run();

        verify(nextJobParamsService, times(1)).getNextJobParams(10);
        verify(jobLauncher, times(1)).run(job, jobParameters);
    }

    @Test
    public void itShouldNotLaunchJobIfPaused() throws JobExecutionException {
        reportingJobRunner.stop();
        reportingJobRunner.run();
        verify(jobLauncher, never()).run(job, jobParameters);
    }

    @Test
    public void itShouldNotLaunchJobIfDisabled() throws JobExecutionException {
        when(migrateRepository.findLastStatus()).thenReturn(MigrateStatus.FAILED);
        reportingJobRunner.run();
        verify(jobLauncher, never()).run(job, jobParameters);
    }
}