package org.opentestsystem.rdw.ingest.migrate.reporting;

import com.google.common.collect.Lists;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.SqlListExecutionRepository;
import org.opentestsystem.rdw.ingest.migrate.reporting.step.SqlListExecutionStep;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.step.builder.StepBuilder;
import org.springframework.batch.core.step.builder.TaskletStepBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.ingest.common.model.ImportContent.CODES;
import static org.opentestsystem.rdw.ingest.common.model.ImportContent.EXAM;
import static org.opentestsystem.rdw.ingest.common.model.ImportContent.PACKAGE;
import static org.opentestsystem.rdw.ingest.migrate.reporting.StagingToReportingStepsConfig.codesEntities;
import static org.opentestsystem.rdw.ingest.migrate.reporting.StagingToReportingStepsConfig.entities;
import static org.opentestsystem.rdw.ingest.migrate.reporting.StagingToReportingStepsConfig.stepDeleteCodesName;
import static org.opentestsystem.rdw.ingest.migrate.reporting.StagingToReportingStepsConfig.stepDeleteEntities;
import static org.opentestsystem.rdw.ingest.migrate.reporting.StagingToReportingStepsConfig.stepUpsertCodesName;
import static org.opentestsystem.rdw.ingest.migrate.reporting.StagingToReportingStepsConfig.stepUpsertOrganization;

@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {SpringBatchIT.BatchTestConfig.class})
@SpringBootTest
@ActiveProfiles("test")
public class StagingToReportingStepsConfigIT {
    @Autowired
    MigrateStagingToWarehouseSqlConfiguration sqlConfig;

    private StepBuilderFactory stepBuilderFactory;
    private SqlListExecutionRepository sqlListExecutionRepository;

    private StagingToReportingStepsConfig configUnderTest;

    @Before
    public void setUp() {
        stepBuilderFactory = mock(StepBuilderFactory.class);
        sqlListExecutionRepository = mock(SqlListExecutionRepository.class);

        configUnderTest = new StagingToReportingStepsConfig(stepBuilderFactory, sqlConfig, sqlListExecutionRepository);
    }

    @Test
    public void verifyUpsertCodesStepConfiguration() {
        final StepBuilder stepBuilder = mock(StepBuilder.class);
        when(stepBuilderFactory.get(stepUpsertCodesName)).thenReturn(stepBuilder);
        when(stepBuilder.tasklet(any())).thenReturn(mock(TaskletStepBuilder.class));
        final ArgumentCaptor<SqlListExecutionStep> captor = ArgumentCaptor.forClass(SqlListExecutionStep.class);

        configUnderTest.upsertCodesStep();
        verify(stepBuilder).tasklet(captor.capture());

        final SqlListExecutionStep argument = captor.getValue();

        final List<String> expectedSqls = newArrayList();
        for (final String entity : codesEntities) {
            expectedSqls.add(sqlConfig.getEntities().get(entity).getSql().get("update"));
            expectedSqls.add(sqlConfig.getEntities().get(entity).getSql().get("insert"));
        }

        assertThat(argument.getSupportedContents()).containsExactly(CODES);
        assertThat(argument.getSqls()).containsExactlyElementsOf(expectedSqls);
    }

    @Test
    public void verifyDeleteCodesStepConfiguration() {
        final StepBuilder stepBuilder = mock(StepBuilder.class);
        when(stepBuilderFactory.get(stepDeleteCodesName)).thenReturn(stepBuilder);
        when(stepBuilder.tasklet(any())).thenReturn(mock(TaskletStepBuilder.class));
        final ArgumentCaptor<SqlListExecutionStep> captor = ArgumentCaptor.forClass(SqlListExecutionStep.class);

        configUnderTest.deleteCodesStep();
        verify(stepBuilder).tasklet(captor.capture());

        final SqlListExecutionStep argument = captor.getValue();

        final List<String> expectedSqls = newArrayList();
        for (final String table : Lists.reverse(codesEntities)) {
            expectedSqls.add(sqlConfig.getEntities().get(table).getSql().get("delete"));
        }

        assertThat(argument.getSupportedContents()).containsExactly(CODES);
        assertThat(argument.getSqls()).containsExactlyElementsOf(expectedSqls);
    }

    @Test
    public void verifyDeleteEntitiesStepConfiguration() {
        final StepBuilder stepBuilder = mock(StepBuilder.class);
        when(stepBuilderFactory.get(stepDeleteEntities)).thenReturn(stepBuilder);
        when(stepBuilder.tasklet(any())).thenReturn(mock(TaskletStepBuilder.class));
        final ArgumentCaptor<SqlListExecutionStep> captor = ArgumentCaptor.forClass(SqlListExecutionStep.class);

        configUnderTest.deleteEntitiesStep();
        verify(stepBuilder).tasklet(captor.capture());

        final SqlListExecutionStep argument = captor.getValue();

        final List<String> expectedSqls = newArrayList();
        for (final String table : Lists.reverse(entities)) {
            expectedSqls.add(sqlConfig.getEntities().get(table).getSql().get("delete"));
        }

        assertThat(argument.getSupportedContents()).containsExactly(PACKAGE, EXAM);
        assertThat(argument.getSqls()).containsExactlyElementsOf(expectedSqls);
    }

    @Test
    public void verifyUpsertOrganizationStepConfiguration() {
        final StepBuilder stepBuilder = mock(StepBuilder.class);
        when(stepBuilderFactory.get(stepUpsertOrganization)).thenReturn(stepBuilder);
        when(stepBuilder.tasklet(any())).thenReturn(mock(TaskletStepBuilder.class));
        final ArgumentCaptor<SqlListExecutionStep> captor = ArgumentCaptor.forClass(SqlListExecutionStep.class);

        configUnderTest.upsertOrganizationStep();
        verify(stepBuilder).tasklet(captor.capture());

        final SqlListExecutionStep argument = captor.getValue();


        final List<String> expectedSqls = newArrayList();
        expectedSqls.add(sqlConfig.getEntities().get("district").getSql().get("update"));
        expectedSqls.add(sqlConfig.getEntities().get("district").getSql().get("insert"));
        expectedSqls.add(sqlConfig.getEntities().get("school").getSql().get("update"));
        expectedSqls.add(sqlConfig.getEntities().get("school").getSql().get("insert"));

        assertThat(argument.getSupportedContents()).containsExactly(EXAM);
        assertThat(argument.getSqls()).containsExactlyElementsOf(expectedSqls);
    }
}