package org.opentestsystem.rdw.ingest.migrate.reporting.service;

import org.junit.Test;
import org.opentestsystem.rdw.ingest.migrate.reporting.MigrateBatchId;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.MigrateImportRepository;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.impl.JdbcMigrateImportRepository;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class NextJobServiceTest {

    //todo: use constants for test values
    //todo: move to properties;
    private static final Long BatchSizeLimit = 10L;

    @Test
    public void shouldHandleLessWorkLastAndMaxNegative() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findLastMigratedImportId()).thenReturn(Optional.of(-1008L));
        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.of((-1002L)));

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isPresent();
        // todo: IntelliJ warnings: there should be a fluent way to do this, but the check is above.
        assertThat(migrateBatchId.get().getStartImportId()).isEqualTo(-1007L);
        assertThat(migrateBatchId.get().getEndImportId()).isEqualTo(-1002L);
    }

    @Test
    public void shouldHandleMoreWorkLastAndMax() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findLastMigratedImportId()).thenReturn(Optional.of(3L));
        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.of((2000L)));

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isPresent();
        assertThat(migrateBatchId.get().getStartImportId()).isEqualTo(4L);
        assertThat(migrateBatchId.get().getEndImportId()).isEqualTo(13L);
        assertThat((migrateBatchId.get().getEndImportId() - migrateBatchId.get().getStartImportId()) + 1).isEqualTo(BatchSizeLimit);
    }

    @Test
    public void shouldHandleExactWorkLastAndMax() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findLastMigratedImportId()).thenReturn(Optional.of(19L));
        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.of((30L)));

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isPresent();
        assertThat(migrateBatchId.get().getStartImportId()).isEqualTo(20L);
        assertThat(migrateBatchId.get().getEndImportId()).isEqualTo(29L);
        assertThat((migrateBatchId.get().getEndImportId() - migrateBatchId.get().getStartImportId()) + 1).isEqualTo(BatchSizeLimit);
    }

    @Test
    public void shouldHandleLessWorkLastAndMax() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findLastMigratedImportId()).thenReturn(Optional.of(2L));
        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.of((7L)));

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isPresent();
        assertThat(migrateBatchId.get().getStartImportId()).isEqualTo(3L);
        assertThat(migrateBatchId.get().getEndImportId()).isEqualTo(7L);
    }

    @Test
    public void shouldHandleNoWorkMax() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.empty());

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isEmpty();
    }

    @Test
    public void shouldHandleMoreWorkFirstAndMax() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findLastMigratedImportId()).thenReturn(Optional.empty());
        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.of((2000L)));
        when(migrateImportRepository.findMinImportId()).thenReturn(Optional.of((21L)));

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isPresent();
        assertThat(migrateBatchId.get().getStartImportId()).isEqualTo(21L);
        assertThat(migrateBatchId.get().getEndImportId()).isEqualTo(30L);
        assertThat((migrateBatchId.get().getEndImportId() - migrateBatchId.get().getStartImportId()) + 1).isEqualTo(BatchSizeLimit);
    }

    @Test
    public void shouldHandleExactWorkFirstAndMax() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findLastMigratedImportId()).thenReturn(Optional.empty());
        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.of((30L)));
        when(migrateImportRepository.findMinImportId()).thenReturn(Optional.of((21L)));

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isPresent();
        assertThat(migrateBatchId.get().getStartImportId()).isEqualTo(21L);
        assertThat(migrateBatchId.get().getEndImportId()).isEqualTo(30L);
        assertThat((migrateBatchId.get().getEndImportId() - migrateBatchId.get().getStartImportId()) + 1).isEqualTo(BatchSizeLimit);
    }

    @Test
    public void shouldHandleLessWorkFirstAndMax() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findLastMigratedImportId()).thenReturn(Optional.empty());
        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.of((27L)));
        when(migrateImportRepository.findMinImportId()).thenReturn(Optional.of((21L)));

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isPresent();
        assertThat(migrateBatchId.get().getStartImportId()).isEqualTo(21L);
        assertThat(migrateBatchId.get().getEndImportId()).isEqualTo(27L);
    }


    @Test
    public void shouldHandleNoWorkFirst() {
        MigrateImportRepository migrateImportRepository;
        NextJobService nextJobService;

        migrateImportRepository = mock(JdbcMigrateImportRepository.class);

        when(migrateImportRepository.findLastMigratedImportId()).thenReturn(Optional.empty());
        when(migrateImportRepository.findMaxImportId()).thenReturn(Optional.of((2000L)));
        when(migrateImportRepository.findMinImportId()).thenReturn(Optional.empty());

        nextJobService = new DefaultNextJobService(migrateImportRepository);

        Optional<MigrateBatchId> migrateBatchId = nextJobService.getNextJobImportId();
        assertThat(migrateBatchId).isEmpty();
    }


}