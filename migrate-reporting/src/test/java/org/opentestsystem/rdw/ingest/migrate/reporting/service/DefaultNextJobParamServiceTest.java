package org.opentestsystem.rdw.ingest.migrate.reporting.service;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.ingest.migrate.reporting.JobParams;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.ReportingMigrateRepository;
import org.opentestsystem.rdw.ingest.migrate.reporting.repository.WarehouseImportRepository;
import org.springframework.batch.core.JobParameter;
import org.springframework.batch.core.JobParameters;
import org.springframework.dao.DataRetrievalFailureException;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;


public class DefaultNextJobParamServiceTest {

    private WarehouseImportRepository warehouseImportRepository;
    private ReportingMigrateRepository reportingMigrateRepository;
    private NextJobParamsService nextJobParamsService;

    private static final int defaultBatchSize = 10;
    private static final long defaultLastImportId = -101L;


    @Before
    public void setUp() {
        warehouseImportRepository = mock(WarehouseImportRepository.class);
        reportingMigrateRepository = mock(ReportingMigrateRepository.class);
        nextJobParamsService = new DefaultNextJobParamService(warehouseImportRepository, reportingMigrateRepository);
    }

    @Test
    public void shouldHandleWithLastMigrate() {
        final long firstInBatch = -100L;
        final long lastInBatch = -91L;

        when(reportingMigrateRepository.findLastMigratedImportId()).thenReturn(defaultLastImportId); // Last migrate.
        when(warehouseImportRepository.findMaxImportIdNotMigrated(defaultLastImportId, defaultBatchSize)).thenReturn(Optional.of((lastInBatch)));

        final Optional<JobParameters> optionalJobParams = nextJobParamsService.getNextJobParams(defaultBatchSize);
        assertThat(optionalJobParams).isPresent();

        final JobParameters jobParameters = optionalJobParams.get();
        assertThat(jobParameters.getParameters().get("jobIdentifier").getType()).isEqualTo(JobParameter.ParameterType.LONG);
        assertThat(jobParameters.getParameters().get("jobIdentifier").isIdentifying()).isTrue();
        assertThat(jobParameters.getLong(JobParams.fistImportId)).isEqualTo(firstInBatch);
        assertThat(jobParameters.getLong(JobParams.lastImportId)).isEqualTo(lastInBatch);
        assertThat(jobParameters.getLong(JobParams.batchSize)).isEqualTo(defaultBatchSize);

        verify(reportingMigrateRepository, times(1)).findLastMigratedImportId();
        verify(warehouseImportRepository, times(1)).findMaxImportIdNotMigrated(defaultLastImportId, defaultBatchSize);
        verify(warehouseImportRepository, never()).findMinImportId();
    }

    @Test
    public void shouldHandleWithLastMigrateNoMoreWork() {
        when(reportingMigrateRepository.findLastMigratedImportId()).thenReturn(defaultLastImportId); // Last migrate.
        when(warehouseImportRepository.findMaxImportIdNotMigrated(defaultLastImportId, defaultBatchSize)).thenReturn(Optional.empty());

        final Optional<JobParameters> optionalJobParams = nextJobParamsService.getNextJobParams(defaultBatchSize);
        assertThat(optionalJobParams).isEmpty();

        verify(reportingMigrateRepository, times(1)).findLastMigratedImportId();
        verify(warehouseImportRepository, times(1)).findMaxImportIdNotMigrated(defaultLastImportId, defaultBatchSize);
        verify(warehouseImportRepository, never()).findMinImportId();
    }

    @Test
    public void shouldHandleFirstMigrate() {
        final long minImportId = -109L;
        final long firstInBatch = -109L;
        final long lastInBatch = -102L;

        when(reportingMigrateRepository.findLastMigratedImportId()).thenReturn(null); // No migrations yet.
        when(warehouseImportRepository.findMinImportId()).thenReturn(Optional.of(minImportId)); // The first import.
        when(warehouseImportRepository.findMaxImportIdNotMigrated(firstInBatch - 1, defaultBatchSize)).thenReturn(Optional.of((lastInBatch)));

        final Optional<JobParameters> optionalJobParams = nextJobParamsService.getNextJobParams(defaultBatchSize);
        assertThat(optionalJobParams).isPresent();

        final JobParameters jobParameters = optionalJobParams.get();
        assertThat(jobParameters.getParameters().get("jobIdentifier").getType()).isEqualTo(JobParameter.ParameterType.LONG);
        assertThat(jobParameters.getParameters().get("jobIdentifier").isIdentifying()).isTrue();
        assertThat(jobParameters.getLong(JobParams.fistImportId)).isEqualTo(firstInBatch);
        assertThat(jobParameters.getLong(JobParams.lastImportId)).isEqualTo(lastInBatch);
        assertThat(jobParameters.getLong(JobParams.batchSize)).isEqualTo(defaultBatchSize);

        verify(reportingMigrateRepository).findLastMigratedImportId();
        verify(warehouseImportRepository).findMaxImportIdNotMigrated(firstInBatch - 1, defaultBatchSize);
        verify(warehouseImportRepository).findMinImportId();
    }

    @Test
    public void shouldHandleFirstMigrateAndNoImports() {
        when(reportingMigrateRepository.findLastMigratedImportId()).thenReturn(null); // No migrations yet.
        when(warehouseImportRepository.findMinImportId()).thenReturn(Optional.empty()); // The first import.

        final Optional<JobParameters> optionalJobParams = nextJobParamsService.getNextJobParams(defaultBatchSize);
        assertThat(optionalJobParams).isEmpty();

        verify(reportingMigrateRepository).findLastMigratedImportId();
        verify(warehouseImportRepository, never()).findMaxImportIdNotMigrated(anyLong(), anyInt());
        verify(warehouseImportRepository).findMinImportId();
    }


    @Test(expected = DataRetrievalFailureException.class)
    public void shouldThrowExceptionOnNoLastAndFindFirstAndNoMax() {
        final long minImportId = -109L;
        final long firstInBatch = -109L; // No migrate recorded then first in batch is first import.

        when(reportingMigrateRepository.findLastMigratedImportId()).thenReturn(null); // No migrations yet.
        when(warehouseImportRepository.findMinImportId()).thenReturn(Optional.of(minImportId)); // The first import.
        when(warehouseImportRepository.findMaxImportIdNotMigrated(firstInBatch - 1, defaultBatchSize)).thenReturn(Optional.empty());

        // Throws exception.
        nextJobParamsService.getNextJobParams(defaultBatchSize);
    }


}