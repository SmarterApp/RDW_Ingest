package org.opentestsystem.rdw.ingest.migrate.reporting.step;

import org.junit.Test;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.SqlConfig;
import org.springframework.test.context.jdbc.SqlGroup;

import java.time.Instant;
import java.util.List;
import org.opentestsystem.rdw.ingest.migrate.reporting.SpringBatchStepIT;
import org.opentestsystem.rdw.migrate.common.ExecutionParams;
import org.opentestsystem.rdw.migrate.common.Migrate;
import org.opentestsystem.rdw.migrate.common.MigrateStatus;
import org.opentestsystem.rdw.migrate.common.TableTestCountHelper;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.rdw.ingest.migrate.reporting.step.WarehouseToStagingStepsConfig.StageGroupsStepName;
import static org.opentestsystem.rdw.migrate.common.TableTestCountHelper.verifyTableCountsAfterTest;

/**
 * There was a very specific bug encountered in production:<br/>
 * When large group files are processed, migrate would occasionally miss some of the groups.
 * The thought is that, if migrate is triggered partway through processing of the file
 * (by other imports coming in), the time-based selection would miss groups that were
 * timestamped *before* the migrate but not committed until *after* the migrate starts.
 * <p>
 * To simulate this, we need to set up the import, group and migrate records carefully.<ul>
 *     <li>big group import record, created=T100, updated=T105</li>
 *     <li>subsequent import records for small groups, created=updated=T100,T101,T102</li>
 *     <li>migrate record for those subsequent import records, first_at=T100, last_at=T102</li>
 *     <li>student group records for big import, created=updated=T102</li>
 *     <li>student group records for big import, created=updated=T104</li>
 *     <li>student group records for small imports, created=updated=T100,T101,T102</li>
 * </ul>
 * Now trigger a migrate: it should try to do T102 - T105 and will miss the T102 groups from the big import.
 * </p>
 * <pre> NOTES
 * System is sitting around at T100
 *
 * Large group ingest 30 starts at T100 (will finish at T103)
 * Bunch of small groups come in 31-33 (before T103)
 * Migrate 20 kicks off (before T103)
 *  - this migrate will migrate the small groups
 *  - this migrate will not see the groups from the large import (txn hasn't committed yet)
 *
 * Large group ingest completes at T103 (import status -> 1, updated -> T103)
 * Migrate 21 kicks off
 *  - this migrate will not migrate groups created before T102
 *
 * migrate
 *    id, first_at, last_at
 *    19,      T98,     T99
 *    20,      T99,    T102
 *    21,     T102,    T103
 *
 * import
 *    id, status, content, created, updated
 *    29,      1,       1,     T98,     T99
 *    30,      1,       5,    T100,    T105
 *    31,      1,       5,    T100,    T100
 *    32,      1,       5,    T100,    T101
 *    33,      1,       5,    T102,    T102
 *
 * student_group
 *    id, import_id, update_import_id, created, updated
 *     2,        30,               30,    T102,    T102
 *     3,        30,               30,    T102,    T102
 *     4,        30,               30,    T104,    T104
 *     5,        30,               30,    T104,    T104
 *     6,        31,               31,    T100,    T100
 *     7,        32,               32,    T101,    T101
 *     8,        33,               33,    T102,    T102
 * </pre>
 */
@SqlGroup({
        @Sql(executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD, config = @SqlConfig(dataSource = "warehouseDatasource"),
                scripts = {"classpath:MigrateGroupsWarehouseSetup.sql"}),

        @Sql(executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD, config = @SqlConfig(dataSource = "warehouseDatasource"),
                scripts = {"classpath:MigrateGroupsWarehouseTeardown.sql"}),
        @Sql(executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD, config = @SqlConfig(dataSource = "reportingDatasource"),
                statements = {"DELETE FROM staging_student_group WHERE id < 0"})
})
public class MigrateGroupsIT extends SpringBatchStepIT {

    @Autowired
    private JdbcTemplate reportingJdbcTemplate;

    @Test
    public void itShouldStageGroups() {
        // Collect counts of rows in each staging table before the step call and the expected change.
        final List<TableTestCountHelper> tableTestCounts = newArrayList();
        tableTestCounts.add(new TableTestCountHelper(reportingJdbcTemplate, "staging_student_group", 5, "id < 0"));

        // simulate running a final migrate that should catch all student groups
        // from the big group import (see MigrateGroupsWarehouseSetup.sql)
        getStepExecutionContext().put(ExecutionParams.migrate,
                Migrate.builder().id(1L).jobId(1)
                        .status(MigrateStatus.STARTED)
                        .firstAt(Instant.parse("2017-07-18T13:00:09Z"))
                        .lastAt(Instant.parse("2017-07-18T13:00:10Z"))
                        .build());

        final JobExecution jobExecution = launchStep(StageGroupsStepName);

        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        verifyTableCountsAfterTest(tableTestCounts);
    }
}
