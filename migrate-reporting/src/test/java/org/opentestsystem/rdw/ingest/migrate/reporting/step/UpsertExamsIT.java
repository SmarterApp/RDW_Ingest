package org.opentestsystem.rdw.ingest.migrate.reporting.step;

import org.junit.Test;
import org.opentestsystem.rdw.ingest.common.model.ImportContent;
import org.opentestsystem.rdw.ingest.migrate.reporting.Migrate;
import org.opentestsystem.rdw.ingest.migrate.reporting.MigrateBatch;
import org.opentestsystem.rdw.ingest.migrate.reporting.SpringBatchStepIT;
import org.opentestsystem.rdw.ingest.migrate.reporting.TableTestCountHelper;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.SqlGroup;

import java.util.List;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.opentestsystem.rdw.ingest.migrate.reporting.TableTestCountHelper.verifyTableCountsAfterTest;
import static org.opentestsystem.rdw.ingest.migrate.reporting.step.StagingToReportingStepsConfig.upsertExamsStepName;
import static org.springframework.test.context.jdbc.Sql.ExecutionPhase.AFTER_TEST_METHOD;
import static org.springframework.test.context.jdbc.Sql.ExecutionPhase.BEFORE_TEST_METHOD;

public class UpsertExamsIT extends SpringBatchStepIT {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @SqlGroup({
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingSetup.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingTearDown.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateCodesFromStagingTearDown.sql"})
    })
    @Test
    public void itShouldDoNothingIfBatchDoesNotHaveRightImportContent() {
        final List<TableTestCountHelper> tableTestCounts = newArrayList();
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam_available_accommodation", 0, "1=1"));
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam_item", 0, "1=1"));
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam", 0, "1=1"));

        getStepExecutionContext().put("batch", new MigrateBatch(mock(Migrate.class), newArrayList(ImportContent.CODES)));

        JobExecution jobExecution = launchStep(upsertExamsStepName);
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        verifyTableCountsAfterTest(tableTestCounts);
    }

    @SqlGroup({
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingCodesPreloadToReporting.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesPreloadReportingSetup.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingSetup.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingTearDown.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateCodesFromStagingTearDown.sql"})
    })
    @Test
    public void itShouldInsert() {
        final List<TableTestCountHelper> tableTestCounts = newArrayList();
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam_available_accommodation", 1, "exam_id in (-88, -87)"));
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam_item", 4, "exam_id in (-88, -87, -86)"));
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam", 2, "id in (-88, -87, -86)"));

        getStepExecutionContext().put("batch", new MigrateBatch(mock(Migrate.class), newArrayList(ImportContent.EXAM)));

        // run the step first time
        JobExecution jobExecution = launchStep(upsertExamsStepName);
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        verifyTableCountsAfterTest(tableTestCounts);

        //repeat to verify that it is idempotent
        jobExecution = launchStep(upsertExamsStepName);
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        verifyTableCountsAfterTest(tableTestCounts);
    }

    @SqlGroup({
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingCodesPreloadToReporting.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingSetup.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesPreloadReportingSetup.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingTearDown.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateCodesFromStagingTearDown.sql"})
    })
    @Test
    public void itShouldUpdate() {

        final List<TableTestCountHelper> tableTestCounts = newArrayList();

        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam_item", -1, "response = 'test'"));
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam", -1, " t3_program_type = 'test'"));

        getStepExecutionContext().put("batch", new MigrateBatch(mock(Migrate.class), newArrayList(ImportContent.EXAM)));

        // run the step first time
        JobExecution jobExecution = launchStep(upsertExamsStepName);
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        verifyTableCountsAfterTest(tableTestCounts);

        //repeat to verify that it is idempotent
        jobExecution = launchStep(upsertExamsStepName);
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        verifyTableCountsAfterTest(tableTestCounts);
    }

    @SqlGroup({
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingCodesPreloadToReporting.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingSetup.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingForDeleteSetup.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesPreloadReportingSetup.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingTearDown.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateCodesFromStagingTearDown.sql"})
    })
    @Test
    public void itShouldNoteDelete() {

        final List<TableTestCountHelper> tableTestCounts = newArrayList();
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam_available_accommodation", 0, "exam_id in (-88)"));
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam_item", 0, "exam_id in (-88)"));
        tableTestCounts.add(new TableTestCountHelper(jdbcTemplate, "reporting_test.exam", 0, "id in (-88)"));

        getStepExecutionContext().put("batch", new MigrateBatch(mock(Migrate.class), newArrayList(ImportContent.EXAM)));

        // run the step first time
        JobExecution jobExecution = launchStep(upsertExamsStepName);
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        verifyTableCountsAfterTest(tableTestCounts);

        //repeat to verify that it is idempotent
        jobExecution = launchStep(upsertExamsStepName);
        assertThat(jobExecution.getExitStatus()).isEqualTo(ExitStatus.COMPLETED);
        verifyTableCountsAfterTest(tableTestCounts);
    }

    @SqlGroup({
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingCodesPreloadToReporting.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingSetup.sql"}),
            @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:MigrateEntitiesPreloadReportingSetup.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateEntitiesFromStagingTearDown.sql"}),
            @Sql(executionPhase = AFTER_TEST_METHOD, scripts = {"classpath:MigrateCodesFromStagingTearDown.sql"})
    })

    /**
     * The exam's completed date is defined as not null in the schema.
     * If `explicit_defaults_for_timestamp` mySQL setting is turned off, this causes an undesirable behaviour.
     * This test verifies that this setting is turned on.
     */
    @Test(expected = DataIntegrityViolationException.class)
    public void testExplicitDefaultsForTimestampIsOn() {
        jdbcTemplate.execute("INSERT INTO reporting_test.exam ( id, type_id, school_year, asmt_id, asmt_version, opportunity, completeness_id,\n" +
                "                                administration_condition_id, session_id, performance_level, scale_score, scale_score_std_err,\n" +
                "                                completed_at, import_id, grade_id, student_id, school_id, iep, lep,\n" +
                "                                section504, economic_disadvantage, migrant_status, eng_prof_lvl, t3_program_type, language_code,\n" +
                "                                prim_disability_type,\n" +
                "                                claim1_scale_score, claim1_scale_score_std_err,claim1_category,\n" +
                "                                claim2_scale_score, claim2_scale_score_std_err,claim2_category,\n" +
                "                                claim3_scale_score, claim3_scale_score_std_err,claim3_category,\n" +
                "                                claim4_scale_score, claim4_scale_score_std_err,claim4_category ) VALUES\n" +
                "(-100, 1,  2016, -99,  null, 1, 1, 1, 'test', 1, 2145, 0.17, null, -88, -98, -89, -1, 1, 1, 0, 0, 1, 'test', 'test', 'eng', null,\n" +
                "    2000, 0.11, 1, 2100, 0.12, 2, 2500, 0.13, 3, 3000, .15, 4);"
        );
    }
}
