package org.opentestsystem.rdw.ingest.processor.service.impl;

import java.util.List;
import java.util.Map;
import org.opentestsystem.rdw.ingest.model.ImportException;
import org.opentestsystem.rdw.ingest.model.ImportStatus;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.model.ExamClaim;
import org.opentestsystem.rdw.ingest.processor.model.ExamClaim.Builder;
import org.opentestsystem.rdw.ingest.processor.model.SubjectClaimScore;
import org.opentestsystem.rdw.ingest.processor.repository.ExamRepository;
import org.opentestsystem.rdw.ingest.processor.service.AnyExamProcessor;
import org.opentestsystem.rdw.model.Opportunity;
import org.opentestsystem.rdw.model.Opportunity.Score;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import static com.google.common.base.Joiner.on;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseOptionalDouble;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseOptionalInteger;

@Service
class ExamProcessor extends AnyExamProcessor<Exam, Exam.Builder, ExamRepository> {

    /**
     * Constructor
     *
     * @param repository the {@link ExamRepository}
     */
    @Autowired
    public ExamProcessor(final ExamRepository repository) {
        super(repository);
    }

    @Override
    public String[] getTypes() {
        return new String[]{"ica"};
    }

    @Override
    protected Exam.Builder buildExam(final Opportunity opportunity, final List<SubjectClaimScore> claims) throws ImportException {
        final List<String> elementErrors = newArrayList();

        final Exam.Builder examBuilder = Exam.builder();
        final Map<String, Builder> claimBuilders = getClaimBuilders(claims);

        for (final Score score : opportunity.getScore()) {
            final String scoreOf = score.getMeasureOf();
            final String label = score.getMeasureLabel();

            if (overallScore.equals(scoreOf)) {
                if (scoreMeasureLabel.equals(label)) {
                    examBuilder
                            .withScaleScore(parseOptionalDouble(score.getValue(), scoreOf + "," + scoreMeasureLabel, elementErrors))
                            .withScaleScoreStdErr(parseOptionalDouble(score.getStandardError(), scoreOf + "," + scoreMeasureLabel + ", StdErr", elementErrors));
                } else if (performanceLevelMeasureLabel.equals(label)) {
                    examBuilder
                            .withAchievementLevel(parseOptionalInteger(score.getValue(), scoreOf + "," + scoreMeasureLabel + ", AchievementLevel", elementErrors));
                }
            } else if (claimBuilders.containsKey(scoreOf)) {
                if (scoreMeasureLabel.equals(label)) {
                    claimBuilders.get(scoreOf)
                            .withScaleScore(parseOptionalDouble(score.getValue(), scoreOf + "," + scoreMeasureLabel, elementErrors))
                            .withScaleScoreStdErr(parseOptionalDouble(score.getStandardError(), scoreOf + "," + scoreMeasureLabel + ", StdErr", elementErrors));
                } else if (performanceLevelMeasureLabel.equals(label)) {
                    claimBuilders.get(scoreOf)
                            .withCategory(parseOptionalInteger(score.getValue(), scoreOf + "," + performanceLevelMeasureLabel + ", Category", elementErrors));
                }
            }
        }

        final List<ExamClaim> examClaims = newArrayList();
        for (ExamClaim.Builder claimBuilder : claimBuilders.values()) {
            //TODO: add handling of the un-scored claims
            examClaims.add(claimBuilder.build());
        }

        if (elementErrors.isEmpty()) return examBuilder.withExamClaims(examClaims);
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private Map<String, Builder> getClaimBuilders(final List<SubjectClaimScore> claims) {

        final Map<String, Builder> claimBuilders = newHashMap();

        for (final SubjectClaimScore subjectClaimScore : claims) {
            claimBuilders.put(subjectClaimScore.getCode(), ExamClaim.builder().withClaimId(subjectClaimScore.getId()));
        }
        return claimBuilders;
    }
}
