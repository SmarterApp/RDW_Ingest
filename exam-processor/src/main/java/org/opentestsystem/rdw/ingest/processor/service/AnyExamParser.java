package org.opentestsystem.rdw.ingest.processor.service;

import java.text.ParseException;
import java.util.List;
import org.opentestsystem.rdw.ingest.model.ImportException;
import org.opentestsystem.rdw.ingest.model.ImportStatus;
import org.opentestsystem.rdw.ingest.processor.model.AnyExam;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Claim;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.repository.AdminConditionRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CompletenessRepository;
import org.opentestsystem.rdw.ingest.processor.utils.ParseUtil;
import org.opentestsystem.rdw.model.Opportunity;
import org.opentestsystem.rdw.model.Test;
import org.springframework.beans.factory.annotation.Autowired;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Double.parseDouble;

/**
 * This class defines a template for parsing the exam related data
 */
public abstract class AnyExamParser<E extends AnyExam, B extends AnyExam.Builder<B, E>> {

    protected static final String scoreMeasureLabel = "ScaleScore";
    protected static final String performanceLevelMeasureLabel = "PerformanceLevel";
    protected static final String overallScore = "Overall";

    private AdminConditionRepository adminConditionRepository;
    private CompletenessRepository completenessRepository;

    @Autowired
    private void setCompletenessRepository(final CompletenessRepository completenessRepository) {
        this.completenessRepository = completenessRepository;
    }

    @Autowired
    private void setAdminConditionRepository(final AdminConditionRepository adminConditionRepository) {
        this.adminConditionRepository = adminConditionRepository;
    }

    /**
     * This method is responsible for creating a builder for {@link AnyExam} and initializing it with
     * the exam specific data from the given input.
     *
     * @param opportunity the {@link Opportunity} that holds exam data
     * @param claims      the list of {@link Claim} for the exam
     * @return a pre-loaded builder
     */
    protected abstract B buildExam(Opportunity opportunity, List<Claim> claims);

    /**
     * Parses the exam data
     */
    public E parse(final Test test, final Opportunity opportunity, final StudentExamAttributes studentExamAttributes, final Assessment assessment) throws ParseException {
        final AnyExam.Builder<B, E> builder = buildExam(opportunity, assessment.getClaims())
                .withStudentAttributes(studentExamAttributes)
                .withExamItems(parseExamItems(opportunity))
                .withAssessmentId(assessment.getId())
                .withAsmtVersion(test.getAssessmentVersion())
                .withCompletedAt(ParseUtil.toDate(opportunity.getDateCompleted(), "opportunity, dateCompleted"))
                //TODO:is opportunity int or long?
                .withOpportunity((int) opportunity.getOpportunity())
                .withSessionId(opportunity.getSessionId())
                .withValid(parseValidity(opportunity.getValidity()))
                .withStatus(opportunity.getStatus());

        if (!isNullOrEmpty(opportunity.getCompleteness())) {
            builder.withCompleteness(completenessRepository.findIdByName(opportunity.getCompleteness()));
        }
        if (!isNullOrEmpty(opportunity.getAdministrationCondition())) {
            builder.withAdministrationConditionId(adminConditionRepository.findIdByName(opportunity.getAdministrationCondition()));
        }

        return builder.build();
    }

    private List<ExamItem> parseExamItems(final Opportunity opportunity) {
        final List<ExamItem> examItems = newArrayList();
        for (final Opportunity.Item item : opportunity.getItem()) {

            final String response = (item.getResponse() != null && !isNullOrEmpty(item.getResponse().getContent())) ?
                    item.getResponse().getContent() : null;
            //TODO: is bank key a number or string?
            examItems.add(new ExamItem(item.getKey(),
                    (new Long(item.getBankKey()).toString()),
                    parseDouble(item.getScore()),
                    item.getScoreStatus(),
                    response));
        }
        return examItems;
    }

    //TODO: consider refactoring it or moving to the db with the rest of the codes if we need to support this value
    private boolean parseValidity(final String value) {
        if (isNullOrEmpty(value)) throw new ImportException(ImportStatus.BAD_DATA, "unsupported validity value [" + value + "]");

        if (value.equalsIgnoreCase("valid")) return true;
        if (value.equalsIgnoreCase("invalid")) return false;

        throw new ImportException(ImportStatus.BAD_DATA, "unsupported validity value [" + value + "]");
    }

}