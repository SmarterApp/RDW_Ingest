package org.opentestsystem.rdw.ingest.processor.repository.impl;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Claim;
import org.opentestsystem.rdw.ingest.processor.repository.StubbedOutAssessmentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;


@Repository
class StubbedOutAssessmentRepositoryImpl implements StubbedOutAssessmentRepository {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.assessment.create}")
    private String sqlCreate;

    @Value("${sql.assessment.claim.createForAsmt}")
    private String sqlClaimCreateForAsmt;

    @Value("${sql.assessment.claim.findForAsmt}")
    private String sqlClaimFindForAsmt;

    @Autowired
    public StubbedOutAssessmentRepositoryImpl(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public Assessment create(final Assessment assessment) {

        final KeyHolder keyHolder = new GeneratedKeyHolder();
        final SqlParameterSource parameterSource = new MapSqlParameterSource()
                .addValue("natural_id", assessment.getNaturalId())
                .addValue("grade_id", assessment.getGradeId())
                .addValue("type_id", assessment.getTypeId())
                .addValue("subject_id", assessment.getSubjectId())
                .addValue("academic_year", assessment.getAcademicYear())
                .addValue("name", assessment.getName())
                .addValue("label", assessment.getLabel())
                .addValue("version", assessment.getVersion());

        jdbcTemplate.update(sqlCreate, parameterSource, keyHolder);
        final Integer asmtId = keyHolder.getKey().intValue();
        batchCreateClaims(assessment.getClaims(), asmtId);
        return Assessment.builder().withCopy(assessment).withClaims(findClaims(asmtId)).withId(asmtId).build();

    }

    private List<Claim> findClaims(final int asmtId) {
        return jdbcTemplate.query(sqlClaimFindForAsmt,
                new MapSqlParameterSource("asmt_id", asmtId),
                new ClaimRowMapper());
    }

    private static class ClaimRowMapper implements RowMapper<Claim> {
        @Override
        public Claim mapRow(final ResultSet rs, final int rowNum) throws SQLException {
            return Claim.builder()
                    .withCode(rs.getString("code"))
                    .withMaxScore(rs.getDouble("max_score"))
                    .withMinScore(rs.getDouble("min_score"))
                    .withId(rs.getInt("id"))
                    .build();

        }
    }

    private void batchCreateClaims(final List<Claim> claims, final long assessmentId) {
        final SqlParameterSource[] batchParameters = claims.stream()
                .map(claim -> new MapSqlParameterSource("asmt_id", assessmentId)
                        .addValue("min_score", claim.getMinScore())
                        .addValue("max_score", claim.getMaxScore())
                        .addValue("code", claim.getCode()))
                .toArray(MapSqlParameterSource[]::new);

        jdbcTemplate.batchUpdate(sqlClaimCreateForAsmt, batchParameters);
    }
}
