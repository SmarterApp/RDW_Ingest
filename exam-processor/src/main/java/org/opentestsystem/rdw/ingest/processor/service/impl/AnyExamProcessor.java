package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.model.AnyExam;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.SubjectClaimScore;
import org.opentestsystem.rdw.ingest.processor.repository.AccommodationRepository;
import org.opentestsystem.rdw.ingest.processor.repository.AdminConditionRepository;
import org.opentestsystem.rdw.ingest.processor.repository.AnyExamRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CompletenessRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamItemProcessor;
import org.opentestsystem.rdw.model.Opportunity;
import org.opentestsystem.rdw.model.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.ArrayList;
import java.util.List;

import static com.google.common.base.Strings.isNullOrEmpty;

/**
 * A base class for processing all exam related data
 */
abstract class AnyExamProcessor<E extends AnyExam, B extends AnyExam.Builder<B, E>, R extends AnyExamRepository<E>> {
    private static final Logger logger = LoggerFactory.getLogger(AnyExamProcessor.class);

    private final R repository;

    protected static final String scoreMeasureLabel = "ScaleScore";
    protected static final String performanceLevelMeasureLabel = "PerformanceLevel";
    protected static final String overallScore = "Overall";

    private AdminConditionRepository adminConditionRepository;
    private CompletenessRepository completenessRepository;
    private ExamItemProcessor examItemProcessor;
    private AccommodationRepository accommodationRepository;

    /**
     * Constructor
     *
     * @param repository the {@link AnyExamRepository}
     */
    protected AnyExamProcessor(final R repository) {
        this.repository = repository;
    }

    @Autowired
    void setCompletenessRepository(final CompletenessRepository completenessRepository) {
        this.completenessRepository = completenessRepository;
    }

    @Autowired
    void setAdminConditionRepository(final AdminConditionRepository adminConditionRepository) {
        this.adminConditionRepository = adminConditionRepository;
    }

    @Autowired
    void setExamItemProcessor(final ExamItemProcessor examItemProcessor) {
        this.examItemProcessor = examItemProcessor;
    }

    @Autowired
    void setAccommodationRepository(final AccommodationRepository accommodationRepository) {
        this.accommodationRepository = accommodationRepository;
    }

    /**
     * @return a list of exam types supported
     */
    public abstract String[] getTypes();

    /**
     * This method is responsible for creating a builder for {@link AnyExam} and initializing it with
     * the exam specific data from the given input.
     *
     * @param opportunity the {@link Opportunity} that holds exam data
     * @param claims      the list of {@link SubjectClaimScore} for the exam
     * @param errorCollector error collector
     * @return a pre-loaded builder
     */
    protected abstract B buildExam(Opportunity opportunity, List<SubjectClaimScore> claims, DataElementErrorCollector errorCollector);

    /**
     * Process the exam
     */
    public void process(final Test report, final Opportunity opportunity, final StudentExamAttributes studentExamAttributes, final Assessment assessment, final long importId) throws ImportException {
        //todo: handle validation here; Ex. number of claims, score values (min/mx) and so on
        repository.create(parse(report, opportunity, studentExamAttributes, assessment, importId));
    }

    /**
     * Parses the exam data
     */
    private E parse(final Test test, final Opportunity opportunity, final StudentExamAttributes studentExamAttributes, final Assessment assessment, final long importId) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();

        final AnyExam.Builder<B, E> builder = buildExam(opportunity, assessment.getSubjectClaimScores(), errorCollector)
                .studentAttributes(studentExamAttributes)
                .examItems(examItemProcessor.process(opportunity.getItem(), assessment, errorCollector))
                .importId(importId)
                .schoolYear(test.getAcademicYear())
                .assessmentId(assessment.getId())
                .asmtVersion(test.getAssessmentVersion())
                .opportunity(opportunity.getOpportunity())
                .sessionId(opportunity.getSessionId());

        final List<String> accommodationCodes = new ArrayList<>();
        for (final Opportunity.Accommodation acc : opportunity.getAccommodation()) {
            accommodationCodes.add(acc.getCode());
        }
        if (!accommodationCodes.isEmpty()) {
            final List<Integer> accommodationIds = accommodationRepository.findIdsByCodes(accommodationCodes);

            if (accommodationCodes.size() > accommodationIds.size())
                logger.warn(String.format("%d accommodation codes did not validate", Math.abs(accommodationCodes.size() - accommodationIds.size())));

            builder.accommodationIds(accommodationIds);
        }

        if (opportunity.getDateCompleted() == null) errorCollector.add(new DataElementError("DateCompleted", null, "must not be null"));
        else builder.completedAt(opportunity.getDateCompleted());

        if (isNullOrEmpty(opportunity.getBestCompleteness())) errorCollector.add(new DataElementError("completeness", null, "must not be null or empty"));
        else builder.completenessId(completenessRepository.findIdByCode(opportunity.getBestCompleteness()));

        if (isNullOrEmpty(opportunity.getAdministrationCondition())) errorCollector.add(new DataElementError("AdministrationCondition", null, "must not be null or empty"));
        else builder.administrationConditionId(adminConditionRepository.findIdByCode(opportunity.getAdministrationCondition()));

        if (errorCollector.isEmpty()) return builder.build();

        throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }
}
