package org.opentestsystem.rdw.ingest.processor.service;


import java.util.List;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.processor.model.AnyExam;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.SubjectClaimScore;
import org.opentestsystem.rdw.ingest.processor.repository.AdminConditionRepository;
import org.opentestsystem.rdw.ingest.processor.repository.AnyExamRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CompletenessRepository;
import org.opentestsystem.rdw.model.Opportunity;
import org.opentestsystem.rdw.model.ScoreInfoType;
import org.opentestsystem.rdw.model.Test;
import org.springframework.beans.factory.annotation.Autowired;

import static com.google.common.base.Joiner.on;
import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static java.util.Date.from;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseOptionalDouble;

/**
 * A generic class for processing all exam related data
 */
public abstract class AnyExamProcessor<E extends AnyExam, B extends AnyExam.Builder<B, E>, R extends AnyExamRepository<E>> {

    private final R repository;

    protected static final String scoreMeasureLabel = "ScaleScore";
    protected static final String performanceLevelMeasureLabel = "PerformanceLevel";
    protected static final String overallScore = "Overall";

    private AdminConditionRepository adminConditionRepository;
    private CompletenessRepository completenessRepository;

    /**
     * Constructor
     *
     * @param repository the {@link AnyExamRepository}
     */
    protected AnyExamProcessor(final R repository) {
        this.repository = repository;
    }

    @Autowired
    void setCompletenessRepository(final CompletenessRepository completenessRepository) {
        this.completenessRepository = completenessRepository;
    }

    @Autowired
    void setAdminConditionRepository(final AdminConditionRepository adminConditionRepository) {
        this.adminConditionRepository = adminConditionRepository;
    }

    /**
     * @return a list of exam types supported
     */
    public abstract String[] getTypes();

    /**
     * This method is responsible for creating a builder for {@link AnyExam} and initializing it with
     * the exam specific data from the given input.
     *
     * @param opportunity the {@link Opportunity} that holds exam data
     * @param claims      the list of {@link SubjectClaimScore} for the exam
     * @return a pre-loaded builder
     */
    protected abstract B buildExam(Opportunity opportunity, List<SubjectClaimScore> claims, List<String> elementErrors);

    /**
     * Process the exam
     */
    public void process(final Test report, final Opportunity opportunity, final StudentExamAttributes studentExamAttributes, final Assessment assessment) throws ImportException {
        //todo: handle validation here; Ex. number of claims, score values (min/mx) and so on
        repository.create(parse(report, opportunity, studentExamAttributes, assessment));
    }

    /**
     * Parses the exam data
     */
    private E parse(final Test test, final Opportunity opportunity, final StudentExamAttributes studentExamAttributes, final Assessment assessment) throws ImportException {
        //TODO: this needs better error handling
        final List<String> elementErrors = newArrayList();
        final AnyExam.Builder<B, E> builder = buildExam(opportunity, assessment.getSubjectClaimScores(), elementErrors)
                .withStudentAttributes(studentExamAttributes)
                .withExamItems(parseExamItems(opportunity, elementErrors))
                .withAssessmentId(assessment.getId())
                .withAsmtVersion(test.getAssessmentVersion())
                .withOpportunity(opportunity.getOpportunity())
                .withSessionId(opportunity.getSessionId())
                .withStatus(opportunity.getStatus());

        //TODO:completedAt should be Instant, not Date?
        if (opportunity.getDateCompleted() == null) elementErrors.add(new DataElementError("DateCompleted", null, "must not be null").toJson());
        else builder.withCompletedAt(from(opportunity.getDateCompleted()));

        if (isNullOrEmpty(opportunity.getBestCompleteness())) elementErrors.add(new DataElementError("completeness", null, "must not be null or empty").toJson());
        else builder.withCompletenessId(completenessRepository.findIdByName(opportunity.getBestCompleteness()));

        if (isNullOrEmpty(opportunity.getAdministrationCondition())) elementErrors.add(new DataElementError("AdministrationCondition", null, "must not be null or empty").toJson());
        else builder.withAdministrationConditionId(adminConditionRepository.findIdByName(opportunity.getAdministrationCondition()));

        if (elementErrors.isEmpty()) return builder.build();
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private List<ExamItem> parseExamItems(final Opportunity opportunity, final List<String> elementErrors) {
        final List<ExamItem> examItems = newArrayList();
        for (final Opportunity.Item item : opportunity.getItem()) {

            final String response = (item.getResponse() != null && !isNullOrEmpty(item.getResponse().getContent())) ?
                    item.getResponse().getContent() : null;

            final ScoreInfoType scoreInfo = item.getScoreInfo();
            examItems.add(new ExamItem(new Long(item.getBankKey()).toString() + "-" + item.getKey(),
                    parseOptionalDouble(item.getScore(), "item", elementErrors),
                    item.getScoreStatus(),
                    response,
                    scoreInfo == null ? null : parseOptionalDouble(scoreInfo.getMaxScore(), "item position", elementErrors),
                    item.getPosition()));
        }
        return examItems;
    }
}
