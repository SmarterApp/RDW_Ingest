package org.opentestsystem.rdw.ingest.processor.service;


import java.util.List;
import org.opentestsystem.rdw.ingest.model.ImportException;
import org.opentestsystem.rdw.ingest.model.ImportStatus;
import org.opentestsystem.rdw.ingest.processor.model.AnyExam;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.SubjectClaimScore;
import org.opentestsystem.rdw.ingest.processor.repository.AdminConditionRepository;
import org.opentestsystem.rdw.ingest.processor.repository.AnyExamRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CompletenessRepository;
import org.opentestsystem.rdw.ingest.processor.utils.ParseUtil;
import org.opentestsystem.rdw.model.Opportunity;
import org.opentestsystem.rdw.model.Test;
import org.springframework.beans.factory.annotation.Autowired;

import static com.google.common.base.Joiner.on;
import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Double.parseDouble;

/**
 * A generic class for processing all exam related data
 */
public abstract class AnyExamProcessor<E extends AnyExam, B extends AnyExam.Builder<B, E>, R extends AnyExamRepository<E>> {

    private final R repository;

    protected static final String scoreMeasureLabel = "ScaleScore";
    protected static final String performanceLevelMeasureLabel = "PerformanceLevel";
    protected static final String overallScore = "Overall";

    private AdminConditionRepository adminConditionRepository;
    private CompletenessRepository completenessRepository;

    /**
     * Constructor
     *
     * @param repository the {@link AnyExamRepository}
     */
    protected AnyExamProcessor(final R repository) {
        this.repository = repository;
    }

    @Autowired
    void setCompletenessRepository(final CompletenessRepository completenessRepository) {
        this.completenessRepository = completenessRepository;
    }

    @Autowired
    void setAdminConditionRepository(final AdminConditionRepository adminConditionRepository) {
        this.adminConditionRepository = adminConditionRepository;
    }

    /**
     * @return a list of exam types supported
     */
    public abstract String[] getTypes();

    /**
     * This method is responsible for creating a builder for {@link AnyExam} and initializing it with
     * the exam specific data from the given input.
     *
     * @param opportunity the {@link Opportunity} that holds exam data
     * @param claims      the list of {@link SubjectClaimScore} for the exam
     * @return a pre-loaded builder
     */
    protected abstract B buildExam(Opportunity opportunity, List<SubjectClaimScore> claims);

    /**
     * Process the exam
     */
    public void process(final Test report, final Opportunity opportunity, final StudentExamAttributes studentExamAttributes, final Assessment assessment) throws ImportException {
        //todo: handle validation here; Ex. number of claims, score values (min/mx) and so on
        repository.create(parse(report, opportunity, studentExamAttributes, assessment));
    }

    /**
     * Parses the exam data
     */
    private E parse(final Test test, final Opportunity opportunity, final StudentExamAttributes studentExamAttributes, final Assessment assessment) throws ImportException {
        //TODO: this needs better error handling
        final List<String> elementErrors = newArrayList();
        final AnyExam.Builder<B, E> builder = buildExam(opportunity, assessment.getSubjectClaimScores())
                .withStudentAttributes(studentExamAttributes)
                .withExamItems(parseExamItems(opportunity))
                .withAssessmentId(assessment.getId())
                .withAsmtVersion(test.getAssessmentVersion())
                .withCompletedAt(ParseUtil.parseMandatoryDate(opportunity.getDateCompleted(), "opportunity,CompletedAt", elementErrors))
                //TODO:is opportunity int or long?
                .withOpportunity((int) opportunity.getOpportunity())
                .withSessionId(opportunity.getSessionId())
                .withValid(parseValidity(opportunity.getValidity()))
                .withStatus(opportunity.getStatus());

        if (!isNullOrEmpty(opportunity.getCompleteness())) {
            builder.withCompleteness(completenessRepository.findIdByName(opportunity.getCompleteness()));
        }
        if (!isNullOrEmpty(opportunity.getAdministrationCondition())) {
            builder.withAdministrationConditionId(adminConditionRepository.findIdByName(opportunity.getAdministrationCondition()));
        }

        if (elementErrors.isEmpty()) return builder.build();
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private List<ExamItem> parseExamItems(final Opportunity opportunity) {
        final List<ExamItem> examItems = newArrayList();
        for (final Opportunity.Item item : opportunity.getItem()) {

            final String response = (item.getResponse() != null && !isNullOrEmpty(item.getResponse().getContent())) ?
                    item.getResponse().getContent() : null;
            //TODO: is bank key a number or string?
            examItems.add(new ExamItem(item.getKey(),
                    (new Long(item.getBankKey()).toString()),
                    parseDouble(item.getScore()),
                    item.getScoreStatus(),
                    response));
        }
        return examItems;
    }

    //TODO: consider refactoring it or moving to the db with the rest of the codes if we need to support this value
    private boolean parseValidity(final String value) {
        if (isNullOrEmpty(value)) throw new ImportException(ImportStatus.BAD_DATA, "unsupported validity value [" + value + "]");

        if (value.equalsIgnoreCase("valid")) return true;
        if (value.equalsIgnoreCase("invalid")) return false;

        throw new ImportException(ImportStatus.BAD_DATA, "unsupported validity value [" + value + "]");
    }
}
