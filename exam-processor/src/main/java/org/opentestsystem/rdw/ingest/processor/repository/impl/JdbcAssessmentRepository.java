package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;
import org.opentestsystem.rdw.common.model.ScoreType;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.AssessmentScore;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentRepository;

import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.common.util.JdbcUtil.getNullable;

@Repository
class JdbcAssessmentRepository implements AssessmentRepository {

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.assessment.findOneByNaturalId}")
    private String sqlFindOneByNaturalId;

    @Value("${sql.assessment.score.findAllForAssessment}")
    private String sqlfindSubjectScores;

    @Value("${sql.assessment.item.findAllForAssessment}")
    private String sqlfindAllItemsForAssessment;

    @Autowired
    JdbcAssessmentRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Transactional(readOnly = true)
    @Override
    public Assessment findOneByNaturalId(final String naturalId) {
        final List<Assessment.Builder> found = jdbcTemplate.query(sqlFindOneByNaturalId,
                new MapSqlParameterSource("natural_id", naturalId),
                (rs, rowNum) -> Assessment.builder()
                        .id(rs.getInt("id"))
                        .naturalId(rs.getString("natural_id"))
                        .gradeCode(rs.getString("grade_code"))
                        .typeId(rs.getInt("type_id"))
                        .subjectId(rs.getInt("subject_id"))
                        .subjectCode(rs.getString("subject_code")));
        if (found.size() == 1) {
            final Assessment.Builder builder = found.get(0);
            final int id = builder.getId();
            return appendItemData(builder, id)
                    .scores(findSubjectScores(id))
                    .build();
        }
        return null;
    }

    private List<AssessmentScore> findSubjectScores(final int asmtId) {
        return jdbcTemplate.query(sqlfindSubjectScores,
                new MapSqlParameterSource("asmt_id", asmtId),
                (rs, rowNum) -> AssessmentScore.builder()
                        .scoreType(ScoreType.valueOf(rs.getInt("score_type_id")))
                        .subjectScoreId(getNullable(rs, rs.getInt("subject_score_id")))
                        .code(rs.getString("code"))
                        .minScore(getNullable(rs, rs.getDouble("min_score")))
                        .maxScore(getNullable(rs, rs.getDouble("max_score")))
                        .build());
    }

    private Assessment.Builder appendItemData(final Assessment.Builder builder, final int asmtId) {
        final Map<String, Integer> idsByNaturalId = newHashMap();
        final Map<String, Integer> targetCodeToId = newHashMap();
        jdbcTemplate.query(sqlfindAllItemsForAssessment,
                new MapSqlParameterSource("asmt_id", asmtId),
                (rs, rowNum) -> {
                    idsByNaturalId.put(rs.getString("natural_id"), rs.getInt("id"));
                    targetCodeToId.putIfAbsent(rs.getString("target_code"), rs.getInt("target_id"));
                    return rs;
                });

        return builder
                .items(idsByNaturalId)
                .targetCodeToId(targetCodeToId);
    }
}
