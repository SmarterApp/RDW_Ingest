package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.trt.Opportunity.Item;
import org.opentestsystem.rdw.common.model.trt.ScoreInfoType;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.ExamItemSubScore;
import org.opentestsystem.rdw.ingest.processor.model.ItemTrait;
import org.opentestsystem.rdw.ingest.processor.repository.ItemTraitRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamItemProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;

@Service
public class DefaultExamItemProcessor implements ExamItemProcessor {

    private final Map<String, Integer> itemTraitIds;

    /**
     * Constructor
     *
     * @param repository the {@link ItemTraitRepository}
     */
    @Autowired
    DefaultExamItemProcessor(final ItemTraitRepository repository) {
        itemTraitIds = newHashMap();
        for (final ItemTrait trait : repository.findAll()) {
            itemTraitIds.put(trait.getDimension(), trait.getId());
        }
    }

    @Override
    public List<ExamItem> parseExamItems(final List<Item> items, final Assessment assessment, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);
        final List<ExamItem> examItems = newArrayList();
        final Map<String, Integer> asmtItems = assessment.getItems();

        for (final Item item : items) {
            final String response = (item.getResponse() != null && !isNullOrEmpty(item.getResponse().getContent())) ? item.getResponse().getContent() : null;
            final ScoreInfoType scoreInfo = item.getScoreInfo();
            final String naturalId = Long.toString(item.getBankKey()) + "-" + item.getKey();

            if (!asmtItems.containsKey(naturalId)) {
                errorCollector.add(new DataElementError("item", naturalId, "Missing item with id = " + naturalId));
                continue;
            }

            examItems.add(ExamItem.builder()
                    .itemId(asmtItems.get(naturalId))
                    .score(parserHelper.parseOptional("item", item.getScore(), Double::parseDouble))
                    .scoreStatus(item.getScoreStatus())
                    .response(response)
                    .position(item.getPosition())
                    .subScoreList(parseTraitScores(scoreInfo, parserHelper))
                    .build());
        }
        return examItems;
    }

    private List<ExamItemSubScore> parseTraitScores(final ScoreInfoType scoreInfo, final ParserHelper parserHelper) {
        final List<ExamItemSubScore> subScores = newArrayList();
        if (scoreInfo == null || scoreInfo.getSubScoreList() == null) return subScores;

        for (final ScoreInfoType subScore : scoreInfo.getSubScoreList().getScoreInfo()) {
            final String trait = subScore.getScoreDimension();
            if (!itemTraitIds.containsKey(trait)) continue;
            subScores.add(new ExamItemSubScore(itemTraitIds.get(trait),
                    parserHelper.parseOptional("item,subScore,scorePoint", subScore.getScorePoint(), Double::parseDouble),
                    subScore.getScoreStatus()));
        }
        return subScores;
    }
}
