package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.trt.Opportunity.Item;
import org.opentestsystem.rdw.common.model.trt.Opportunity.Item.Response;
import org.opentestsystem.rdw.common.model.trt.ScoreInfoType;
import org.opentestsystem.rdw.ingest.common.config.SbacScoreConfiguration;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.ExamItemSubScore;
import org.opentestsystem.rdw.ingest.processor.model.ItemTrait;
import org.opentestsystem.rdw.ingest.processor.repository.ItemTraitRepository;
import org.opentestsystem.rdw.ingest.processor.repository.ResponseTypeRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamItemProcessor;
import org.opentestsystem.rdw.utils.DataElementError;
import org.opentestsystem.rdw.utils.DataElementErrorCollector;
import org.opentestsystem.rdw.utils.ParserHelper;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static org.springframework.util.StringUtils.hasText;

@Service
public class DefaultExamItemProcessor implements ExamItemProcessor {

    private final SbacScoreConfiguration scoreConfiguration;
    private final ItemTraitRepository itemTraitRepository;
    private final ResponseTypeRepository responseTypeRepository;

    /**
     * Constructor
     *
     * @param itemTraitRepository the {@link ItemTraitRepository}
     */
    @Autowired
    DefaultExamItemProcessor(final SbacScoreConfiguration scoreConfiguration,
                             final ItemTraitRepository itemTraitRepository,
                             final ResponseTypeRepository responseTypeRepository) {
        this.scoreConfiguration = scoreConfiguration;
        this.itemTraitRepository = itemTraitRepository;
        this.responseTypeRepository = responseTypeRepository;
    }

    @Override
    public List<ExamItem> parseExamItems(final List<Item> items, final Assessment assessment, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);
        final List<ExamItem> examItems = newArrayList();
        final Map<String, Integer> asmtItems = assessment.getItems();

        // build lookup for item traits (relies on repository caching this)
        final Map<String, Integer> itemTraitIds = itemTraitRepository.findAll().stream()
                .collect(Collectors.toMap(ItemTrait::getDimension, ItemTrait::getId));

        for (final Item item : items) {
            final String naturalId = item.getBankKey() + "-" + item.getKey();

            if (!asmtItems.containsKey(naturalId)) {
                errorCollector.add(new DataElementError("item", naturalId, "Missing item with id = " + naturalId));
                continue;
            }

            final Response response = item.getResponse();
            String responseText = null;
            Instant submittedAt = null;
            Integer responseTypeId = null;
            if (response != null) {
                responseText = isNullOrEmpty(response.getContent()) ? null : response.getContent();
                responseTypeId = isNullOrEmpty(response.getType()) ? null : responseTypeRepository.findIdByCode(response.getType());
                submittedAt = response.getDate();
            }

            examItems.add(ExamItem.builder()
                    .itemId(asmtItems.get(naturalId))
                    .score(parserHelper.validate("item", item.getScore(), this::toScore))
                    .scoreStatus(parserHelper.validate("score status", item.getScoreStatus(), 50, false))
                    .response(responseText)
                    .position((int) item.getPosition())
                    .subScoreList(parseTraitScores(item.getScoreInfo(), itemTraitIds, parserHelper))
                    .administeredAt(item.getAdminDate())
                    .submitted((int) item.getIsSelected())
                    .submittedAt(submittedAt)
                    .numberOfVisits(item.getNumberVisits())
                    .responseDuration(item.getResponseDuration())
                    .responseContentType(item.getMimeType())
                    .pageNumber(item.getPageNumber())
                    .pageVisits(item.getPageVisits())
                    .pageTime(item.getPageTime())
                    .responseTypeId(responseTypeId)
                    .build());
        }
        return examItems;
    }

    private Double toScore(final String value) {
        if (!hasText(value)) return null;

        final Double score = Double.parseDouble(value);
        if (score >= scoreConfiguration.getItemScore().getMin() && score <= scoreConfiguration.getItemScore().getMax()) return score;

        throw new IllegalArgumentException("invalid value, must be " + scoreConfiguration.getItemScore().getMin() + " - " + scoreConfiguration.getItemScore().getMax());
    }

    private List<ExamItemSubScore> parseTraitScores(final ScoreInfoType scoreInfo,
                                                    final Map<String, Integer> itemTraitIds,
                                                    final ParserHelper parserHelper) {
        final List<ExamItemSubScore> subScores = newArrayList();
        if (scoreInfo == null || scoreInfo.getSubScoreList() == null) return subScores;

        for (final ScoreInfoType subScore : scoreInfo.getSubScoreList().getScoreInfo()) {
            final String trait = subScore.getScoreDimension();
            if (!itemTraitIds.containsKey(trait)) continue;
            subScores.add(new ExamItemSubScore(itemTraitIds.get(trait),
                    parserHelper.validate("item,subScore,scorePoint", subScore.getScorePoint(), this::toScore),
                    parserHelper.validate("item,subScore,status", subScore.getScoreStatus(), 50, false)));
        }
        return subScores;
    }
}
