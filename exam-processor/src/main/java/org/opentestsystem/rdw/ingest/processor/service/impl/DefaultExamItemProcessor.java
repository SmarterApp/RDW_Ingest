package org.opentestsystem.rdw.ingest.processor.service.impl;

import java.util.List;
import java.util.Map;
import org.opentestsystem.rdw.ingest.common.error.DataElementError;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.ExamItemSubScore;
import org.opentestsystem.rdw.ingest.processor.model.ItemTrait;
import org.opentestsystem.rdw.ingest.processor.repository.ItemTraitRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamItemProcessor;
import org.opentestsystem.rdw.model.Opportunity.Item;
import org.opentestsystem.rdw.model.ScoreInfoType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseOptionalDouble;

@Service
public class DefaultExamItemProcessor implements ExamItemProcessor {

    private final Map<String, Integer> itemTraitIds;

    /**
     * Constructor
     *
     * @param repository the {@link ItemTraitRepository}
     */
    @Autowired
    DefaultExamItemProcessor(final ItemTraitRepository repository) {
        itemTraitIds = newHashMap();
        for (final ItemTrait trait : repository.findAll()) {
            itemTraitIds.put(trait.getDimension(), trait.getId());
        }
    }

    @Override
    public List<ExamItem> processes(final List<Item> items, final Assessment assessment, final List<String> elementErrors) {
        final List<ExamItem> examItems = newArrayList();
        final Map<String, Integer> asmtItems = assessment.getItems();

        for (final Item item : items) {
            final String response = (item.getResponse() != null && !isNullOrEmpty(item.getResponse().getContent())) ? item.getResponse().getContent() : null;
            final ScoreInfoType scoreInfo = item.getScoreInfo();
            final String naturalId = new Long(item.getBankKey()).toString() + "-" + item.getKey();

            if (!asmtItems.containsKey(naturalId)) {
                elementErrors.add(new DataElementError("item", naturalId, "Missing item with id = " + naturalId).toJson());
                continue;
            }

            examItems.add(ExamItem.builder()
                    .itemId(asmtItems.get(naturalId))
                    .score(parseOptionalDouble(item.getScore(), "item", elementErrors))
                    .scoreStatus(item.getScoreStatus())
                    .response(response)
                    .position(item.getPosition())
                    .subScoreList(parseTraitScores(scoreInfo, elementErrors))
                    .build());
        }
        return examItems;
    }

    private List<ExamItemSubScore> parseTraitScores(final ScoreInfoType scoreInfo, final List<String> elementErrors) {
        final List<ExamItemSubScore> subScores = newArrayList();
        if (scoreInfo == null || scoreInfo.getSubScoreList() == null) return subScores;

        for (final ScoreInfoType subScore : scoreInfo.getSubScoreList().getScoreInfo()) {
            final String trait = subScore.getScoreDimension();
            if (scoreInfo == null || !itemTraitIds.containsKey(trait)) continue;
            subScores.add(new ExamItemSubScore(itemTraitIds.get(trait),
                    parseOptionalDouble(subScore.getScorePoint(), "item,subScore,scorePoint", elementErrors),
                    subScore.getScoreStatus()));

        }
        return subScores;
    }

}
