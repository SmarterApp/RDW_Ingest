package org.opentestsystem.rdw.ingest.processor.service.util;


import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import org.opentestsystem.rdw.common.model.trt.Context;
import org.opentestsystem.rdw.common.model.trt.Examinee;
import org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.utils.ParserHelper.toBoolean;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LEPExitDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LimitedEnglishProficiencyEntryDate;

public class TrtUtils {
    /**
     * Map of aliases for TRT attribute field names. The key is the documented TRT attribute field name,
     * while the value is an alternate name, typically from the DWSA (the CSV import file) spec.
     * These will be used when looking for attribute values; for now for efficiency, just string attributes.
     * Although it is unlikely that multiple entries will exist with different names, if that happens the
     * TRT-named attribute value will be favored.
     */
    private static final Map<String, String> FieldAliases = newHashMap();

    static {
        FieldAliases.put("StudentIdentifier", "SSID");
        FieldAliases.put("GradeLevelWhenAssessed", "Grade");
        FieldAliases.put("SchoolId", "ResponsibleInstitutionIdentifier");
        FieldAliases.put(LimitedEnglishProficiencyEntryDate.name(), "EnglishLearnerIdentificationDate");
        FieldAliases.put(LEPExitDate.name(), "ReclassifiedFluentEnglishProficientDate");
    }

    public static String getBestAttributeValue(final Examinee examinee,
                                                final String element) {
        Examinee.ExamineeAttribute attribute = examinee.getBestAttribute(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        return attribute == null ? null : attribute.getValue();
    }

    public static String getBestAttributeValue(final Examinee examinee,
                                                final ConfigurableDataElement element) {
        return getBestAttributeValue(examinee, element.name());
    }

    public static String getBestRelationshipValue(final Examinee examinee,
                                                   final String element) {
        Examinee.ExamineeRelationship attribute = examinee.getBestRelationship(element);
        if (attribute != null) return attribute.getValue();

        if (FieldAliases.containsKey(element)) {
            attribute = examinee.getBestRelationship(FieldAliases.get(element));
        }
        return attribute == null ? null : attribute.getValue();
    }

    public static Set<String> getBestGroupNames(final Examinee examinee) {
        // get attributes with "StudentGroupName"
        // if any are FINAL then only get FINAL else only get INITIAL
        final Set<String> finalNames = newHashSet();
        final Set<String> initialNames = newHashSet();
        for (final Object obj : examinee.getExamineeAttributeOrExamineeRelationship()) {
            if (!(obj instanceof Examinee.ExamineeAttribute)) continue;
            final Examinee.ExamineeAttribute attribute = (Examinee.ExamineeAttribute) obj;
            if ("StudentGroupName".equals(attribute.getName())) {
                if (Context.FINAL.equals(attribute.getContext())) finalNames.add(attribute.getValue());
                else initialNames.add(attribute.getValue());
            }
        }
        return finalNames.isEmpty() ? initialNames : finalNames;
    }

    /**
     * The Section504Status attribute has a legacy value that indicates "unknown" which maps to null.
     * Otherwise it is a required boolean value.
     */
    public static final Function<String, Boolean> toSection504Status = value -> {
        if ("Unknown/Cannot Provide".equalsIgnoreCase(value)) return null;
        return toBoolean.apply(value);
    };
}
