package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.Iterables;
import org.opentestsystem.rdw.ingest.common.util.JdbcUtil;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.model.ExamClaim;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.ExamItemSubScore;
import org.opentestsystem.rdw.ingest.processor.model.ExamTarget;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.repository.ExamRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.ingest.common.repository.JdbcUtils.safeText;
import static org.opentestsystem.rdw.ingest.common.util.JdbcUtil.getNullable;
import static org.opentestsystem.rdw.ingest.processor.model.ExamItem.Conventions;
import static org.opentestsystem.rdw.ingest.processor.model.ExamItem.EvidenceAndElaboration;
import static org.opentestsystem.rdw.ingest.processor.model.ExamItem.OrganizationAndPurpose;

@Repository
class JdbcExamRepository implements ExamRepository {
    private final static Logger logger = LoggerFactory.getLogger(JdbcExamRepository.class);

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.exam.examClaimScore.create}")
    private String sqlExamClaimScoreCreate;

    @Value("${sql.exam.examClaimScore.update}")
    private String sqlExamClaimScoreUpdate;

    @Value("${sql.exam.examClaimScore.delete}")
    private String sqlExamClaimScoreDelete;

    @Value("${sql.exam.examClaimScore.findByExamId}")
    private String sqlExamClaimScoreFindByExamId;

    @Value("${sql.exam.examTargetScore.create}")
    private String sqlExamTargetScoreCreate;

    @Value("${sql.exam.examTargetScore.update}")
    private String sqlExamTargetScoreUpdate;

    @Value("${sql.exam.examTargetScore.delete}")
    private String sqlExamTargetScoreDelete;

    @Value("${sql.exam.examTargetScore.findByExamId}")
    private String sqlExamTargetScoreFindByExamId;

    @Value("${sql.exam.examItem.create}")
    private String sqlExamItemCreate;

    @Value("${sql.exam.examItem.update}")
    private String sqlExamItemUpdate;

    @Value("${sql.exam.examItem.delete}")
    private String sqlExamItemDelete;

    @Value("${sql.exam.examItem.findByExamId}")
    private String sqlExamItemFindByExamId;

    @Value("${sql.exam.create}")
    private String sqlCreate;

    @Value("${sql.exam.update}")
    private String sqlUpdate;

    @Value("${sql.exam.delete}")
    private String sqlDelete;

    @Value("${sql.exam.findOne}")
    private String sqlFindOne;

    @Value("${sql.exam.accommodation.create}")
    private String sqlExamAccommodationCreate;

    @Value("${sql.exam.accommodation.delete}")
    private String sqlExamAccommodationDelete;

    @Value("${sql.exam.accommodation.findByExamId}")
    private String sqlExamAccommodationFindByExamId;

    @Autowired
    JdbcExamRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Retryable(maxAttemptsExpression = "${jdbc.retry.default.max-attempts}", backoff = @Backoff(delayExpression = "${jdbc.retry.default.delay}", multiplierExpression = "${jdbc.retry.default.multiplier}", random = true))
    @Transactional
    public long upsert(final Exam exam, final long importId) {
        if (exam.isDeleted()) throw new IllegalArgumentException("deleted exam is not supported for upsert");
        final Exam existing = findOne(exam.getAssessmentId(), exam.getOppId());
        if (existing == null) {
            return createExam(exam, importId);
        } else if (existing.getStatusDate() == null ||
                existing.getStatusDate().equals(exam.getStatusDate()) ||
                existing.getStatusDate().isBefore(exam.getStatusDate())) {
            return updateExamAndChildren(exam, existing, importId);
        } else {
            logger.info("Ignoring TDSReport with early statusDate. Import: {}, Existing statusDate: {}, Posted statusDate: {}",
                    importId, existing.getStatusDate(), exam.getStatusDate());
            return existing.getId();
        }
    }

    @Override
    @Transactional
    public void delete(final Exam exam, final long importId) {
        if (!exam.isDeleted()) throw new IllegalArgumentException("attempt to deleted is invalid");

        final Exam existing = findOne(exam.getAssessmentId(), exam.getOppId());
        if (existing == null) return;

        final SqlParameterSource parameterSource = new MapSqlParameterSource().addValue("id", existing.getId()).addValue("update_import_id", importId);
        jdbcTemplate.update(sqlDelete, parameterSource);
    }

    private long updateExamAndChildren(final Exam submitted, final Exam existing, final long importId) {
        boolean updated = upsertExamClaims(submitted.getExamClaims(), existing.getId());
        updated |= upsertExamTargets(submitted.getExamTargets(), existing.getId());
        updated |= upsertExamItems(submitted.getExamItems(), existing.getId());
        updated |= upsertAccommodations(submitted.getAccommodationIds(), existing.getId());

        if (updated || !equivalent(existing, submitted)) {
            logger.info("Updating Exam. Import: {} AssessmentId: {} OpportunityId: {} Deleted: {}",
                    importId, submitted.getAssessmentId(), submitted.getOppId(), submitted.isDeleted());

            final SqlParameterSource parameterSource = new MapSqlParameterSource()
                    .addValue("id", existing.getId())
                    .addValue("update_import_id", importId)
                    .addValues(toSqlParams(submitted));
            final int updateCount = jdbcTemplate.update(sqlUpdate, parameterSource);

            if (updateCount != 1) {
                throw new IllegalStateException("Unable to update exam: " + existing.getId() + " Import: " + importId);
            }

        } else {
            logger.debug("Ignoring Exam with equivalent content. Import: {} AssessmentId: {} OpportunityId: {} Deleted: {}",
                    importId, submitted.getAssessmentId(), submitted.getOppId(), submitted.isDeleted());
        }
        return existing.getId();
    }

    @Override
    public Exam findOne(final long assessmentId, final String opportunityId) {
        final SqlParameterSource parameterSource = new MapSqlParameterSource()
                .addValue("asmt_id", assessmentId)
                .addValue("opportunity_id", opportunityId);
        try {
            return jdbcTemplate.queryForObject(sqlFindOne, parameterSource, ExamRowMapper);
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }

    private long createExam(final Exam exam, final long importId) {
        logger.debug("Creating Exam. Import: {} AssessmentId: {} OpportunityId: {} Deleted: {}",
                importId, exam.getAssessmentId(), exam.getOppId(), exam.isDeleted());

        final KeyHolder keyHolder = new GeneratedKeyHolder();
        final SqlParameterSource parameterSource = new MapSqlParameterSource()
                .addValue("import_id", importId)
                .addValue("update_import_id", importId)
                .addValues(toSqlParams(exam));

        jdbcTemplate.update(sqlCreate, parameterSource, keyHolder);
        final long id = keyHolder.getKey().longValue();
        createExamClaims(exam.getExamClaims(), id);
        createExamTargets(exam.getExamTargets(), id);
        createExamItems(exam.getExamItems(), id);
        addAccommodations(exam.getAccommodationIds(), id);
        return id;
    }

    private static final RowMapper<Exam> ExamRowMapper = (row, rowNum) -> {
        final StudentExamAttributes attributes = StudentExamAttributes.builder()
                .gradeId(row.getInt("grade_id"))
                .studentId(row.getInt("student_id"))
                .responsibleSchoolId(row.getInt("school_id"))
                .ideaIndicator(row.getBoolean("iep"))
                .lep(getNullable(row, row.getBoolean("lep")))
                .section504(getNullable(row, row.getBoolean("section504")))
                .economicDisadvantage(row.getBoolean("economic_disadvantage"))
                .migrantStatus(getNullable(row, row.getBoolean("migrant_status")))
                .engProfLvl(row.getString("eng_prof_lvl"))
                .t3ProgramType(row.getString("t3_program_type"))
                .languageId(getNullable(row, row.getInt("language_id")))
                .militaryConnectedId(getNullable(row, row.getInt("military_connected_id")))
                .primDisabilityType(row.getString("prim_disability_type"))
                .examineeId(getNullable(row, row.getLong("examinee_id")))
                .elasId(getNullable(row, row.getInt("elas_id")))
                .elasStartDate(getNullableLocalDate(row, row.getDate("elas_start_at")))
                .build();
        return Exam.builder()
                .studentExamAttributes(attributes)
                .id(row.getLong("id"))
                .typeId(row.getInt("type_id"))
                .schoolYear(row.getInt("school_year"))
                .assessmentId(row.getInt("asmt_id"))
                .asmtVersion(row.getString("asmt_version"))
                .opportunity(row.getLong("opportunity"))
                .oppId(row.getString("oppId"))
                .completenessId(row.getInt("completeness_id"))
                .administrationConditionId(row.getInt("administration_condition_id"))
                .sessionId(row.getString("session_id"))
                .scaleScore(getNullable(row, row.getDouble("scale_score")))
                .scaleScoreStdErr(getNullable(row, row.getDouble("scale_score_std_err")))
                .performanceLevel(getNullable(row, row.getInt("performance_level")))
                .completedAt(row.getTimestamp("completed_at").toInstant())
                .statusDate(toInstantOrNull(row.getTimestamp("status_date")))
                .deleted(row.getBoolean("deleted"))
                .deliverMode(row.getString("deliver_mode"))
                .handScoreProject(getNullable(row, row.getLong("hand_score_project")))
                .contract(row.getString("contract"))
                .testReason(row.getString("test_reason"))
                .assessmentAdminStartedAt(getNullableLocalDate(row, row.getDate("assessment_admin_started_at")))
                .startedAt(toInstantOrNull(row.getTimestamp("started_at")))
                .forceSubmittedAt(toInstantOrNull(row.getTimestamp("force_submitted_at")))
                .status(row.getString("status"))
                .itemCount(getNullable(row, row.getLong("item_count")))
                .fieldTestCount(getNullable(row, row.getLong("field_test_count")))
                .pauseCount(getNullable(row, row.getLong("pause_count")))
                .gracePeriodRestarts(getNullable(row, row.getLong("grace_period_restarts")))
                .abnormalStarts(getNullable(row, row.getLong("abnormal_starts")))
                .testWindowId(row.getString("test_window_id"))
                .testAdministratorId(row.getString("test_administrator_id"))
                .responsibleOrganizationName(row.getString("responsible_organization_name"))
                .testAdministratorName(row.getString("test_administrator_name"))
                .sessionPlatformUserAgent(row.getString("session_platform_user_agent"))
                .testDeliveryServer(row.getString("test_delivery_server"))
                .testDeliveryDb(row.getString("test_delivery_db"))
                .windowOpportunityCount(row.getString("window_opportunity_count"))
                .thetaScore(getNullable(row, row.getDouble("theta_score")))
                .thetaScoreStdErr(getNullable(row, row.getDouble("theta_score_std_err")))
                .build();
    };

    private static Map<String, Object> toSqlParams(final Exam exam) {
        final StudentExamAttributes studentExamAttributes = exam.getStudentExamAttributes();
        return new MapSqlParameterSource()
                .addValue("type_id", exam.getTypeId())
                .addValue("school_year", exam.getSchoolYear())
                .addValue("asmt_id", exam.getAssessmentId())
                .addValue("asmt_version", exam.getAsmtVersion())
                .addValue("opportunity", exam.getOpportunity())
                .addValue("oppId", exam.getOppId())
                .addValue("completeness_id", exam.getCompletenessId())
                .addValue("administration_condition_id", exam.getAdministrationConditionId())
                .addValue("session_id", exam.getSessionId())
                .addValue("scale_score", exam.getScaleScore())
                .addValue("scale_score_std_err", exam.getScaleScoreStdErr())
                .addValue("performance_level", exam.getPerformanceLevel())
                .addValue("completed_at", Timestamp.from(exam.getCompletedAt()))
                .addValue("status_date", toTimeStampOrNull(exam.getStatusDate()))
                .addValue("deleted", exam.isDeleted())
                .addValue("deliver_mode", exam.getDeliverMode())
                .addValue("hand_score_project", exam.getHandScoreProject())
                .addValue("contract", exam.getContract())
                .addValue("test_reason", exam.getTestReason())
                .addValue("assessment_admin_started_at", exam.getAssessmentAdminStartedAt())
                .addValue("started_at", toTimeStampOrNull(exam.getStartedAt()))
                .addValue("force_submitted_at", toTimeStampOrNull(exam.getForceSubmittedAt()))
                .addValue("status", exam.getStatus())
                .addValue("item_count", exam.getItemCount())
                .addValue("field_test_count", exam.getFieldTestCount())
                .addValue("pause_count", exam.getPauseCount())
                .addValue("grace_period_restarts", exam.getGracePeriodRestarts())
                .addValue("abnormal_starts", exam.getAbnormalStarts())
                .addValue("test_window_id", exam.getTestWindowId())
                .addValue("test_administrator_id", exam.getTestAdministratorId())
                .addValue("responsible_organization_name", exam.getResponsibleOrganizationName())
                .addValue("test_administrator_name", exam.getTestAdministratorName())
                .addValue("session_platform_user_agent", exam.getSessionPlatformUserAgent())
                .addValue("test_delivery_server", exam.getTestDeliveryServer())
                .addValue("test_delivery_db", exam.getTestDeliveryDb())
                .addValue("window_opportunity_count", exam.getWindowOpportunityCount())
                .addValue("theta_score", exam.getThetaScore())
                .addValue("theta_score_std_err", exam.getThetaScoreStdErr())
                .addValue("grade_id", studentExamAttributes.getGradeId())
                .addValue("student_id", studentExamAttributes.getStudentId())
                .addValue("school_id", studentExamAttributes.getResponsibleSchoolId())
                .addValue("iep", studentExamAttributes.getIdeaIndicator())
                .addValue("lep", studentExamAttributes.getLep())
                .addValue("section504", studentExamAttributes.getSection504())
                .addValue("economic_disadvantage", studentExamAttributes.getEconomicDisadvantage())
                .addValue("migrant_status", studentExamAttributes.getMigrantStatus())
                .addValue("eng_prof_lvl", studentExamAttributes.getEngProfLvl())
                .addValue("t3_program_type", studentExamAttributes.getT3ProgramType())
                .addValue("language_id", studentExamAttributes.getLanguageId())
                .addValue("military_connected_id", studentExamAttributes.getMilitaryConnectedId())
                .addValue("prim_disability_type", studentExamAttributes.getPrimDisabilityType())
                .addValue("examinee_id", studentExamAttributes.getExamineeId())
                .addValue("elas_id", studentExamAttributes.getElasId())
                .addValue("elas_start_at", studentExamAttributes.getElasStartDate())
                .getValues();
    }

    // shallow equals check on Exam
    private static boolean equivalent(final Exam e1, final Exam e2) {
        return Objects.equals(e1.getTypeId(), e2.getTypeId())
                && Objects.equals(e1.getSchoolYear(), e2.getSchoolYear())
                && Objects.equals(e1.getAssessmentId(), e2.getAssessmentId())
                && Objects.equals(e1.getAsmtVersion(), e2.getAsmtVersion())
                && Objects.equals(e1.getOpportunity(), e2.getOpportunity())
                && Objects.equals(e1.getOppId(), e2.getOppId())
                && Objects.equals(e1.getCompletenessId(), e2.getCompletenessId())
                && Objects.equals(e1.getAdministrationConditionId(), e2.getAdministrationConditionId())
                && Objects.equals(e1.getSessionId(), e2.getSessionId())
                && JdbcUtil.equivalent(e1.getScaleScore(), e2.getScaleScore())
                && JdbcUtil.equivalent(e1.getScaleScoreStdErr(), e2.getScaleScoreStdErr())
                && Objects.equals(e1.getPerformanceLevel(), e2.getPerformanceLevel())
                && Objects.equals(e1.getCompletedAt(), e2.getCompletedAt())
                && Objects.equals(e1.getStatusDate(), e2.getStatusDate())
                && Objects.equals(e1.isDeleted(), e2.isDeleted())
                && Objects.equals(e1.getDeliverMode(), e2.getDeliverMode())
                && Objects.equals(e1.getHandScoreProject(), e2.getHandScoreProject())
                && Objects.equals(e1.getContract(), e2.getContract())
                && Objects.equals(e1.getTestReason(), e2.getTestReason())
                && Objects.equals(e1.getAssessmentAdminStartedAt(), e2.getAssessmentAdminStartedAt())
                && Objects.equals(e1.getStartedAt(), e2.getStartedAt())
                && Objects.equals(e1.getForceSubmittedAt(), e2.getForceSubmittedAt())
                && Objects.equals(e1.getStatus(), e2.getStatus())
                && Objects.equals(e1.getItemCount(), e2.getItemCount())
                && Objects.equals(e1.getFieldTestCount(), e2.getFieldTestCount())
                && Objects.equals(e1.getPauseCount(), e2.getPauseCount())
                && Objects.equals(e1.getGracePeriodRestarts(), e2.getGracePeriodRestarts())
                && Objects.equals(e1.getAbnormalStarts(), e2.getAbnormalStarts())
                && Objects.equals(e1.getTestWindowId(), e2.getTestWindowId())
                && Objects.equals(e1.getTestAdministratorId(), e2.getTestAdministratorId())
                && Objects.equals(e1.getResponsibleOrganizationName(), e2.getResponsibleOrganizationName())
                && Objects.equals(e1.getTestAdministratorName(), e2.getTestAdministratorName())
                && Objects.equals(e1.getSessionPlatformUserAgent(), e2.getSessionPlatformUserAgent())
                && Objects.equals(e1.getTestDeliveryServer(), e2.getTestDeliveryServer())
                && Objects.equals(e1.getTestDeliveryDb(), e2.getTestDeliveryDb())
                && Objects.equals(e1.getWindowOpportunityCount(), e2.getWindowOpportunityCount())
                && JdbcUtil.equivalent(e1.getThetaScore(), e2.getThetaScore())
                && JdbcUtil.equivalent(e1.getThetaScoreStdErr(), e2.getThetaScoreStdErr())
                && Objects.equals(e1.getStudentExamAttributes().getGradeId(), e2.getStudentExamAttributes().getGradeId())
                && Objects.equals(e1.getStudentExamAttributes().getStudentId(), e2.getStudentExamAttributes().getStudentId())
                && Objects.equals(e1.getStudentExamAttributes().getResponsibleSchoolId(), e2.getStudentExamAttributes().getResponsibleSchoolId())
                && Objects.equals(e1.getStudentExamAttributes().getIdeaIndicator(), e2.getStudentExamAttributes().getIdeaIndicator())
                && Objects.equals(e1.getStudentExamAttributes().getLep(), e2.getStudentExamAttributes().getLep())
                && Objects.equals(e1.getStudentExamAttributes().getSection504(), e2.getStudentExamAttributes().getSection504())
                && Objects.equals(e1.getStudentExamAttributes().getEconomicDisadvantage(), e2.getStudentExamAttributes().getEconomicDisadvantage())
                && Objects.equals(e1.getStudentExamAttributes().getMigrantStatus(), e2.getStudentExamAttributes().getMigrantStatus())
                && Objects.equals(e1.getStudentExamAttributes().getEngProfLvl(), e2.getStudentExamAttributes().getEngProfLvl())
                && Objects.equals(e1.getStudentExamAttributes().getT3ProgramType(), e2.getStudentExamAttributes().getT3ProgramType())
                && Objects.equals(e1.getStudentExamAttributes().getLanguageId(), e2.getStudentExamAttributes().getLanguageId())
                && Objects.equals(e1.getStudentExamAttributes().getMilitaryConnectedId(), e2.getStudentExamAttributes().getMilitaryConnectedId())
                && Objects.equals(e1.getStudentExamAttributes().getPrimDisabilityType(), e2.getStudentExamAttributes().getPrimDisabilityType())
                && Objects.equals(e1.getStudentExamAttributes().getExamineeId(), e2.getStudentExamAttributes().getExamineeId())
                && Objects.equals(e1.getStudentExamAttributes().getElasId(), e2.getStudentExamAttributes().getElasId())
                && Objects.equals(e1.getStudentExamAttributes().getElasStartDate(), e2.getStudentExamAttributes().getElasStartDate());
    }

    // ************************************************************************
    // Helpers for dealing with exam claims
    // ************************************************************************

    /**
     * Upsert the exam claims. Calculate the exact db changes needed. This approach is necessary
     * because changes to exam claims are audited and we don't want to put false entries in the
     * audit trail.
     *
     * @param submitted submitted exam claims
     * @param examId exam id
     * @return true if there were any changes needed
     */
    private boolean upsertExamClaims(final List<ExamClaim> submitted, final long examId) {
        final List<ExamClaim> existing = jdbcTemplate
                .query(sqlExamClaimScoreFindByExamId, new MapSqlParameterSource("exam_id", examId), ExamClaimRowMapper);

        // loop through modifying lists so that:
        //   submitted - unchanged (don't mess with collection parameter passed in)
        //   created - contains those needing to be created
        //   existing - contains those needing to be deleted
        //   updated - contains those needing to be updated
        final List<ExamClaim> updated = newArrayList();
        final List<ExamClaim> created = newArrayList();
        for (final ExamClaim claim : submitted) {
            final int found = Iterables.indexOf(existing, c -> c != null && c.getClaimId() == claim.getClaimId());
            if (found == -1) {
                created.add(claim);
                continue;
            }
            final ExamClaim exists = existing.remove(found);
            if (!equivalent(claim, exists)) {
                // need the new claim with the existing id
                updated.add(claim.copy().id(exists.getId()).build());
            }
        }

        if (!updated.isEmpty()) {
            jdbcTemplate.batchUpdate(sqlExamClaimScoreUpdate, updated.stream()
                .map(c -> new MapSqlParameterSource("id", c.getId()).addValues(toSqlParams(c)))
                .toArray(MapSqlParameterSource[]::new));
        }
        if (!created.isEmpty()) {
            createExamClaims(created, examId);
        }
        if (!existing.isEmpty()) {
            jdbcTemplate.update(sqlExamClaimScoreDelete,
                    new MapSqlParameterSource("ids", existing.stream().map(ExamClaim::getId).collect(toList())));

        }

        return !updated.isEmpty() || !created.isEmpty() || !existing.isEmpty();
    }

    private void createExamClaims(final List<ExamClaim> examClaims, final long examId) {
        if (examClaims.isEmpty()) return;

        jdbcTemplate.batchUpdate(sqlExamClaimScoreCreate, examClaims.stream()
            .map(c -> new MapSqlParameterSource("exam_id", examId).addValues(toSqlParams(c)))
            .toArray(MapSqlParameterSource[]::new));
    }

    private static final RowMapper<ExamClaim> ExamClaimRowMapper = (row, rowNum) -> ExamClaim.builder()
            .id(row.getLong("id"))
            .claimId(row.getInt("subject_claim_score_id"))
            .scaleScore(getNullable(row, row.getDouble("scale_score")))
            .scaleScoreStdErr(getNullable(row, row.getDouble("scale_score_std_err")))
            .thetaScore(getNullable(row, row.getDouble("theta_score")))
            .thetaScoreStdErr(getNullable(row, row.getDouble("theta_score_std_err")))
            .category(getNullable(row, row.getInt("category")))
            .build();

    private static Map<String, Object> toSqlParams(final ExamClaim examClaim) {
        return new MapSqlParameterSource()
                .addValue("subject_claim_score_id", examClaim.getClaimId())
                .addValue("scale_score", examClaim.getScaleScore())
                .addValue("scale_score_std_err", examClaim.getScaleScoreStdErr())
                .addValue("theta_score", examClaim.getThetaScore())
                .addValue("theta_score_std_err", examClaim.getThetaScoreStdErr())
                .addValue("category", examClaim.getCategory())
                .getValues();
    }

    private static boolean equivalent(final ExamClaim ec1, final ExamClaim ec2) {
        return Objects.equals(ec1.getClaimId(), ec2.getClaimId())
                && JdbcUtil.equivalent(ec1.getScaleScore(), ec2.getScaleScore())
                && JdbcUtil.equivalent(ec1.getScaleScoreStdErr(), ec2.getScaleScoreStdErr())
                && JdbcUtil.equivalent(ec1.getThetaScore(), ec2.getThetaScore())
                && JdbcUtil.equivalent(ec1.getThetaScoreStdErr(), ec2.getThetaScoreStdErr())
                && Objects.equals(ec1.getCategory(), ec2.getCategory());
    }

    // ************************************************************************
    // Helpers for dealing with exam targets
    // ************************************************************************

    /**
     * Upsert the exam targets. Calculate the exact db changes needed. This approach is necessary
     * because changes to exam targets are audited and we don't want to put false entries in the
     * audit trail.
     *
     * @param submitted submitted exam targets
     * @param examId exam id
     * @return true if there were any changes needed
     */
    private boolean upsertExamTargets(final List<ExamTarget> submitted, final long examId) {
        // get existing targets for the exam
        final List<ExamTarget> existing = jdbcTemplate
                .query(sqlExamTargetScoreFindByExamId, new MapSqlParameterSource("exam_id", examId), ExamTargetRowMapper);

        // loop through modifying lists so that:
        //   submitted - unchanged (don't mess with collection parameter passed in)
        //   created - contains those needing to be created
        //   existing - contains those needing to be deleted
        //   updated - contains those needing to be updated
        final List<ExamTarget> updated = newArrayList();
        final List<ExamTarget> created = newArrayList();
        for (final ExamTarget target : submitted) {
            final int found = Iterables.indexOf(existing, t -> t != null && t.getTargetId() == target.getTargetId());
            if (found == -1) {
                created.add(target);
                continue;
            }
            final ExamTarget exists = existing.remove(found);
            if (!equivalent(target, exists)) {
                // need the new target with the existing id
                updated.add(target.copy().id(exists.getId()).build());
            }
        }

        if (!updated.isEmpty()) {
            jdbcTemplate.batchUpdate(sqlExamTargetScoreUpdate, updated.stream()
                .map(t -> new MapSqlParameterSource("id", t.getId()).addValues(toSqlParams(t)))
                .toArray(MapSqlParameterSource[]::new));
        }
        if (!created.isEmpty()) {
            createExamTargets(created, examId);
        }
        if (!existing.isEmpty()) {
            jdbcTemplate.update(sqlExamTargetScoreDelete,
                    new MapSqlParameterSource("ids", existing.stream().map(ExamTarget::getId).collect(toList())));
        }

        return !(updated.isEmpty() && created.isEmpty() && existing.isEmpty());
    }

    private void createExamTargets(final List<ExamTarget> examTargets, final long examId) {
        if (examTargets.isEmpty()) return;

        jdbcTemplate.batchUpdate(sqlExamTargetScoreCreate, examTargets.stream()
                .map(t -> new MapSqlParameterSource("exam_id", examId).addValues(toSqlParams(t)))
                .toArray(MapSqlParameterSource[]::new));
    }

    private static final RowMapper<ExamTarget> ExamTargetRowMapper = (row, rowNum) -> ExamTarget.builder()
            .id(row.getLong("id"))
            .targetId(row.getInt("target_id"))
            .studentRelativeResidualScore(getNullable(row, row.getDouble("student_relative_residual_score")))
            .standardMetRelativeResidualScore(getNullable(row, row.getDouble("standard_met_relative_residual_score")))
            .build();

    private static Map<String, Object> toSqlParams(final ExamTarget examTarget) {
        return new MapSqlParameterSource()
                .addValue("target_id", examTarget.getTargetId())
                .addValue("student_relative_residual_score", examTarget.getStudentRelativeResidualScore())
                .addValue("standard_met_relative_residual_score", examTarget.getStandardMetRelativeResidualScore())
                .getValues();
    }

    private static boolean equivalent(final ExamTarget et1, final ExamTarget et2) {
        return Objects.equals(et1.getTargetId(), et2.getTargetId())
                && JdbcUtil.equivalent(et1.getStudentRelativeResidualScore(), et2.getStudentRelativeResidualScore())
                && JdbcUtil.equivalent(et1.getStandardMetRelativeResidualScore(), et2.getStandardMetRelativeResidualScore());
    }

    // ************************************************************************
    // Helpers for dealing with exam items
    // ************************************************************************

    private boolean upsertExamItems(final List<ExamItem> submittedItems, final long examId) {
        final Map<Integer, ExamItem> existingItemsByItemId = findExamItemsByExamId(examId).stream()
                .collect(Collectors.toMap(
                        ExamItem::getItemId,
                        item -> item
                ));

        final Map<Long, ExamItem> updated = new HashMap<>();
        final List<ExamItem> newItems = new ArrayList<>();

        for (final ExamItem item : submittedItems) {
            final ExamItem existing = existingItemsByItemId.get(item.getItemId());
            if (existing == null) {
                newItems.add(item);
                continue;
            }

            existingItemsByItemId.remove(item.getItemId());
            if (!equivalent(existing, item)) {
                updated.put(existing.getId(), item);
            }
        }

        updateExamItems(updated);
        createExamItems(newItems, examId);
        deleteExamItems(existingItemsByItemId.values().stream()
                .map(ExamItem::getId)
                .collect(toList()));
        return !updated.isEmpty() || !newItems.isEmpty() || !existingItemsByItemId.isEmpty();
    }

    private List<ExamItem> findExamItemsByExamId(final long examId) {
        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("exam_id", examId);

        return jdbcTemplate.query(sqlExamItemFindByExamId, parameters, ExamItemRowMapper);
    }

    private void createExamItems(final List<ExamItem> examItems, final long examId) {
        if (examItems.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = new MapSqlParameterSource[examItems.size()];
        for (int i = 0; i < examItems.size(); i++) {
            final ExamItem examItem = examItems.get(i);
            batchParameters[i] = new MapSqlParameterSource()
                    .addValue("exam_id", examId)
                    .addValues(toSqlParams(examItem));
        }

        jdbcTemplate.batchUpdate(sqlExamItemCreate, batchParameters);
    }

    private void updateExamItems(final Map<Long, ExamItem> examItems) {
        if (examItems.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = new MapSqlParameterSource[examItems.size()];
        int i = 0;
        for (final Map.Entry<Long, ExamItem> entry : examItems.entrySet()) {
            batchParameters[i++] = new MapSqlParameterSource()
                    .addValue("id", entry.getKey())
                    .addValues(toSqlParams(entry.getValue()));
        }

        jdbcTemplate.batchUpdate(sqlExamItemUpdate, batchParameters);
    }

    private void deleteExamItems(final Collection<Long> examItemIds) {
        if (examItemIds.isEmpty()) return;

        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("ids", examItemIds);

        jdbcTemplate.update(sqlExamItemDelete, parameters);
    }

    private static final RowMapper<ExamItem> ExamItemRowMapper = (row, rowNum) -> {
        final List<ExamItemSubScore> subScores = newArrayList(
                new ExamItemSubScore(EvidenceAndElaboration,
                        getNullable(row, row.getDouble("trait_evidence_elaboration_score")),
                        row.getString("trait_evidence_elaboration_score_status")),
                new ExamItemSubScore(OrganizationAndPurpose,
                        getNullable(row, row.getDouble("trait_organization_purpose_score")),
                        row.getString("trait_organization_purpose_score_status")),
                new ExamItemSubScore(Conventions,
                        getNullable(row, row.getDouble("trait_conventions_score")),
                        row.getString("trait_conventions_score_status"))
        );

        return ExamItem.builder()
                .id(row.getLong("id"))
                .itemId(row.getInt("item_id"))
                .score(row.getDouble("score"))
                .scoreStatus(row.getString("score_status"))
                .position(row.getInt("position"))
                .response(row.getString("response"))
                .subScoreList(subScores)
                .administeredAt(toInstantOrNull(row.getTimestamp("administered_at")))
                .submittedAt(toInstantOrNull(row.getTimestamp("submitted_at")))
                .numberOfVisits(getNullable(row, row.getLong("number_of_visits")))
                .responseDuration(getNullable(row, row.getDouble("response_duration")))
                .responseContentType(row.getString("response_content_type"))
                .pageNumber(getNullable(row, row.getLong("page_number")))
                .pageVisits(getNullable(row, row.getLong("page_visits")))
                .pageTime(getNullable(row, row.getInt("page_time")))
                .responseTypeId(getNullable(row, row.getInt("response_type_id")))
                .submitted(getNullable(row, row.getInt("submitted")))
                .build();
    };

    private static Map<String, Object> toSqlParams(final ExamItem examItem) {
        final MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("item_id", examItem.getItemId())
                .addValue("response", safeText(examItem.getResponse()))
                .addValue("score_status", examItem.getScoreStatus())
                .addValue("score", examItem.getScore())
                .addValue("position", examItem.getPosition())
                .addValue("administered_at", toTimeStampOrNull(examItem.getAdministeredAt()))
                .addValue("submitted_at", toTimeStampOrNull(examItem.getSubmittedAt()))
                .addValue("number_of_visits", examItem.getNumberOfVisits())
                .addValue("response_duration", examItem.getResponseDuration())
                .addValue("response_content_type", examItem.getResponseContentType())
                .addValue("page_number", examItem.getPageNumber())
                .addValue("page_visits", examItem.getPageVisits())
                .addValue("page_time", examItem.getPageTime())
                .addValue("response_type_id", examItem.getResponseTypeId())
                .addValue("submitted", examItem.getSubmitted());

        final ExamItemSubScore evidenceElaborationScore = examItem.getEvidenceAndElaborationSubScore();
        params.addValue("trait_evidence_elaboration_score", evidenceElaborationScore == null ? null : evidenceElaborationScore.getScore())
                .addValue("trait_evidence_elaboration_score_status", evidenceElaborationScore == null ? null : evidenceElaborationScore.getScoreStatus());

        final ExamItemSubScore organizationPurposeSubScore = examItem.getOrganizationAndPurposeSubScore();
        params.addValue("trait_organization_purpose_score", organizationPurposeSubScore == null ? null : organizationPurposeSubScore.getScore())
                .addValue("trait_organization_purpose_score_status", organizationPurposeSubScore == null ? null : organizationPurposeSubScore.getScoreStatus());

        final ExamItemSubScore conventionsSubScore = examItem.getConventionsSubScore();
        params.addValue("trait_conventions_score", conventionsSubScore == null ? null : conventionsSubScore.getScore())
                .addValue("trait_conventions_score_status", conventionsSubScore == null ? null : conventionsSubScore.getScoreStatus());

        return params.getValues();
    }

    private static boolean equivalent(final ExamItem ei1, final ExamItem ei2) {
        return Objects.equals(ei1.getItemId(), ei2.getItemId())
                && JdbcUtil.equivalent(ei1.getScore(), ei2.getScore())
                && Objects.equals(ei1.getScoreStatus(), ei2.getScoreStatus())
                && Objects.equals(ei1.getResponse(), ei2.getResponse())
                && Objects.equals(ei1.getPosition(), ei2.getPosition())
                && Objects.equals(ei1.getAdministeredAt(), ei2.getAdministeredAt())
                && Objects.equals(ei1.getSubmitted(), ei2.getSubmitted())
                && Objects.equals(ei1.getSubmittedAt(), ei2.getSubmittedAt())
                && Objects.equals(ei1.getNumberOfVisits(), ei2.getNumberOfVisits())
                && JdbcUtil.equivalent(ei1.getResponseDuration(), ei2.getResponseDuration())
                && Objects.equals(ei1.getResponseContentType(), ei2.getResponseContentType())
                && Objects.equals(ei1.getPageNumber(), ei2.getPageNumber())
                && Objects.equals(ei1.getPageVisits(), ei2.getPageVisits())
                && Objects.equals(ei1.getPageTime(), ei2.getPageTime())
                && Objects.equals(ei1.getResponseTypeId(), ei2.getResponseTypeId())
                && Objects.equals(ei1.getConventionsSubScore(), ei2.getConventionsSubScore())
                && Objects.equals(ei1.getEvidenceAndElaborationSubScore(), ei2.getEvidenceAndElaborationSubScore())
                && Objects.equals(ei1.getOrganizationAndPurposeSubScore(), ei2.getOrganizationAndPurposeSubScore());
    }

    private boolean upsertAccommodations(final List<Integer> submittedAccommodationIds, final long examId) {
        final List<Integer> existingAccommodations = findAccommodationsByExamId(examId);

        final List<Integer> newAccommodations = newArrayList(submittedAccommodationIds);
        newAccommodations.removeAll(existingAccommodations);
        existingAccommodations.removeAll(submittedAccommodationIds);

        addAccommodations(newAccommodations, examId);
        deleteAccommodations(existingAccommodations, examId);
        return !newAccommodations.isEmpty() || !existingAccommodations.isEmpty();
    }

    private List<Integer> findAccommodationsByExamId(final long examId) {
        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("exam_id", examId);

        return jdbcTemplate.queryForList(
                sqlExamAccommodationFindByExamId,
                parameters,
                Integer.class);
    }

    private void addAccommodations(final List<Integer> accommodationIds, final long examId) {
        if (accommodationIds.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = new MapSqlParameterSource[accommodationIds.size()];
        for (int i = 0; i < accommodationIds.size(); i++) {
            final Integer accommodationId = accommodationIds.get(i);
            batchParameters[i] = new MapSqlParameterSource("exam_id", examId)
                    .addValue("accommodation_id", accommodationId);
        }

        jdbcTemplate.batchUpdate(sqlExamAccommodationCreate, batchParameters);
    }

    private void deleteAccommodations(final List<Integer> accommodationIds, final long examId) {
        if (accommodationIds.isEmpty()) return;

        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("exam_id", examId)
                .addValue("accommodation_ids", accommodationIds);

        jdbcTemplate.update(sqlExamAccommodationDelete, parameters);
    }

    private static Timestamp toTimeStampOrNull(final Instant instant) {
        return instant == null ? null : Timestamp.from(instant);
    }

    private static Instant toInstantOrNull(final Timestamp timestamp) {
        return timestamp == null ? null : timestamp.toInstant();
    }

    private static LocalDate getNullableLocalDate(final ResultSet rs, final Date localDate) throws SQLException {
        return rs.wasNull() ? null : localDate.toLocalDate();
    }
}
