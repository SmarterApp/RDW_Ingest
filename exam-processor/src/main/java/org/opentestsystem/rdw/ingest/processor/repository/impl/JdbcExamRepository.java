package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.model.ExamClaim;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.ExamItemSubScore;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.repository.ExamRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.ingest.common.repository.JdbcUtils.safeText;
import static org.opentestsystem.rdw.ingest.processor.model.ExamItem.Conventions;
import static org.opentestsystem.rdw.ingest.processor.model.ExamItem.EvidenceAndElaboration;
import static org.opentestsystem.rdw.ingest.processor.model.ExamItem.OrganizationAndPurpose;

@Repository
class JdbcExamRepository implements ExamRepository {
    private final static Logger logger = LoggerFactory.getLogger(JdbcExamRepository.class);

    private final NamedParameterJdbcTemplate jdbcTemplate;

    @Value("${sql.exam.examClaimScore.create}")
    private String sqlExamClaimScoreCreate;

    @Value("${sql.exam.examClaimScore.update}")
    private String sqlExamClaimScoreUpdate;

    @Value("${sql.exam.examClaimScore.delete}")
    private String sqlExamClaimScoreDelete;

    @Value("${sql.exam.examClaimScore.findByExamId}")
    private String sqlExamClaimScoreFindByExamId;

    @Value("${sql.exam.examItem.create}")
    private String sqlExamItemCreate;

    @Value("${sql.exam.examItem.update}")
    private String sqlExamItemUpdate;

    @Value("${sql.exam.examItem.delete}")
    private String sqlExamItemDelete;

    @Value("${sql.exam.examItem.findByExamId}")
    private String sqlExamItemFindByExamId;

    @Value("${sql.exam.create}")
    private String sqlCreate;

    @Value("${sql.exam.update}")
    private String sqlUpdate;

    @Value("${sql.exam.findOne}")
    private String sqlFindOne;

    @Value("${sql.exam.accommodation.create}")
    private String sqlExamAccommodationCreate;

    @Value("${sql.exam.accommodation.delete}")
    private String sqlExamAccommodationDelete;

    @Value("${sql.exam.accommodation.findByExamId}")
    private String sqlExamAccommodationFindByExamId;

    @Autowired
    JdbcExamRepository(final NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Retryable(maxAttemptsExpression = "${jdbc.retry.default.max-attempts}", backoff = @Backoff(delayExpression = "${jdbc.retry.default.delay}"))
    @Transactional
    public long upsert(final Exam exam, final long importId) {
        final Exam existing = findOne(exam.getAssessmentId(), exam.getStudentExamAttributes().getStudentId(), exam.getOppId());
        if (existing == null) {
            return createExam(exam, importId);
        } else if (existing.getStatusDate() == null ||
                existing.getStatusDate().equals(exam.getStatusDate()) ||
                existing.getStatusDate().isBefore(exam.getStatusDate())) {
            return updateExamAndChildren(exam, existing, importId);
        } else {
            logger.info("Ignoring TDSReport with early statusDate. Import: {}, Existing statusDate: {}, Posted statusDate: {}",
                    importId, existing.getStatusDate(), exam.getStatusDate());
            return existing.getId();
        }
    }

    private long updateExamAndChildren(final Exam submitted, final Exam existing, final long importId) {
        boolean updated = upsertExamClaims(submitted.getExamClaims(), existing.getId());
        updated |= upsertExamItems(submitted.getExamItems(), existing.getId());
        updated |= upsertAccommodations(submitted.getAccommodationIds(), existing.getId());

        if (updated || !existing.equivalent(submitted)) {
            updateExam(submitted, existing.getId(), importId);
        }
        return existing.getId();
    }

    private Exam findOne(final long assessmentId, final int studentId, final String opportunityId) {
        final SqlParameterSource parameterSource = new MapSqlParameterSource()
                .addValue("asmt_id", assessmentId)
                .addValue("student_id", studentId)
                .addValue("opportunity_id", opportunityId);
        try {
            return jdbcTemplate.queryForObject(sqlFindOne,
                    parameterSource,
                    (row, rowNum) -> {
                            final StudentExamAttributes attributes = StudentExamAttributes.builder()
                                    .gradeId(row.getInt("grade_id"))
                                    .studentId(row.getInt("student_id"))
                                    .responsibleSchoolId(row.getInt("school_id"))
                                    .ideaIndicator(row.getBoolean("iep"))
                                    .lep(row.getBoolean("lep"))
                                    .section504(row.getBoolean("section504"))
                                    .economicDisadvantage(row.getBoolean("economic_disadvantage"))
                                    .migrantStatus(row.getBoolean("migrant_status"))
                                    .engProfLvl(row.getString("eng_prof_lvl"))
                                    .t3ProgramType(row.getString("t3_program_type"))
                                    .languageCode(row.getString("language_code"))
                                    .primDisabilityType(row.getString("prim_disability_type"))
                                    .build();
                            return Exam.builder()
                                    .studentExamAttributes(attributes)
                                    .id(row.getLong("id"))
                                    .typeId(row.getInt("type_id"))
                                    .schoolYear(row.getInt("school_year"))
                                    .assessmentId(row.getInt("asmt_id"))
                                    .asmtVersion(row.getString("asmt_version"))
                                    .opportunity(row.getLong("opportunity"))
                                    .oppId(row.getString("oppId"))
                                    .completenessId(row.getInt("completeness_id"))
                                    .administrationConditionId(row.getInt("administration_condition_id"))
                                    .sessionId(row.getString("session_id"))
                                    .scaleScore(row.getDouble("scale_score"))
                                    .scaleScoreStdErr(row.getDouble("scale_score_std_err"))
                                    .performanceLevel(row.getInt("performance_level"))
                                    .completedAt(row.getTimestamp("completed_at").toInstant())
                                    .statusDate(row.getTimestamp("status_date") == null ? null : row.getTimestamp("status_date").toInstant())
                                    .deleted(row.getBoolean("deleted"))
                                    .build();
                    });
        } catch (final EmptyResultDataAccessException e) {
            return null;
        }
    }

    private long createExam(final Exam exam, final long importId) {

        final KeyHolder keyHolder = new GeneratedKeyHolder();
        final SqlParameterSource parameterSource = new MapSqlParameterSource()
                .addValue("import_id", importId)
                .addValue("update_import_id", importId)
                .addValues(toSqlParams(exam));

        jdbcTemplate.update(sqlCreate, parameterSource, keyHolder);
        final Long id = keyHolder.getKey().longValue();
        createExamClaims(exam.getExamClaims(), id);
        createExamItems(exam.getExamItems(), id);
        addAccommodations(exam.getAccommodationIds(), id);
        return id;
    }

    private void updateExam(final Exam exam, final long examId, final long importId) {
        final SqlParameterSource parameterSource = new MapSqlParameterSource()
                .addValue("id", examId)
                .addValue("update_import_id", importId)
                .addValues(toSqlParams(exam));
        final int updateCount = jdbcTemplate.update(sqlUpdate, parameterSource);

        if (updateCount != 1) {
            throw new IllegalStateException("Unable to update exam: " + exam.getId() + " Import: " + importId);
        }
    }

    private Map<String, Object> toSqlParams(final Exam exam) {
        final StudentExamAttributes studentExamAttributes = exam.getStudentExamAttributes();
        return new MapSqlParameterSource()
                .addValue("type_id", exam.getTypeId())
                .addValue("school_year", exam.getSchoolYear())
                .addValue("asmt_id", exam.getAssessmentId())
                .addValue("asmt_version", exam.getAsmtVersion())
                .addValue("opportunity", exam.getOpportunity())
                .addValue("oppId", exam.getOppId())
                .addValue("completeness_id", exam.getCompletenessId())
                .addValue("administration_condition_id", exam.getAdministrationConditionId())
                .addValue("session_id", exam.getSessionId())
                .addValue("scale_score", exam.getScaleScore())
                .addValue("scale_score_std_err", exam.getScaleScoreStdErr())
                .addValue("performance_level", exam.getPerformanceLevel())
                .addValue("completed_at", Timestamp.from(exam.getCompletedAt()))
                .addValue("status_date", exam.getStatusDate() == null ? null : Timestamp.from(exam.getStatusDate()))
                .addValue("deleted", exam.isDeleted())
                .addValue("grade_id", studentExamAttributes.getGradeId())
                .addValue("student_id", studentExamAttributes.getStudentId())
                .addValue("school_id", studentExamAttributes.getResponsibleSchoolId())
                .addValue("iep", studentExamAttributes.getIdeaIndicator())
                .addValue("lep", studentExamAttributes.getLep())
                .addValue("section504", studentExamAttributes.getSection504())
                .addValue("economic_disadvantage", studentExamAttributes.getEconomicDisadvantage())
                .addValue("migrant_status", studentExamAttributes.getMigrantStatus())
                .addValue("eng_prof_lvl", studentExamAttributes.getEngProfLvl())
                .addValue("t3_program_type", studentExamAttributes.getT3ProgramType())
                .addValue("language_code", studentExamAttributes.getLanguageCode())
                .addValue("prim_disability_type", studentExamAttributes.getPrimDisabilityType())
                .getValues();
    }

    private boolean upsertExamClaims(final List<ExamClaim> submittedClaims, final long examId) {
        final Map<Integer, ExamClaim> existingClaimsById = findClaimsByExamId(examId).stream()
                .collect(Collectors.toMap(
                        ExamClaim::getClaimId,
                        claim -> claim
                ));

        final Map<Long, ExamClaim> updated = new HashMap<>();
        final List<ExamClaim> newClaims = new ArrayList<>();

        for (final ExamClaim claim : submittedClaims) {
            final ExamClaim existing = existingClaimsById.get(claim.getClaimId());
            if (existing == null) {
                newClaims.add(claim);
                continue;
            }

            existingClaimsById.remove(claim.getClaimId());
            if (!existing.equivalent(claim)) {
                updated.put(existing.getId(), claim);
            }
        }

        updateExamClaims(updated);
        createExamClaims(newClaims, examId);
        deleteExamClaims(existingClaimsById.values().stream()
                .map(ExamClaim::getId)
                .collect(Collectors.toList()));
        return !updated.isEmpty() || !newClaims.isEmpty() || !existingClaimsById.isEmpty();
    }

    private List<ExamClaim> findClaimsByExamId(final long examId)  {
        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("exam_id", examId);

        return jdbcTemplate.query(
                sqlExamClaimScoreFindByExamId,
                parameters,
                (row, rowNum) -> ExamClaim.builder()
                        .id(row.getLong("id"))
                        .claimId(row.getInt("subject_claim_score_id"))
                        .scaleScore(row.getDouble("scale_score"))
                        .scaleScoreStdErr(row.getDouble("scale_score_std_err"))
                        .category(row.getInt("category"))
                        .build());
    }

    private void createExamClaims(final List<ExamClaim> examClaims, final long examId) {
        if (examClaims.isEmpty()) return;

        final SqlParameterSource[] batchParameters = examClaims.stream()
                .map(examClaim -> new MapSqlParameterSource()
                        .addValue("exam_id", examId)
                        .addValues(toSqlParams(examClaim)))
                .toArray(MapSqlParameterSource[]::new);

        jdbcTemplate.batchUpdate(sqlExamClaimScoreCreate, batchParameters);
    }

    private void updateExamClaims(final Map<Long, ExamClaim> examClaimsById) {
        if (examClaimsById.isEmpty()) return;

        final SqlParameterSource[] batchParameters = examClaimsById.entrySet().stream()
                .map(entry -> new MapSqlParameterSource()
                        .addValue("id", entry.getKey())
                        .addValues(toSqlParams(entry.getValue())))
                .toArray(MapSqlParameterSource[]::new);

        jdbcTemplate.batchUpdate(sqlExamClaimScoreUpdate, batchParameters);
    }

    private void deleteExamClaims(final List<Long> claimIds) {
        if (claimIds.isEmpty()) return;

        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("ids", claimIds);

        jdbcTemplate.update(sqlExamClaimScoreDelete, parameters);
    }

    private Map<String, Object> toSqlParams(final ExamClaim examClaim) {
        return new MapSqlParameterSource()
                .addValue("subject_claim_score_id", examClaim.getClaimId())
                .addValue("scale_score", examClaim.getScaleScore())
                .addValue("scale_score_std_err", examClaim.getScaleScoreStdErr())
                .addValue("category", examClaim.getCategory())
                .getValues();
    }

    private boolean upsertExamItems(final List<ExamItem> submittedItems, final long examId) {
        final Map<Integer, ExamItem> existingItemsByItemId = findExamItemsByExamId(examId).stream()
                .collect(Collectors.toMap(
                        ExamItem::getItemId,
                        item -> item
                ));

        final Map<Long, ExamItem> updated = new HashMap<>();
        final List<ExamItem> newItems = new ArrayList<>();

        for (final ExamItem item : submittedItems) {
            final ExamItem existing = existingItemsByItemId.get(item.getItemId());
            if (existing == null) {
                newItems.add(item);
                continue;
            }

            existingItemsByItemId.remove(item.getItemId());
            if (!existing.equivalent(item)) {
                updated.put(existing.getId(), item);
            }
        }

        updateExamItems(updated);
        createExamItems(newItems, examId);
        deleteExamItems(existingItemsByItemId.values().stream()
                .map(ExamItem::getId)
                .collect(Collectors.toList()));
        return !updated.isEmpty() || !newItems.isEmpty() || !existingItemsByItemId.isEmpty();
    }

    private List<ExamItem> findExamItemsByExamId(final long examId) {
        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("exam_id", examId);

        return jdbcTemplate.query(
                sqlExamItemFindByExamId,
                parameters,
                (row, rowNum) -> {
                    final List<ExamItemSubScore> subScores = new ArrayList<>();

                    final Double evidenceElaborationScore = row.getDouble("trait_evidence_elaboration_score");
                    if (!row.wasNull()) {
                        subScores.add(new ExamItemSubScore(
                                EvidenceAndElaboration,
                                evidenceElaborationScore,
                                row.getString("trait_evidence_elaboration_score_status")));
                    }

                    final Double organizationPurposeScore = row.getDouble("trait_organization_purpose_score");
                    if (!row.wasNull()) {
                        subScores.add(new ExamItemSubScore(
                                OrganizationAndPurpose,
                                organizationPurposeScore,
                                row.getString("trait_organization_purpose_score_status")));
                    }

                    final Double conventionsScore = row.getDouble("trait_conventions_score");
                    if (!row.wasNull()) {
                        subScores.add(new ExamItemSubScore(
                                Conventions,
                                conventionsScore,
                                row.getString("trait_conventions_score_status")));
                    }

                    return ExamItem.builder()
                            .id(row.getLong("id"))
                            .itemId(row.getInt("item_id"))
                            .score(row.getDouble("score"))
                            .scoreStatus(row.getString("score_status"))
                            .position(row.getInt("position"))
                            .response(row.getString("response"))
                            .subScoreList(subScores)
                            .build();
                });
    }

    private void createExamItems(final List<ExamItem> examItems, final long examId) {
        if (examItems.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = new MapSqlParameterSource[examItems.size()];
        for (int i = 0; i < examItems.size(); i++) {
            final ExamItem examItem = examItems.get(i);
            batchParameters[i] = new MapSqlParameterSource()
                    .addValue("exam_id", examId)
                    .addValues(toSqlParams(examItem));
        }

        jdbcTemplate.batchUpdate(sqlExamItemCreate, batchParameters);
    }

    private void updateExamItems(final Map<Long, ExamItem> examItems) {
        if (examItems.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = new MapSqlParameterSource[examItems.size()];
        int i = 0;
        for (final Map.Entry<Long, ExamItem> entry : examItems.entrySet()) {
            batchParameters[i++] = new MapSqlParameterSource()
                    .addValue("id", entry.getKey())
                    .addValues(toSqlParams(entry.getValue()));
        }

        jdbcTemplate.batchUpdate(sqlExamItemUpdate, batchParameters);
    }

    private void deleteExamItems(final Collection<Long> examItemIds) {
        if (examItemIds.isEmpty()) return;

        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("ids", examItemIds);

        jdbcTemplate.update(sqlExamItemDelete, parameters);
    }

    private Map<String, Object> toSqlParams(final ExamItem examItem) {
        final MapSqlParameterSource params = new MapSqlParameterSource()
                .addValue("item_id", examItem.getItemId())
                .addValue("response", safeText(examItem.getResponse()))
                .addValue("score_status", examItem.getScoreStatus())
                .addValue("score", examItem.getScore())
                .addValue("position", examItem.getPosition());

        final ExamItemSubScore evidenceElaborationScore = examItem.getEvidenceAndElaborationSubScore();
        params
                .addValue("trait_evidence_elaboration_score", evidenceElaborationScore == null ? null : evidenceElaborationScore.getScore())
                .addValue("trait_evidence_elaboration_score_status", evidenceElaborationScore == null ? null : evidenceElaborationScore.getScoreStatus());

        final ExamItemSubScore organizationPurposeSubScore = examItem.getOrganizationAndPurposeSubScore();
        params
                .addValue("trait_organization_purpose_score", organizationPurposeSubScore == null ? null : organizationPurposeSubScore.getScore())
                .addValue("trait_organization_purpose_score_status", organizationPurposeSubScore == null ? null : organizationPurposeSubScore.getScoreStatus());

        final ExamItemSubScore conventionsSubScore = examItem.getConventionsSubScore();
        params
                .addValue("trait_conventions_score", conventionsSubScore == null ? null : conventionsSubScore.getScore())
                .addValue("trait_conventions_score_status", conventionsSubScore == null ? null : conventionsSubScore.getScoreStatus());
        return params.getValues();
    }

    private boolean upsertAccommodations(final List<Integer> submittedAccommodationIds, final long examId) {
        final List<Integer> existingAccommodations = findAccommodationsByExamId(examId);

        final List<Integer> newAccommodations = newArrayList(submittedAccommodationIds);
        newAccommodations.removeAll(existingAccommodations);
        existingAccommodations.removeAll(submittedAccommodationIds);

        addAccommodations(newAccommodations, examId);
        deleteAccommodations(existingAccommodations, examId);
        return !newAccommodations.isEmpty() || !existingAccommodations.isEmpty();
    }

    private List<Integer> findAccommodationsByExamId(final long examId) {
        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("exam_id", examId);

        return jdbcTemplate.queryForList(
                sqlExamAccommodationFindByExamId,
                parameters,
                Integer.class);
    }

    private void addAccommodations(final List<Integer> accommodationIds, final long examId) {
        if (accommodationIds.isEmpty()) return;

        final MapSqlParameterSource[] batchParameters = new MapSqlParameterSource[accommodationIds.size()];
        for (int i = 0; i < accommodationIds.size(); i++) {
            final Integer accommodationId = accommodationIds.get(i);
            batchParameters[i] = new MapSqlParameterSource("exam_id", examId)
                    .addValue("accommodation_id", accommodationId);
        }

        jdbcTemplate.batchUpdate(sqlExamAccommodationCreate, batchParameters);
    }

    private void deleteAccommodations(final List<Integer> accommodationIds, final long examId) {
        if (accommodationIds.isEmpty()) return;

        final MapSqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("exam_id", examId)
                .addValue("accommodation_ids", accommodationIds);

        jdbcTemplate.update(sqlExamAccommodationDelete, parameters);
    }
}
