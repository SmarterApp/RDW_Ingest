package org.opentestsystem.rdw.ingest.processor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.messaging.Message;

import java.io.ByteArrayInputStream;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.TDSReport;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.processor.service.TDSReportProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineResults;
import org.opentestsystem.rdw.script.ScriptRuntimeException;

import static org.opentestsystem.rdw.common.model.trt.XmlUtils.tdsReportFromXml;

@EnableBinding(Sink.class)
public class ExamProcessor {
    private static final Logger logger = LoggerFactory.getLogger(ExamProcessor.class);

    private static final String PIPELINE_NAME = "ExamPipeline";

    private final TDSReportProcessor reportProcessor;
    private final ImportRepository importRepository;
    private final Pipeline pipeline;

    @Autowired
    public ExamProcessor(final TDSReportProcessor reportProcessor,
                         final ImportRepository importRepository,
                         final PipelineFactory pipelineFactory) {
        this.reportProcessor = reportProcessor;
        this.importRepository = importRepository;
        this.pipeline = loadPipeline(pipelineFactory);
    }

    @ServiceActivator(inputChannel = Sink.INPUT)
    public void process(final Message<?> message) {
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(message);
        final byte[] payload = (byte[]) message.getPayload();
        final long importId = accessor.getImportId();

        logger.debug("received {} import {}", accessor.getContent(), importId);

        final TDSReport report;

        try {
            if (pipeline == null) {
                report = tdsReportFromXml(new ByteArrayInputStream(payload));
            } else {
                final PipelineResults results = pipeline.run(payload);
                logger.debug("Transformed TRT to: \n{}", results.asString());
                report = tdsReportFromXml(new ByteArrayInputStream(results.asByteArray()));
            }
        } catch (final ScriptRuntimeException e) {
            logger.info("pipeline failed to convert xml to tds report with error: " + e.getMessage());
            if (e.getCause() instanceof ImportException) {
                ImportException ie = (ImportException)e.getCause();
                importRepository.updateStatusAndMessageById(importId, ie.getStatus(), ie.getMessage());
            }
            return;
        } catch (final Exception e) {
            logger.info("pipeline failed to convert xml to tds report with error: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
            return;
        }

        try {
            reportProcessor.process(report, importId);
            importRepository.updateStatusAndMessageById(importId, ImportStatus.PROCESSED, null);
        } catch (final ImportException e) {
            logger.warn("processing caught import error missed by pipeline validation: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, e.getStatus(), e.getMessage());
        } catch (final Exception e) {
            logger.warn("failed with an unexpected error: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
        }
    }

    private Pipeline loadPipeline(final PipelineFactory factory) {
        // TODO: get current version from ?configuratino?
        final String version = "1.0";

        try {
            return factory.getPipeline(PIPELINE_NAME, "1.0");
        } catch (final PipelineBuildException e) {
            logger.error("Cannot load pipeline " + PIPELINE_NAME + ", v. " + version, e);
        }

        return null;
    }
}
