package org.opentestsystem.rdw.ingest.processor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.messaging.Message;
import org.springframework.util.MimeType;

import java.io.ByteArrayInputStream;
<<<<<<< develop
=======
import java.util.Optional;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportContent;
>>>>>>> RP-386: updates based on code review
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.TDSReport;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.common.util.TransformedPayloadArchiver;
import org.opentestsystem.rdw.ingest.processor.service.TDSReportProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineResults;
import org.opentestsystem.rdw.script.ScriptRuntimeException;

import static org.opentestsystem.rdw.common.model.trt.XmlUtils.tdsReportFromXml;
import static org.springframework.util.MimeTypeUtils.APPLICATION_XML;

@EnableBinding(Sink.class)
public class ExamProcessor {
    private static final Logger logger = LoggerFactory.getLogger(ExamProcessor.class);

    private static final String PipelineName = "ExamPipeline";

    // Expected type of document after pipeline processing.
    private static final MimeType ContentType = APPLICATION_XML;

    // The expected Import Content for this processor.
    private static final ImportContent Content = ImportContent.EXAM;

    private final TDSReportProcessor reportProcessor;
    private final ImportRepository importRepository;
    private final PipelineFactory pipelineFactory;
    private final ArchiveService archiveService;

    /**
     * @param reportProcessor the report processor
     * @param importRepository the import repository for updating import record state
     * @param pipelineFactory (exam) pipeline factory; expected to be tenant-aware and caching
     */
    @Autowired
    public ExamProcessor(final TDSReportProcessor reportProcessor,
                         final ImportRepository importRepository,
                         final PipelineFactory pipelineFactory,
                         final ArchiveService archiveService) {
        this.reportProcessor = reportProcessor;
        this.importRepository = importRepository;
        this.pipelineFactory = pipelineFactory;
        this.archiveService = archiveService;
    }

    @ServiceActivator(inputChannel = Sink.INPUT)
    public void process(final Message<?> message) {
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(message);
        final byte[] payload = (byte[]) message.getPayload();
        final long importId = accessor.getImportId();

        // set tenant context from message
<<<<<<< develop
        final String tenantId = accessor.getTenantId();
        if (tenantId == null) {
            logger.error("No tenant id found in {} message header for import {}", accessor.getContent(), importId);
            // updating the import status might seem like a good idea here, something like:
            // importRepository.updateStatusAndMessageById(importId, ImportStatus.INVALID, "System error: no tenant id found in message header");
            // but that won't work since we don't have a tenant context
            return;
        }
=======
        // TODO: breaks model of handling all exceptions internally.
        final String tenantId = Optional.ofNullable(accessor.getTenantId()).orElseThrow(() ->
                new IllegalArgumentException(
                        "no tenant id in " + accessor.getContent() + " message for import " + importId));
>>>>>>> RP-386: updates based on code review
        TenantContextHolder.setTenantId(tenantId);

        logger.debug("received {} import {} for tenant id {}", accessor.getContent(), importId, tenantId);

        // get the pipeline dynamically so it can use the current tenant
        // this expects the factory to deal with tenant and any caching
        // TODO - deal with version and whether a fail to load is okay or not
        final String pipelineVersion = "1";
        Pipeline pipeline = null;
        try {
            pipeline = pipelineFactory.getPipeline(PipelineName, pipelineVersion);
        } catch (final PipelineBuildException e) {
            logger.warn("Cannot load pipeline " + PipelineName + ", version " + pipelineVersion, e);
        }

        // Run input through pipeline
        final TDSReport report;
        try {
            if (pipeline == null) {
                report = tdsReportFromXml(new ByteArrayInputStream(payload));
            } else {
                // Run through pipeline and archive the transformation if any
                final PipelineResults results = pipeline.run(payload);
                final byte [] transformedPayload  = results.asByteArray();
                if (results.isModified()) {
                    TransformedPayloadArchiver.archive(payload, transformedPayload, Content, ContentType,
                            archiveService::writeResource);
                }
                report = tdsReportFromXml(new ByteArrayInputStream(transformedPayload));
            }
        } catch (final ScriptRuntimeException e) {
            logger.warn("pipeline failed to convert xml to tds report with error: " + e.getMessage());
            if (e.getCause() instanceof ImportException) {
                final ImportException ie = (ImportException)e.getCause();
                importRepository.updateStatusAndMessageById(importId, ie.getStatus(), ie.getMessage());
            } else {
                importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
            }
            return;
        } catch (final Exception e) {
            logger.warn("pipeline failed to convert xml to tds report with error: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
            return;
        }

        // Process the input report
        try {
            reportProcessor.process(report, importId);
            importRepository.updateStatusAndMessageById(importId, ImportStatus.PROCESSED, null);
        } catch (final ImportException e) {
            logger.warn("processing caught import error missed by pipeline validation: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, e.getStatus(), e.getMessage());
        } catch (final Exception e) {
            logger.warn("failed with an unexpected error: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
        }
    }
}
