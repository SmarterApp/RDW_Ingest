package org.opentestsystem.rdw.ingest.processor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.messaging.Message;

import java.io.ByteArrayInputStream;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.TDSReport;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.common.util.TransformedPayloadArchiver;
import org.opentestsystem.rdw.ingest.processor.service.TDSReportProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.ScriptRuntimeException;

import static org.opentestsystem.rdw.common.model.trt.XmlUtils.tdsReportFromXml;

@EnableBinding(Sink.class)
public class ExamProcessor {
    private static final Logger logger = LoggerFactory.getLogger(ExamProcessor.class);

    private static final String PipelineName = "ExamPipeline";

    private final TDSReportProcessor reportProcessor;
    private final ImportRepository importRepository;
    private final PipelineFactory pipelineFactory;
    private final ArchiveService archiveService;

    /**
     * @param reportProcessor the report processor
     * @param importRepository the import repository for updating import record state
     * @param pipelineFactory (exam) pipeline factory; expected to be tenant-aware and caching
     */
    @Autowired
    public ExamProcessor(final TDSReportProcessor reportProcessor,
                         final ImportRepository importRepository,
                         final PipelineFactory pipelineFactory,
                         final ArchiveService archiveService) {
        this.reportProcessor = reportProcessor;
        this.importRepository = importRepository;
        this.pipelineFactory = pipelineFactory;
        this.archiveService = archiveService;
    }

    @ServiceActivator(inputChannel = Sink.INPUT)
    public void process(final Message<?> message) {
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(message);
        final byte[] payload = (byte[]) message.getPayload();
        final long importId = accessor.getImportId();
        final TransformedPayloadArchiver archiver = new TransformedPayloadArchiver();

        // set tenant context from message
        final String tenantId = accessor.getTenantId();
        if (tenantId == null) {
            logger.error("No tenant id found in {} message header for import {}", accessor.getContent(), importId);
            // updating the import status might seem like a good idea here, something like:
            // importRepository.updateStatusAndMessageById(importId, ImportStatus.INVALID, "System error: no tenant id found in message header");
            // but that won't work since we don't have a tenant context
            return;
        }
        TenantContextHolder.setTenantId(tenantId);

        logger.debug("received {} import {} for tenant id {}", accessor.getContent(), importId, tenantId);

        // get the pipeline dynamically so it can use the current tenant
        // this expects the factory to deal with tenant and any caching
        // TODO - deal with version and whether a fail to load is okay or not
        final String PipelineVersion = "1";
        Pipeline pipeline = null;
        try {
            pipeline = pipelineFactory.getPipeline(PipelineName, PipelineVersion);
        } catch (final PipelineBuildException e) {
            logger.warn("Cannot load pipeline " + PipelineName + ", version " + PipelineVersion, e);
        }

        final TDSReport report;
        try {
            if (pipeline == null) {
                report = tdsReportFromXml(new ByteArrayInputStream(payload));
            } else {
                // Run through pipeline and archive the transformation if any
                final byte [] transformedPayload = pipeline.run(payload).asByteArray();
                archiver.archive(accessor, payload, transformedPayload, archiveService::writeResource);

                report = tdsReportFromXml(new ByteArrayInputStream(transformedPayload));
            }
        } catch (final ScriptRuntimeException e) {
            logger.warn("pipeline failed to convert xml to tds report with error: " + e.getMessage());
            if (e.getCause() instanceof ImportException) {
                final ImportException ie = (ImportException)e.getCause();
                importRepository.updateStatusAndMessageById(importId, ie.getStatus(), ie.getMessage());
            } else {
                importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
            }
            return;
        } catch (final Exception e) {
            logger.warn("pipeline failed to convert xml to tds report with error: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
            return;
        }

        try {
            reportProcessor.process(report, importId);
            importRepository.updateStatusAndMessageById(importId, ImportStatus.PROCESSED, null);
        } catch (final ImportException e) {
            logger.warn("processing caught import error missed by pipeline validation: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, e.getStatus(), e.getMessage());
        } catch (final Exception e) {
            logger.warn("failed with an unexpected error: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
        }
    }
}
