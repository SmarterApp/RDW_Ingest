package org.opentestsystem.rdw.ingest.processor;

import com.google.common.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Sink;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.messaging.Message;

import java.io.ByteArrayInputStream;
import java.util.Optional;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.TDSReport;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.common.script.PipelineException;
import org.opentestsystem.rdw.ingest.common.script.PipelineProcessor;
import org.opentestsystem.rdw.ingest.common.script.PipelineService;
import org.opentestsystem.rdw.ingest.common.script.PipelineType;
import org.opentestsystem.rdw.ingest.processor.service.TDSReportProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.multitenant.TenantContextHolder;

import static org.opentestsystem.rdw.common.model.trt.XmlUtils.tdsReportFromXml;

@EnableBinding(Sink.class)
public class ExamProcessor  extends PipelineProcessor {
    private static final Logger logger = LoggerFactory.getLogger(ExamProcessor.class);

    @VisibleForTesting
    static final PipelineType pipelineType = PipelineType.Exam;

    private final TDSReportProcessor reportProcessor;
    private final ArchiveService archiveService;

    /**
     * @param reportProcessor  the report processor
     * @param importRepository the import repository for updating import record state
     * @param pipelineService  pipeline service; expected to be tenant-aware and caching
     */
    @Autowired
    public ExamProcessor(final TDSReportProcessor reportProcessor,
                         final ImportRepository importRepository,
                         final PipelineService pipelineService,
                         final ArchiveService archiveService)
    {
        super(importRepository, pipelineService);
        this.reportProcessor = reportProcessor;
        this.archiveService = archiveService;
    }

    @ServiceActivator(inputChannel = Sink.INPUT)
    public void process(final Message<?> message) {
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(message);
        final byte[] payload = (byte[]) message.getPayload();
        final long importId = accessor.getImportId();

        // set tenant context from message
        final String tenantId = accessor.getTenantId();
        if (tenantId == null) {
            logger.error("No tenant id found in {} message header for import {}", accessor.getContent(), importId);
            // updating the import status might seem like a good idea here, something like:
            // importRepository.updateStatusAndMessageById(importId, ImportStatus.INVALID, "System error: no tenant id found in message header");
            // but that won't work since we don't have a tenant context
            return;
        }

        TenantContextHolder.setTenantId(tenantId);

        logger.debug("received {} import {} for tenant id {}", accessor.getContent(), importId, tenantId);

        // Process payload by pipeline if one exists
        byte[] preProcessedPayload;
        try {
            preProcessedPayload = processByPipeline(
                    Optional.of(pipelineType), payload, importId, archiveService::writeResource);
        } catch (PipelineException e) {
            logger.error("Failed to process {} import {} for tenant id {}: {}",
                    accessor.getContent(), importId, tenantId, e.getMessage());
            if (e.getCause() != null) {
                logger.error("Caused by:", e.getCause());
            }
            return;
        }

        final TDSReport report = tdsReportFromXml(new ByteArrayInputStream(preProcessedPayload));

        // Process the input report
        try {
            reportProcessor.process(report, importId);
            importRepository.updateStatusAndMessageById(importId, ImportStatus.PROCESSED, null);
        } catch (final ImportException e) {
            logger.warn("processing caught import error missed by pipeline validation: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, e.getStatus(), e.getMessage());
        } catch (final Exception e) {
            logger.warn("failed with an unexpected error: " + e.getMessage());
            importRepository.updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, e.getMessage());
        }
    }
}
