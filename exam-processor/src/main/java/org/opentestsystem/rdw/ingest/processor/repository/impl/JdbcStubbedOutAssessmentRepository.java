package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentRepository;
import org.opentestsystem.rdw.ingest.processor.repository.StubbedOutAssessmentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.BatchPreparedStatementSetter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcCall;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import java.util.stream.Collectors;


@Repository
class JdbcStubbedOutAssessmentRepository implements StubbedOutAssessmentRepository {

    private final JdbcTemplate jdbcTemplate;

    private final AssessmentRepository assessmentRepository;

    @Value("${sql.assessment.createItems}")
    private String sqlCreateItems;

    @Autowired
    JdbcStubbedOutAssessmentRepository(final JdbcTemplate jdbcTemplate,
                                       final AssessmentRepository assessmentRepository) {
        this.jdbcTemplate = jdbcTemplate;
        this.assessmentRepository = assessmentRepository;
    }

    @Transactional
    @Retryable(maxAttemptsExpression = "${jdbc.retry.default.max-attempts}", backoff = @Backoff(delayExpression = "${jdbc.retry.default.delay}"))
    @Override
    public Assessment create(final Assessment assessment, final long importId) {

        final int id = (int) new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("asmt_safe_create")
                .execute(new MapSqlParameterSource()
                        .addValue("p_natural_id", assessment.getNaturalId())
                        .addValue("p_name", assessment.getName())
                        .addValue("p_label", assessment.getLabel())
                        .addValue("p_grade_id", assessment.getGradeId())
                        .addValue("p_type_id", assessment.getTypeId())
                        .addValue("p_subject_id", assessment.getSubjectId())
                        .addValue("p_school_year", assessment.getSchoolYear())
                        .addValue("p_import_id", importId))
                .get("p_id");

        batchCreateItems(assessment.getItems().keySet().stream().collect(Collectors.toList()), id);
        return assessmentRepository.findOneByNaturalId(assessment.getNaturalId());
    }

    private void batchCreateItems(final List<String> items, final long assessmentId) {
        if (items.isEmpty()) return;

        jdbcTemplate.batchUpdate(sqlCreateItems, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(final PreparedStatement ps, final int i) throws SQLException {
                ps.setLong(1, assessmentId);
                ps.setLong(2, assessmentId);
                ps.setString(3, items.get(i));
                ps.setLong(4, assessmentId);
            }

            @Override
            public int getBatchSize() {
                return items.size();
            }
        });
    }
}