package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.trt.Context;
import org.opentestsystem.rdw.common.model.trt.Examinee;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeRelationship;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.StudentGroup;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toBoolean;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toBooleanOrNull;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLocalDateOrNull;

@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private static final String SchoolId = "SchoolId";

    private static final String FirstName = "FirstName";
    private static final String LastOrSurname = "LastOrSurname";
    private static final String MiddleName = "MiddleName";
    private static final String StudentIdentifier = "StudentIdentifier";
    private static final String Birthdate = "Birthdate";
    private static final String Sex = "Sex";
    private static final String FirstEntryDateIntoUSSchool = "FirstEntryDateIntoUSSchool";
    private static final String LimitedEnglishProficiencyEntryDate = "LimitedEnglishProficiencyEntryDate";
    private static final String LEPExitDate = "LEPExitDate";

    private static final String IDEAIndicator = "IDEAIndicator";
    private static final String LEPStatus = "LEPStatus";
    private static final String Section504Status = "Section504Status";
    private static final String EconomicDisadvantageStatus = "EconomicDisadvantageStatus";
    private static final String MigrantStatus = "MigrantStatus";
    private static final String LanguageCode = "LanguageCode";
    private static final String EnglishLanguageProficiencyLevel = "EnglishLanguageProficiencyLevel";
    private static final String TitleIIILanguageInstructionProgramType = "TitleIIILanguageInstructionProgramType";
    private static final String PrimaryDisabilityType = "PrimaryDisabilityType";
    private static final String GradeLevelWhenAssessed = "GradeLevelWhenAssessed";

    private static final String StudentGroupName = "StudentGroupName";


    private final GenderRepository genderRepository;
    private final EthnicityService ethnicityService;
    private final GradeRepository gradeRepository;
    private final SchoolRepository schoolRepository;

    @Autowired
    DefaultExamineeProcessor(final GenderRepository genderRepository,
                             final GradeRepository gradeRepository,
                             final EthnicityService ethnicityService,
                             final SchoolRepository schoolRepository) {
        this.genderRepository = genderRepository;
        this.gradeRepository = gradeRepository;
        this.ethnicityService = ethnicityService;
        this.schoolRepository = schoolRepository;
    }

    @Override
    public int parseSchoolId(final Examinee examinee) throws ImportException {
        final String naturalId = getBestRelationshipValue(examinee, SchoolId);
        final Integer schoolId = schoolRepository.findIdByNaturalId(naturalId);
        if (schoolId != null) return schoolId;
        throw new ImportException(ImportStatus.UNKNOWN_SCHOOL, "unable to find a school with natural id [" + naturalId + "]");
    }

    @Override
    public Student parseStudent(final Examinee examinee, final int schoolYear, final int schoolId) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final Student.Builder studentBuilder = Student.builder()
                .firstName(parserHelper.validate(FirstName, getBestAttributeValue(examinee, FirstName), 60, true))
                .lastOrSurname(parserHelper.validate(LastOrSurname, getBestAttributeValue(examinee, LastOrSurname), 60, true))
                .middleName(parserHelper.validate(MiddleName, getBestAttributeValue(examinee, MiddleName), 60, false))
                .ssid(parserHelper.validate(StudentIdentifier, getBestAttributeValue(examinee, StudentIdentifier), 65, true))
                .birthday(parserHelper.validate(Birthdate, getBestAttributeValue(examinee, Birthdate), LocalDate::parse))
                .genderId(parserHelper.validate(Sex, getBestAttributeValue(examinee, Sex), checkNotBlank.andThen(genderRepository::findIdByCode).andThen(new CheckNotNull<>())))
                .firsEntryIntoUSSchoolAt(parserHelper.validate(FirstEntryDateIntoUSSchool, getBestAttributeValue(examinee, FirstEntryDateIntoUSSchool), toLocalDateOrNull))
                .lepEntryAt(parserHelper.validate(LimitedEnglishProficiencyEntryDate, getBestAttributeValue(examinee, LimitedEnglishProficiencyEntryDate), toLocalDateOrNull))
                .lepExitAt(parserHelper.validate(LEPExitDate, getBestAttributeValue(examinee, LEPExitDate), toLocalDateOrNull))
                .ethnicityIds(ethnicityService.getEthnicity(examinee, errorCollector))
                .groups(parseGroups(examinee, schoolYear, schoolId, parserHelper));

        if (errorCollector.isEmpty()) return studentBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }

    @Override
    public StudentExamAttributes parseStudentExamAttributes(final Examinee examinee, final int schoolId, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);
        final StudentExamAttributes.Builder builder = StudentExamAttributes.builder()
                .ideaIndicator(parserHelper.validate(IDEAIndicator, getBestAttributeValue(examinee, IDEAIndicator), toBoolean))
                .lep(parserHelper.validate(LEPStatus, getBestAttributeValue(examinee, LEPStatus), toBoolean))
                .section504(parserHelper.validate(Section504Status, getBestAttributeValue(examinee, Section504Status), toSection504Status))
                .economicDisadvantage(parserHelper.validate(EconomicDisadvantageStatus, getBestAttributeValue(examinee, EconomicDisadvantageStatus), toBoolean))
                .migrantStatus(parserHelper.validate(MigrantStatus, getBestAttributeValue(examinee, MigrantStatus), toBooleanOrNull))
                .languageCode(parserHelper.validate(LanguageCode, getBestAttributeValue(examinee, LanguageCode), 3, false))
                .engProfLvl(parserHelper.validate(EnglishLanguageProficiencyLevel, getBestAttributeValue(examinee, EnglishLanguageProficiencyLevel), 20, false))
                .t3ProgramType(parserHelper.validate(TitleIIILanguageInstructionProgramType, getBestAttributeValue(examinee, TitleIIILanguageInstructionProgramType), 20, false))
                .primDisabilityType(parserHelper.validate(PrimaryDisabilityType, getBestAttributeValue(examinee, PrimaryDisabilityType), 3, false))
                .gradeId(parserHelper.validate(GradeLevelWhenAssessed, getBestAttributeValue(examinee, GradeLevelWhenAssessed), checkNotBlank.andThen(gradeRepository::findIdByCode).andThen(new CheckNotNull<>())))
                .responsibleSchoolId(schoolId);

        return errorCollector.isEmpty() ? builder.build() : null;
    }

    private List<StudentGroup> parseGroups(final Examinee examinee, final int schoolYear, final int schoolId, final ParserHelper parserHelper) {
        // deal with student groups: create groups if they don't already exist then add student to them
        final List<StudentGroup> groups = newArrayList();
        final Set<String> groupNames = getBestGroupNames(examinee);
        if (!groupNames.isEmpty()) {
            for (final String groupName : groupNames) {
                groups.add(StudentGroup.builder()
                        .name(parserHelper.validate("StudentGroupName", groupName, 255, true))
                        .schoolId(schoolId)
                        .schoolYear(schoolYear)
                        .active(true)
                        .build());
            }
        }
        return groups;
    }

    /**
     * Map of aliases for TRT attribute field names. The key is the documented TRT attribute field name,
     * while the value is an alternate name, typically from the DWSA (the CSV import file) spec.
     * These will be used when looking for attribute values; for now for efficiency, just string attributes.
     * Although it is unlikely that multiple entries will exist with different names, if that happens the
     * TRT-named attribute value will be favored.
     */
    private static final Map<String, String> FieldAliases = newHashMap();

    static {
        FieldAliases.put(StudentIdentifier, "SSID");
        FieldAliases.put(GradeLevelWhenAssessed, "Grade");
        FieldAliases.put(SchoolId, "ResponsibleInstitutionIdentifier");
    }

    private static String getBestAttributeValue(final Examinee examinee,
                                                final String element) {
        ExamineeAttribute attribute = examinee.getBestAttribute(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        return attribute == null ? null : attribute.getValue();
    }

    private static String getBestRelationshipValue(final Examinee examinee,
                                                   final String element) {
        ExamineeRelationship attribute = examinee.getBestRelationship(element);
        if (attribute != null) return attribute.getValue();

        if (FieldAliases.containsKey(element)) {
            attribute = examinee.getBestRelationship(FieldAliases.get(element));
        }
        return attribute == null ? null : attribute.getValue();
    }

    private static Set<String> getBestGroupNames(final Examinee examinee) {
        // get attributes with "StudentGroupName"
        // if any are FINAL then only get FINAL else only get INITIAL
        final Set<String> finalNames = newHashSet();
        final Set<String> initialNames = newHashSet();
        for (final Object obj : examinee.getExamineeAttributeOrExamineeRelationship()) {
            if (!(obj instanceof ExamineeAttribute)) continue;
            final ExamineeAttribute attribute = (ExamineeAttribute) obj;
            if (StudentGroupName.equals(attribute.getName())) {
                if (Context.FINAL.equals(attribute.getContext())) finalNames.add(attribute.getValue());
                else initialNames.add(attribute.getValue());
            }
        }
        return finalNames.isEmpty() ? initialNames : finalNames;
    }

    /**
     * The Section504Status attribute has a legacy value that indicates "unknown" which maps to null.
     * Otherwise it is a required boolean value.
     */
    static final Function<String, Boolean> toSection504Status = value -> {
        if ("Unknown/Cannot Provide".equalsIgnoreCase(value)) return null;
        return toBoolean.apply(value);
    };
}
