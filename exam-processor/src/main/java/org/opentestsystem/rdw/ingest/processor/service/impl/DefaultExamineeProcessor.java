package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.processor.model.District;
import org.opentestsystem.rdw.ingest.processor.model.School;
import org.opentestsystem.rdw.ingest.processor.model.School.Builder;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.repository.StudentRepository;
import org.opentestsystem.rdw.ingest.processor.service.DataElementError;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.model.Examinee;
import org.opentestsystem.rdw.model.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.model.Examinee.ExamineeRelationship;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.List;
import java.util.Map;

import static com.google.common.base.Joiner.on;
import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryBoolean;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryDate;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryString;

@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private final SchoolRepository schoolRepository;
    private final StudentRepository studentRepository;
    private final GenderRepository genderRepository;
    private final EthnicityService ethnicityService;
    private final GradeRepository gradeRepository;

    @Autowired
    DefaultExamineeProcessor(final SchoolRepository schoolRepository,
                             final StudentRepository studentRepository,
                             final GenderRepository genderRepository,
                             final GradeRepository gradeRepository,
                             final EthnicityService ethnicityService) {
        this.genderRepository = genderRepository;
        this.gradeRepository = gradeRepository;
        this.schoolRepository = schoolRepository;
        this.studentRepository = studentRepository;
        this.ethnicityService = ethnicityService;
    }

    @Override
    public StudentExamAttributes process(final Examinee examinee, final School school) throws ImportException {

        // parse and collect all parsing issues before proceeding with other actions
        final List<String> errMsg = newArrayList();
        Student student = null;
        try {
            student = parseStudent(examinee);
        } catch (final ImportException e) {
            errMsg.add(e.getMessage());
        }

        StudentExamAttributes.Builder studentExamAttrBuilder = null;
        try {
            studentExamAttrBuilder = parseStudentAttributes(examinee);
        } catch (final ImportException e) {
            errMsg.add(e.getMessage());
        }

        if (!errMsg.isEmpty()) throw new ImportException(ImportStatus.BAD_DATA, on(",").join(errMsg));

        final int schoolId = schoolRepository.upsert(school);
        final long studentId = studentRepository.upsert(student);

        return studentExamAttrBuilder
                .responsibleSchoolId(schoolId)
                .studentId(studentId)
                .build();
    }

    @Override
    public School parseExamineeRelationship(final Examinee examinee) throws ImportException {
        final List<String> elementErrors = newArrayList();
        final Builder schoolBuilder = School.builder()
                .district(District.builder()
                        .stateCode(parseMandatoryRelationship(examinee, "StateAbbreviation", elementErrors))
                        .naturalId(parseMandatoryRelationship(examinee, "DistrictId", elementErrors))
                        .name(parseMandatoryRelationship(examinee, "DistrictName", elementErrors))
                        .build())
                .naturalId(parseMandatoryRelationship(examinee, "SchoolId", elementErrors))
                .name(parseMandatoryRelationship(examinee, "SchoolName", elementErrors));

        if (elementErrors.isEmpty()) return schoolBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private Student parseStudent(final Examinee examinee) throws ImportException {
        final List<String> elementErrors = newArrayList();
        final Student.Builder studentBuilder = Student.builder()
                .firstName(parseMandatoryStringAttribute(examinee, "FirstName", elementErrors))
                .lastOrSurname(parseMandatoryStringAttribute(examinee, "LastOrSurname", elementErrors))
                .middleName(parseOptionalStringAttribute(examinee, "MiddleName", elementErrors))
                .ssid(parseMandatoryStringAttribute(examinee, "StudentIdentifier", elementErrors))
                .birthday(parseMandatoryDateAttribute(examinee, "Birthdate", elementErrors))
                .genderId(parseGenderId(examinee, elementErrors))
                .firsEntryIntoUSSchoolAt(parseOptionalDateAttribute(examinee, "FirstEntryDateIntoUSSchool", elementErrors))
                .lepEntryAt(parseOptionalDateAttribute(examinee, "LimitedEnglishProficiencyEntryDate", elementErrors))
                .lepExitAt(parseOptionalDateAttribute(examinee, "LEPExitDate", elementErrors))
                .ethnicityIds(ethnicityService.getExameneeRaceAndEthnicity(examinee, elementErrors));

        if (elementErrors.isEmpty()) return studentBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private StudentExamAttributes.Builder parseStudentAttributes(final Examinee examinee) throws ImportException {
        final List<String> elementErrors = newArrayList();
        final StudentExamAttributes.Builder studentAttributesBuilder = StudentExamAttributes.builder()

                .ideaIndicator(parseMandatoryBooleanAttribute(examinee, "IDEAIndicator", elementErrors))
                .lep(parseMandatoryBooleanAttribute(examinee, "LEPStatus", elementErrors))
                .section504(parseMandatoryBooleanAttribute(examinee, "Section504Status", elementErrors))
                .economicDisadvantage(parseMandatoryBooleanAttribute(examinee, "EconomicDisadvantageStatus", elementErrors))
                .migrantStatus(parseOptionalBooleanAttribute(examinee, "MigrantStatus", elementErrors))
                .languageCode(parseOptionalStringAttribute(examinee, "LanguageCode", elementErrors))
                .engProfLvl(parseOptionalStringAttribute(examinee, "EnglishLanguageProficiencyLevel", elementErrors))
                .t3ProgramType(parseOptionalStringAttribute(examinee, "TitleIIILanguageInstructionProgramType", elementErrors))
                .primDisabilityType(parseOptionalStringAttribute(examinee, "PrimaryDisabilityType", elementErrors))
                .gradeId(parseGradeId(examinee, elementErrors));

        if (elementErrors.isEmpty()) return studentAttributesBuilder;
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private Integer parseGenderId(final Examinee examinee, final List<String> elementErrors) {
        final String sexAttr = "Sex";
        final String sex = parseMandatoryStringAttribute(examinee, sexAttr, elementErrors);

        if (sex == null) return null;

        try {
            return genderRepository.findIdByName(sex);
        } catch (final IllegalArgumentException e) {
            elementErrors.add(new DataElementError(sexAttr, sex, e.getMessage()).toJson());
            return null;
        }
    }

    private Integer parseGradeId(final Examinee examinee, final List<String> elementErrors) {
        final String gradeAttr = "GradeLevelWhenAssessed";
        final String grade = parseMandatoryStringAttribute(examinee, gradeAttr, elementErrors);

        if (grade == null) return null;

        try {
            return gradeRepository.findIdByCode(grade);
        } catch (final IllegalArgumentException e) {
            elementErrors.add(new DataElementError(gradeAttr, grade, e.getMessage()).toJson());
            return null;
        }
    }

    /**
     * Map of aliases for TRT attribute field names. The key is the documented TRT attribute field name,
     * while the value is an alternate name, typically from the DWSA (the CSV import file) spec.
     * These will be used when looking for attribute values; for now for efficiency, just string attributes.
     * Although it is unlikely that multiple entries will exist with different names, if that happens the
     * TRT-named attribute value will be favored.
     */
    private static Map<String, String> FieldAliases = newHashMap();
    static {
        FieldAliases.put("StudentIdentifier", "SSID");
        FieldAliases.put("AlternateSSID", "ExternalSSID");
        FieldAliases.put("GradeLevelWhenAssessed", "Grade");
        FieldAliases.put("DistrictId", "ResponsibleDistrictIdentifier");
        FieldAliases.put("DistrictName", "OrganizationName");
        FieldAliases.put("SchoolId", "ResponsibleInstitutionIdentifier");
        FieldAliases.put("SchoolName", "NameOfInstitution");
    };

    private static String parseMandatoryStringAttribute(final Examinee examinee,
                                                        final String element,
                                                        final List<String> elementErrors) {
        ExamineeAttribute attribute = examinee.getBestAttribute(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        if (attribute != null) return parseMandatoryString(attribute.getValue(), element, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value").toJson());
        return null;
    }

    private static Boolean parseMandatoryBooleanAttribute(final Examinee examinee,
                                                          final String element,
                                                          final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute != null) return parseMandatoryBoolean(attribute.getValue(), element, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value").toJson());
        return null;
    }

    private static Date parseMandatoryDateAttribute(final Examinee examinee,
                                                    final String element,
                                                    final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute != null) return parseMandatoryDate(attribute.getValue(), element, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value").toJson());
        return null;
    }


    private static Boolean parseOptionalBooleanAttribute(final Examinee examinee,
                                                         final String element,
                                                         final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryBoolean(attribute.getValue(), element, elementErrors);
    }

    private static String parseOptionalStringAttribute(final Examinee examinee,
                                                       final String element,
                                                       final List<String> elementErrors) {
        ExamineeAttribute attribute = examinee.getBestAttribute(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryString(attribute.getValue(), element, elementErrors);
    }

    private static Date parseOptionalDateAttribute(final Examinee examinee,
                                                   final String element,
                                                   final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryDate(attribute.getValue(), element, elementErrors);
    }

    private static String parseMandatoryRelationship(final Examinee examinee,
                                                     final String element,
                                                     final List<String> elementErrors) {
        ExamineeRelationship attribute = examinee.getBestRelationship(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestRelationship(FieldAliases.get(element));
        }

        if (attribute != null) return parseMandatoryString(attribute.getValue(), element, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value").toJson());
        return null;
    }
}
