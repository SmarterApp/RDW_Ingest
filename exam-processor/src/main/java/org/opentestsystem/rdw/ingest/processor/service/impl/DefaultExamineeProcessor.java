package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.trt.Context;
import org.opentestsystem.rdw.common.model.trt.Examinee;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeRelationship;
import org.opentestsystem.rdw.ingest.common.model.District;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.model.School;
import org.opentestsystem.rdw.ingest.common.model.School.Builder;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.common.util.Precondition;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.StudentGroup;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;

@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private static final String StateAbbreviation = "StateAbbreviation";
    private static final String DistrictId = "DistrictId";
    private static final String DistrictName = "DistrictName";
    private static final String SchoolId = "SchoolId";
    private static final String SchoolName = "SchoolName";

    private static final String FirstName = "FirstName";
    private static final String LastOrSurname = "LastOrSurname";
    private static final String MiddleName = "MiddleName";
    private static final String StudentIdentifier = "StudentIdentifier";
    private static final String Birthdate = "Birthdate";
    private static final String Sex = "Sex";
    private static final String FirstEntryDateIntoUSSchool = "FirstEntryDateIntoUSSchool";
    private static final String LimitedEnglishProficiencyEntryDate = "LimitedEnglishProficiencyEntryDate";
    private static final String LEPExitDate = "LEPExitDate";

    private static final String IDEAIndicator = "IDEAIndicator";
    private static final String LEPStatus = "LEPStatus";
    private static final String Section504Status = "Section504Status";
    private static final String EconomicDisadvantageStatus = "EconomicDisadvantageStatus";
    private static final String MigrantStatus = "MigrantStatus";
    private static final String LanguageCode = "LanguageCode";
    private static final String EnglishLanguageProficiencyLevel = "EnglishLanguageProficiencyLevel";
    private static final String TitleIIILanguageInstructionProgramType = "TitleIIILanguageInstructionProgramType";
    private static final String PrimaryDisabilityType = "PrimaryDisabilityType";
    private static final String GradeLevelWhenAssessed = "GradeLevelWhenAssessed";

    private static final String StudentGroupName = "StudentGroupName";


    private final GenderRepository genderRepository;
    private final EthnicityService ethnicityService;
    private final GradeRepository gradeRepository;
    private final SubjectRepository subjectRepository;

    @Autowired
    DefaultExamineeProcessor(final GenderRepository genderRepository,
                             final GradeRepository gradeRepository,
                             final EthnicityService ethnicityService,
                             final SubjectRepository subjectRepository) {
        this.genderRepository = genderRepository;
        this.gradeRepository = gradeRepository;
        this.ethnicityService = ethnicityService;
        this.subjectRepository = subjectRepository;
    }

    @Override
    public School parseExamineeRelationship(final Examinee examinee) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final Builder schoolBuilder = School.builder()
                .district(District.builder()
                        .stateCode(parserHelper.parseMandatory(StateAbbreviation, getBestRelationshipValue(examinee, StateAbbreviation), Precondition::checkNotBlank))
                        .naturalId(parserHelper.parseMandatory(DistrictId, getBestRelationshipValue(examinee, DistrictId), Precondition::checkNotBlank))
                        .name(parserHelper.parseMandatory(DistrictName, getBestRelationshipValue(examinee, DistrictName), Precondition::checkNotBlank))
                        .build())
                .naturalId(parserHelper.parseMandatory(SchoolId, getBestRelationshipValue(examinee, SchoolId), Precondition::checkNotBlank))
                .name(parserHelper.parseMandatory(SchoolName, getBestRelationshipValue(examinee, SchoolName), Precondition::checkNotBlank));

        if (errorCollector.isEmpty()) return schoolBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }

    @Override
    public Student parseStudent(final Examinee examinee, final int schoolYear, final int schoolId) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final Student.Builder studentBuilder = Student.builder()
                .firstName(parserHelper.parseMandatory(FirstName, getBestAttributeValue(examinee, FirstName), Precondition::checkNotBlank))
                .lastOrSurname(parserHelper.parseMandatory(LastOrSurname, getBestAttributeValue(examinee, LastOrSurname), Precondition::checkNotBlank))
                .middleName(parserHelper.parseOptional(MiddleName, getBestAttributeValue(examinee, MiddleName), Precondition::checkNotBlank))
                .ssid(parserHelper.parseMandatory(StudentIdentifier, getBestAttributeValue(examinee, StudentIdentifier), Precondition::checkNotBlank))
                .birthday(parserHelper.parseMandatory(Birthdate, getBestAttributeValue(examinee, Birthdate), LocalDate::parse))
                .genderId(parserHelper.parseMandatoryAndValidate(Sex, getBestAttributeValue(examinee, Sex), Precondition::checkNotBlank, genderRepository::findIdByCode))
                .firsEntryIntoUSSchoolAt(parserHelper.parseOptional(FirstEntryDateIntoUSSchool, getBestAttributeValue(examinee, FirstEntryDateIntoUSSchool), LocalDate::parse))
                .lepEntryAt(parserHelper.parseOptional(LimitedEnglishProficiencyEntryDate, getBestAttributeValue(examinee, LimitedEnglishProficiencyEntryDate), LocalDate::parse))
                .lepExitAt(parserHelper.parseOptional(LEPExitDate, getBestAttributeValue(examinee, LEPExitDate), LocalDate::parse))
                .ethnicityIds(ethnicityService.getEthnicity(examinee, errorCollector))
                .groups(parseGroups(examinee, schoolYear, schoolId));

        if (errorCollector.isEmpty()) return studentBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }

    @Override
    public StudentExamAttributes parseStudentExamAttributes(final Examinee examinee, final int schoolId, final DataElementErrorCollector errorCollector) {
        final ParserHelper parserHelper = new ParserHelper(errorCollector);
        final StudentExamAttributes.Builder builder = StudentExamAttributes.builder()
                .ideaIndicator(parserHelper.parseMandatory(IDEAIndicator, getBestAttributeValue(examinee, IDEAIndicator), ParserHelper::toBoolean))
                .lep(parserHelper.parseMandatory(LEPStatus, getBestAttributeValue(examinee, LEPStatus), ParserHelper::toBoolean))
                .section504(parserHelper.parseMandatory(Section504Status, getBestAttributeValue(examinee, Section504Status), ParserHelper::toBoolean))
                .economicDisadvantage(parserHelper.parseMandatory(EconomicDisadvantageStatus, getBestAttributeValue(examinee, EconomicDisadvantageStatus), ParserHelper::toBoolean))
                .migrantStatus(parserHelper.parseOptional(MigrantStatus, getBestAttributeValue(examinee, MigrantStatus), ParserHelper::toBoolean))
                .languageCode(parserHelper.parseOptional(LanguageCode, getBestAttributeValue(examinee, LanguageCode), Precondition::checkNotBlank))
                .engProfLvl(parserHelper.parseOptional(EnglishLanguageProficiencyLevel, getBestAttributeValue(examinee, EnglishLanguageProficiencyLevel), Precondition::checkNotBlank))
                .t3ProgramType(parserHelper.parseOptional(TitleIIILanguageInstructionProgramType, getBestAttributeValue(examinee, TitleIIILanguageInstructionProgramType), Precondition::checkNotBlank))
                .primDisabilityType(parserHelper.parseOptional(PrimaryDisabilityType, getBestAttributeValue(examinee, PrimaryDisabilityType), Precondition::checkNotBlank))
                .gradeId(parserHelper.parseMandatoryAndValidate(GradeLevelWhenAssessed, getBestAttributeValue(examinee, GradeLevelWhenAssessed), Precondition::checkNotBlank, gradeRepository::findIdByCode))
                .responsibleSchoolId(schoolId);

        return errorCollector.isEmpty() ? builder.build() : null;
    }

    private List<StudentGroup> parseGroups(final Examinee examinee, final int schoolYear, final int schoolId) {
        // deal with student groups: create groups if they don't already exist then add student to them
        final List<StudentGroup> groups = newArrayList();
        final Set<String> groupNames = getBestGroupNames(examinee);
        if (!groupNames.isEmpty()) {
            for (final String groupName : groupNames) {
                groups.add(StudentGroup.builder()
                        .name(groupName)
                        .schoolId(schoolId)
                        .schoolYear(schoolYear)
                        .active(true)
                        .build());
            }
        }
        return groups;
    }

    /**
     * Map of aliases for TRT attribute field names. The key is the documented TRT attribute field name,
     * while the value is an alternate name, typically from the DWSA (the CSV import file) spec.
     * These will be used when looking for attribute values; for now for efficiency, just string attributes.
     * Although it is unlikely that multiple entries will exist with different names, if that happens the
     * TRT-named attribute value will be favored.
     */
    private static final Map<String, String> FieldAliases = newHashMap();

    static {
        FieldAliases.put(StudentIdentifier, "SSID");
        FieldAliases.put(GradeLevelWhenAssessed, "Grade");
        FieldAliases.put(DistrictId, "ResponsibleDistrictIdentifier");
        FieldAliases.put(DistrictName, "OrganizationName");
        FieldAliases.put(SchoolId, "ResponsibleInstitutionIdentifier");
        FieldAliases.put(SchoolName, "NameOfInstitution");
    }

    private static String getBestAttributeValue(final Examinee examinee,
                                                final String element) {
        ExamineeAttribute attribute = examinee.getBestAttribute(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        return attribute == null ? null : attribute.getValue();
    }

    private static String getBestRelationshipValue(final Examinee examinee,
                                                   final String element) {
        ExamineeRelationship attribute = examinee.getBestRelationship(element);
        if (attribute != null) return attribute.getValue();

        if (FieldAliases.containsKey(element)) {
            attribute = examinee.getBestRelationship(FieldAliases.get(element));
        }
        return attribute == null ? null : attribute.getValue();
    }

    private static Set<String> getBestGroupNames(final Examinee examinee) {
        // get attributes with "StudentGroupName"
        // if any are FINAL then only get FINAL else only get INITIAL
        final Set<String> finalNames = newHashSet();
        final Set<String> initialNames = newHashSet();
        for (final Object obj : examinee.getExamineeAttributeOrExamineeRelationship()) {
            if (!(obj instanceof ExamineeAttribute)) continue;
            final ExamineeAttribute attribute = (ExamineeAttribute) obj;
            if (StudentGroupName.equals(attribute.getName())) {
                if (Context.FINAL.equals(attribute.getContext())) finalNames.add(attribute.getValue());
                else initialNames.add(attribute.getValue());
            }
        }
        return finalNames.isEmpty() ? initialNames : finalNames;
    }
}
