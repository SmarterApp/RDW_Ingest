package org.opentestsystem.rdw.ingest.processor.service.impl;

import java.util.Date;
import java.util.List;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.processor.model.District;
import org.opentestsystem.rdw.ingest.processor.model.School;
import org.opentestsystem.rdw.ingest.processor.model.School.Builder;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.repository.StudentRepository;
import org.opentestsystem.rdw.ingest.processor.service.DataElementError;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.model.Examinee;
import org.opentestsystem.rdw.model.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.model.Examinee.ExamineeRelationship;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import static com.google.common.base.Joiner.on;
import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryBoolean;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryDate;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryString;

@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private final SchoolRepository schoolRepository;
    private final StudentRepository studentRepository;
    private final GenderRepository genderRepository;
    private final EthnicityService ethnicityService;
    private final GradeRepository gradeRepository;

    @Autowired
    DefaultExamineeProcessor(final SchoolRepository schoolRepository,
                             final StudentRepository studentRepository,
                             final GenderRepository genderRepository,
                             final GradeRepository gradeRepository,
                             final EthnicityService ethnicityService) {
        this.genderRepository = genderRepository;
        this.gradeRepository = gradeRepository;
        this.schoolRepository = schoolRepository;
        this.studentRepository = studentRepository;
        this.ethnicityService = ethnicityService;
    }

    @Override
    public StudentExamAttributes process(final Examinee examinee, final School school) throws ImportException {

        // parse and collect all parsing issues before proceeding with other actions
        final List<String> errMsg = newArrayList();
        Student student = null;
        try {
            student = parseStudent(examinee);
        } catch (final ImportException e) {
            errMsg.add(e.getMessage());
        }

        StudentExamAttributes.Builder studentExamAttrBuilder = null;
        try {
            studentExamAttrBuilder = parseStudentAttributes(examinee);
        } catch (final ImportException e) {
            errMsg.add(e.getMessage());
        }

        if (!errMsg.isEmpty()) throw new ImportException(ImportStatus.BAD_DATA, on(",").join(errMsg));

        final int schoolId = schoolRepository.upsert(school);
        final long studentId = studentRepository.upsert(student);

        return studentExamAttrBuilder
                .withResponsibleSchoolId(schoolId)
                .withStudentId(studentId)
                .build();
    }

    @Override
    public School parseExamineeRelationship(final Examinee examinee) throws ImportException {
        final List<String> elementErrors = newArrayList();
        final Builder schoolBuilder = School.builder()
                .withDistrict(District.builder()
                        .withStateCode(parseMandatoryRelationship(examinee, "StateAbbreviation", elementErrors))
                        .withNaturalId(parseMandatoryRelationship(examinee, "ResponsibleDistrictIdentifier", elementErrors))
                        .withName(parseMandatoryRelationship(examinee, "OrganizationName", elementErrors))
                        .build())
                .withNaturalId(parseMandatoryRelationship(examinee, "ResponsibleInstitutionIdentifier", elementErrors))
                .withName(parseMandatoryRelationship(examinee, "NameOfInstitution", elementErrors));

        if (elementErrors.isEmpty()) return schoolBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private Student parseStudent(final Examinee examinee) throws ImportException {
        final List<String> elementErrors = newArrayList();
        final Student.Builder studentBuilder = Student.builder()
                .withFirstName(parseMandatoryStringAttribute(examinee, "FirstName", elementErrors))
                .withLastOrSurname(parseMandatoryStringAttribute(examinee, "LastOrSurname", elementErrors))
                .withMiddleName(parseOptionalStringAttribute(examinee, "MiddleName", elementErrors))
                .withSsid(parseMandatoryStringAttribute(examinee, "StudentIdentifier", elementErrors))
                .withBirthday(parseMandatoryDateAttribute(examinee, "Birthdate", elementErrors))
                .withGenderId(parseGenderId(examinee, elementErrors))
                .withFirsEntryIntoUSSchoolAt(parseOptionalDateAttribute(examinee, "FirstEntryDateIntoUSSchool", elementErrors))
                .withLepEntryAt(parseOptionalDateAttribute(examinee, "LimitedEnglishProficiencyEntryDate", elementErrors))
                .withLepExitAt(parseOptionalDateAttribute(examinee, "LEPExitDate", elementErrors))
                .withEthnicityIds(ethnicityService.getExameneeRaceAndEthnicity(examinee, elementErrors));

        if (elementErrors.isEmpty()) return studentBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private StudentExamAttributes.Builder parseStudentAttributes(final Examinee examinee) throws ImportException {
        final List<String> elementErrors = newArrayList();
        final StudentExamAttributes.Builder studentAttributesBuilder = StudentExamAttributes.builder()

                .withIdeaIndicator(parseMandatoryBooleanAttribute(examinee, "IDEAIndicator", elementErrors))
                .withLep(parseMandatoryBooleanAttribute(examinee, "LEPStatus", elementErrors))
                .withSection504(parseMandatoryBooleanAttribute(examinee, "Section504Status", elementErrors))
                .withEconomicDisadvantage(parseMandatoryBooleanAttribute(examinee, "EconomicDisadvantageStatus", elementErrors))
                .withMigrantStatus(parseOptionalBooleanAttribute(examinee, "MigrantStatus", elementErrors))
                .withLanguageCode(parseOptionalStringAttribute(examinee, "LanguageCode", elementErrors))
                .withEngProfLvl(parseOptionalStringAttribute(examinee, "EnglishLanguageProficiencyLevel", elementErrors))
                .withT3ProgramType(parseOptionalStringAttribute(examinee, "TitleIIILanguageInstructionProgramType", elementErrors))
                .withPrimDisabilityType(parseOptionalStringAttribute(examinee, "PrimaryDisabilityType", elementErrors))
                .withGradeId(parseGradeId(examinee, elementErrors));

        if (elementErrors.isEmpty()) return studentAttributesBuilder;
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private Integer parseGenderId(final Examinee examinee, final List<String> elementErrors) {
        final String sexAttr = "Sex";
        final String sex = parseMandatoryStringAttribute(examinee, sexAttr, elementErrors);

        if (sex == null) return null;

        try {
            return genderRepository.findIdByName(sex);
        } catch (final IllegalArgumentException e) {
            elementErrors.add(new DataElementError(sexAttr, sex, e.getMessage()).toJson());
            return null;
        }
    }

    private Integer parseGradeId(final Examinee examinee, final List<String> elementErrors) {
        final String gradeAttr = "GradeLevelWhenAssessed";
        final String grade = parseMandatoryStringAttribute(examinee, gradeAttr, elementErrors);

        if (grade == null) return null;

        try {
            return gradeRepository.findIdByCode(grade);
        } catch (final IllegalArgumentException e) {
            elementErrors.add(new DataElementError(gradeAttr, grade, e.getMessage()).toJson());
            return null;
        }
    }

    private static String parseMandatoryStringAttribute(final Examinee examinee,
                                                        final String element,
                                                        final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute != null) return parseMandatoryString(attribute.getValue(), element, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value").toJson());
        return null;
    }

    private static Boolean parseMandatoryBooleanAttribute(final Examinee examinee,
                                                          final String element,
                                                          final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute != null) return parseMandatoryBoolean(attribute.getValue(), element, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value").toJson());
        return null;
    }

    private static Date parseMandatoryDateAttribute(final Examinee examinee,
                                                    final String element,
                                                    final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute != null) return parseMandatoryDate(attribute.getValue(), element, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value").toJson());
        return null;
    }


    private static Boolean parseOptionalBooleanAttribute(final Examinee examinee,
                                                         final String element,
                                                         final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryBoolean(attribute.getValue(), element, elementErrors);
    }

    private static String parseOptionalStringAttribute(final Examinee examinee,
                                                       final String element,
                                                       final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryString(attribute.getValue(), element, elementErrors);
    }

    private static Date parseOptionalDateAttribute(final Examinee examinee,
                                                   final String element,
                                                   final List<String> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryDate(attribute.getValue(), element, elementErrors);
    }

    private static String parseMandatoryRelationship(final Examinee examinee,
                                                     final String element,
                                                     final List<String> elementErrors) {
        final ExamineeRelationship attribute = examinee.getBestRelationship(element);

        if (attribute != null) return parseMandatoryString(attribute.getValue(), element, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value").toJson());
        return null;
    }
}
