package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.common.repository.LanguageRepository;
import org.opentestsystem.rdw.ingest.processor.config.DataElementsConfiguration;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.Context;
import org.opentestsystem.rdw.common.model.trt.Examinee;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeRelationship;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.StudentGroup;
import org.opentestsystem.rdw.ingest.processor.repository.ElasRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toBoolean;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLocalDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.AliasName;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Birthdate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.EconomicDisadvantageStatus;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.EnglishLanguageAcquisitionStatus;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.EnglishLanguageAcquisitionStatusStartDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.EnglishLanguageProficiencyLevel;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Ethnicity;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.FirstEntryDateIntoUSSchool;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.FirstName;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.IDEAIndicator;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LEPExitDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LEPStatus;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LanguageCode;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LastOrSurname;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LimitedEnglishProficiencyEntryDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.MiddleName;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.MigrantStatus;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.PrimaryDisabilityType;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Section504Status;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Sex;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.TitleIIILanguageInstructionProgramType;

@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private final GenderRepository genderRepository;
    private final EthnicityService ethnicityService;
    private final GradeRepository gradeRepository;
    private final SchoolRepository schoolRepository;
    private final ElasRepository elasRepository;
    private final LanguageRepository languageRepository;
    private final Set<ConfigurableDataElement> optionalDataElements;

    @Autowired
    DefaultExamineeProcessor(final GenderRepository genderRepository,
                             final GradeRepository gradeRepository,
                             final EthnicityService ethnicityService,
                             final SchoolRepository schoolRepository,
                             final ElasRepository elasRepository,
                             final LanguageRepository languageRepository,
                             final DataElementsConfiguration requiredDataElementsConfiguration) {
        this.genderRepository = genderRepository;
        this.gradeRepository = gradeRepository;
        this.ethnicityService = ethnicityService;
        this.schoolRepository = schoolRepository;
        this.elasRepository = elasRepository;
        this.languageRepository = languageRepository;
        this.optionalDataElements = requiredDataElementsConfiguration.getOptionalDataElements();
    }

    @Override
    public int parseSchoolId(final Examinee examinee) throws ImportException {
        final String naturalId = getBestRelationshipValue(examinee, "SchoolId");
        final Integer schoolId = schoolRepository.findIdByNaturalId(naturalId);
        if (schoolId != null) return schoolId;
        // put as much info as possible into the import message
        final String schoolName = getBestRelationshipValue(examinee, "SchoolName");
        final String districtId = getBestRelationshipValue(examinee, "DistrictId");
        final String districtName = getBestRelationshipValue(examinee, "DistrictName");
        throw new ImportException(ImportStatus.UNKNOWN_SCHOOL,
                "unable to find a school with natural id [" + naturalId + "]." +
                        " School name: " + schoolName + ", district id: [" + districtId + "], district name: " + districtName);
    }

    @Override
    public Student parseStudent(final Examinee examinee, final int schoolYear, final int schoolId) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ExamParserHelper parserHelper = new ExamParserHelper(errorCollector, optionalDataElements);
        if (examinee.getIsDemo()) {
            errorCollector.add(new DataElementError("isDemo", "true", "demo students are not supported"));
        }

        final Student.Builder studentBuilder = Student.builder()
                .firstName(parserHelper.validate(FirstName, getBestAttributeValue(examinee, FirstName), 60))
                .lastOrSurname(parserHelper.validate(LastOrSurname, getBestAttributeValue(examinee, LastOrSurname), 60))
                .middleName(parserHelper.validate(MiddleName, getBestAttributeValue(examinee, MiddleName), 60))
                .aliasName(parserHelper.validate(AliasName, getBestAttributeValue(examinee, AliasName), 60))
                .ssid(parserHelper.validate("StudentIdentifier", getBestAttributeValue(examinee, "StudentIdentifier"), 65, true))
                .birthday(parserHelper.validate(Birthdate, getBestAttributeValue(examinee, Birthdate), toLocalDate))
                .genderId(parserHelper.validate(Sex, getBestAttributeValue(examinee, Sex), checkNotBlank.andThen(genderRepository::findIdByCode)))
                .firsEntryIntoUSSchoolAt(parserHelper.validate(FirstEntryDateIntoUSSchool, getBestAttributeValue(examinee, FirstEntryDateIntoUSSchool), toLocalDate))
                .lepEntryAt(parserHelper.validate(LimitedEnglishProficiencyEntryDate, getBestAttributeValue(examinee, LimitedEnglishProficiencyEntryDate), toLocalDate))
                .lepExitAt(parserHelper.validate(LEPExitDate, getBestAttributeValue(examinee, LEPExitDate), toLocalDate))
                // each individual ethnicity value is validated by the ethnicity service,
                // but a validation of at least one ethnicity being required is done here
                .ethnicityIds(parserHelper.isNotEmpty(Ethnicity, ethnicityService.getEthnicity(examinee, errorCollector)))
                .groups(parseGroups(examinee, schoolYear, schoolId, parserHelper));

        if (errorCollector.isEmpty()) return studentBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }

    @Override
    public StudentExamAttributes parseStudentExamAttributes(final Examinee examinee, final int schoolId, final DataElementErrorCollector errorCollector) {
        final ExamParserHelper parserHelper = new ExamParserHelper(errorCollector, optionalDataElements);
        final StudentExamAttributes.Builder builder = StudentExamAttributes.builder()
                .ideaIndicator(parserHelper.validate(IDEAIndicator, getBestAttributeValue(examinee, IDEAIndicator), toBoolean))
                .section504(parserHelper.validate(Section504Status, getBestAttributeValue(examinee, Section504Status), toSection504Status))
                .economicDisadvantage(parserHelper.validate(EconomicDisadvantageStatus, getBestAttributeValue(examinee, EconomicDisadvantageStatus), toBoolean))
                .migrantStatus(parserHelper.validate(MigrantStatus, getBestAttributeValue(examinee, MigrantStatus), toBoolean))
                .languageId(parserHelper.validate(LanguageCode, getBestAttributeValue(examinee, LanguageCode), checkNotBlank.andThen(languageRepository::findIdByCode)))
                .lep(parserHelper.validate(LEPStatus, getBestAttributeValue(examinee, LEPStatus), toBoolean))
                .engProfLvl(parserHelper.validate(EnglishLanguageProficiencyLevel, getBestAttributeValue(examinee, EnglishLanguageProficiencyLevel), 20))
                .t3ProgramType(parserHelper.validate(TitleIIILanguageInstructionProgramType, getBestAttributeValue(examinee, TitleIIILanguageInstructionProgramType), 30))
                .primDisabilityType(parserHelper.validate(PrimaryDisabilityType, getBestAttributeValue(examinee, PrimaryDisabilityType), 3))
                .gradeId(parserHelper.validate("GradeLevelWhenAssessed", getBestAttributeValue(examinee, "GradeLevelWhenAssessed"), checkNotBlank.andThen(gradeRepository::findIdByCode)))
                .responsibleSchoolId(schoolId)
                .examineeId(examinee.getKey())
                .elasId(parserHelper.validate(EnglishLanguageAcquisitionStatus, getBestAttributeValue(examinee, EnglishLanguageAcquisitionStatus), checkNotBlank.andThen(elasRepository::findIdByCode)))
                .elasStartDate(parserHelper.validate(EnglishLanguageAcquisitionStatusStartDate, getBestAttributeValue(examinee, EnglishLanguageAcquisitionStatusStartDate), toLocalDate));

        return errorCollector.isEmpty() ? builder.build() : null;
    }

    private List<StudentGroup> parseGroups(final Examinee examinee, final int schoolYear, final int schoolId, final ExamParserHelper parserHelper) {
        // deal with student groups: create groups if they don't already exist then add student to them
        final List<StudentGroup> groups = newArrayList();
        final Set<String> groupNames = getBestGroupNames(examinee);
        if (!groupNames.isEmpty()) {
            for (final String groupName : groupNames) {
                groups.add(StudentGroup.builder()
                        .name(parserHelper.validate("StudentGroupName", groupName, 255, true))
                        .schoolId(schoolId)
                        .schoolYear(schoolYear)
                        .active(true)
                        .build());
            }
        }
        return groups;
    }

    /**
     * Map of aliases for TRT attribute field names. The key is the documented TRT attribute field name,
     * while the value is an alternate name, typically from the DWSA (the CSV import file) spec.
     * These will be used when looking for attribute values; for now for efficiency, just string attributes.
     * Although it is unlikely that multiple entries will exist with different names, if that happens the
     * TRT-named attribute value will be favored.
     */
    private static final Map<String, String> FieldAliases = newHashMap();

    static {
        FieldAliases.put("StudentIdentifier", "SSID");
        FieldAliases.put("GradeLevelWhenAssessed", "Grade");
        FieldAliases.put("SchoolId", "ResponsibleInstitutionIdentifier");
        FieldAliases.put(LimitedEnglishProficiencyEntryDate.name(), "EnglishLearnerIdentificationDate");
        FieldAliases.put(LEPExitDate.name(), "ReclassifiedFluentEnglishProficientDate");
    }

    private static String getBestAttributeValue(final Examinee examinee,
                                                final String element) {
        ExamineeAttribute attribute = examinee.getBestAttribute(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        return attribute == null ? null : attribute.getValue();
    }

    private static String getBestAttributeValue(final Examinee examinee,
                                                final ConfigurableDataElement element) {
        return getBestAttributeValue(examinee, element.name());
    }

    private static String getBestRelationshipValue(final Examinee examinee,
                                                   final String element) {
        ExamineeRelationship attribute = examinee.getBestRelationship(element);
        if (attribute != null) return attribute.getValue();

        if (FieldAliases.containsKey(element)) {
            attribute = examinee.getBestRelationship(FieldAliases.get(element));
        }
        return attribute == null ? null : attribute.getValue();
    }

    private static Set<String> getBestGroupNames(final Examinee examinee) {
        // get attributes with "StudentGroupName"
        // if any are FINAL then only get FINAL else only get INITIAL
        final Set<String> finalNames = newHashSet();
        final Set<String> initialNames = newHashSet();
        for (final Object obj : examinee.getExamineeAttributeOrExamineeRelationship()) {
            if (!(obj instanceof ExamineeAttribute)) continue;
            final ExamineeAttribute attribute = (ExamineeAttribute) obj;
            if ("StudentGroupName".equals(attribute.getName())) {
                if (Context.FINAL.equals(attribute.getContext())) finalNames.add(attribute.getValue());
                else initialNames.add(attribute.getValue());
            }
        }
        return finalNames.isEmpty() ? initialNames : finalNames;
    }

    /**
     * The Section504Status attribute has a legacy value that indicates "unknown" which maps to null.
     * Otherwise it is a required boolean value.
     */
    static final Function<String, Boolean> toSection504Status = value -> {
        if ("Unknown/Cannot Provide".equalsIgnoreCase(value)) return null;
        return toBoolean.apply(value);
    };
}
