package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.common.model.District;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.model.School;
import org.opentestsystem.rdw.ingest.common.model.School.Builder;
import org.opentestsystem.rdw.ingest.common.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.StudentGroup;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.StudentGroupRepository;
import org.opentestsystem.rdw.ingest.processor.repository.StudentRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SubjectRepository;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.common.model.trt.Context;
import org.opentestsystem.rdw.common.model.trt.Examinee;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeRelationship;
import org.opentestsystem.rdw.common.model.trt.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryBoolean;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryDate;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryString;

@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private final SchoolRepository schoolRepository;
    private final StudentRepository studentRepository;
    private final GenderRepository genderRepository;
    private final EthnicityService ethnicityService;
    private final GradeRepository gradeRepository;
    private final SubjectRepository subjectRepository;
    private final StudentGroupRepository studentGroupRepository;

    @Autowired
    DefaultExamineeProcessor(final SchoolRepository schoolRepository,
                             final StudentRepository studentRepository,
                             final GenderRepository genderRepository,
                             final GradeRepository gradeRepository,
                             final EthnicityService ethnicityService,
                             final SubjectRepository subjectRepository,
                             final StudentGroupRepository studentGroupRepository) {
        this.genderRepository = genderRepository;
        this.gradeRepository = gradeRepository;
        this.schoolRepository = schoolRepository;
        this.studentRepository = studentRepository;
        this.ethnicityService = ethnicityService;
        this.subjectRepository = subjectRepository;
        this.studentGroupRepository = studentGroupRepository;
    }

    @Override
    public StudentExamAttributes process(final Examinee examinee, final Test test, final School school, final long importId) throws ImportException {
        // parse and collect all parsing issues before proceeding with other actions
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final Student student = parseStudent(examinee, errorCollector);
        final StudentExamAttributes.Builder studentExamAttrBuilder = parseStudentAttributes(examinee, errorCollector);
        if (!errorCollector.isEmpty()) throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());

        final int schoolId = schoolRepository.upsert(school, importId);
        final long studentId = studentRepository.upsert(student, importId);

        // deal with student groups: create groups if they don't already exist then add student to them
        final Set<String> groupNames = getBestGroupNames(examinee);
        if (!groupNames.isEmpty()) {
            final int schoolYear = (int) test.getAcademicYear();
            final int subjectId = subjectRepository.findIdByCode(test.getSubject());
            final List<Integer> groupIds = newArrayList();
            for (final String groupName : groupNames) {
                Integer groupId = studentGroupRepository.findIdByNameAndSchoolAndYear(groupName, schoolId, schoolYear);
                if (groupId == null) {
                    groupId = studentGroupRepository.create(StudentGroup.builder()
                            .name(groupName)
                            .schoolId(schoolId)
                            .schoolYear(schoolYear)
                            .subjectId(subjectId)
                            .active(true)
                            .build(), importId).getId();
                }
                groupIds.add(groupId);
            }
            studentGroupRepository.addStudentToGroups(studentId, groupIds, importId);
        }

        return studentExamAttrBuilder
                .responsibleSchoolId(schoolId)
                .studentId(studentId)
                .build();
    }

    @Override
    public School parseExamineeRelationship(final Examinee examinee) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final Builder schoolBuilder = School.builder()
                .district(District.builder()
                        .stateCode(parseMandatoryRelationship(examinee, "StateAbbreviation", errorCollector))
                        .naturalId(parseMandatoryRelationship(examinee, "DistrictId", errorCollector))
                        .name(parseMandatoryRelationship(examinee, "DistrictName", errorCollector))
                        .build())
                .naturalId(parseMandatoryRelationship(examinee, "SchoolId", errorCollector))
                .name(parseMandatoryRelationship(examinee, "SchoolName", errorCollector));

        if (errorCollector.isEmpty()) return schoolBuilder.build();

        throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }

    private Student parseStudent(final Examinee examinee,
                                 final DataElementErrorCollector errorCollector) throws ImportException {
        final Student.Builder studentBuilder = Student.builder()
                .firstName(parseMandatoryStringAttribute(examinee, "FirstName", errorCollector))
                .lastOrSurname(parseMandatoryStringAttribute(examinee, "LastOrSurname", errorCollector))
                .middleName(parseOptionalStringAttribute(examinee, "MiddleName", errorCollector))
                .ssid(parseMandatoryStringAttribute(examinee, "StudentIdentifier", errorCollector))
                .birthday(parseMandatoryDateAttribute(examinee, "Birthdate", errorCollector))
                .genderId(parseGenderId(examinee, errorCollector))
                .firsEntryIntoUSSchoolAt(parseOptionalDateAttribute(examinee, "FirstEntryDateIntoUSSchool", errorCollector))
                .lepEntryAt(parseOptionalDateAttribute(examinee, "LimitedEnglishProficiencyEntryDate", errorCollector))
                .lepExitAt(parseOptionalDateAttribute(examinee, "LEPExitDate", errorCollector))
                .ethnicityIds(ethnicityService.getExameneeRaceAndEthnicity(examinee, errorCollector));

        return errorCollector.isEmpty() ? studentBuilder.build() : null;
    }

    private StudentExamAttributes.Builder parseStudentAttributes(final Examinee examinee,
                                                                 final DataElementErrorCollector errorCollector) throws ImportException {
        final StudentExamAttributes.Builder studentAttributesBuilder = StudentExamAttributes.builder()
                .ideaIndicator(parseMandatoryBooleanAttribute(examinee, "IDEAIndicator", errorCollector))
                .lep(parseMandatoryBooleanAttribute(examinee, "LEPStatus", errorCollector))
                .section504(parseMandatoryBooleanAttribute(examinee, "Section504Status", errorCollector))
                .economicDisadvantage(parseMandatoryBooleanAttribute(examinee, "EconomicDisadvantageStatus", errorCollector))
                .migrantStatus(parseOptionalBooleanAttribute(examinee, "MigrantStatus", errorCollector))
                .languageCode(parseOptionalStringAttribute(examinee, "LanguageCode", errorCollector))
                .engProfLvl(parseOptionalStringAttribute(examinee, "EnglishLanguageProficiencyLevel", errorCollector))
                .t3ProgramType(parseOptionalStringAttribute(examinee, "TitleIIILanguageInstructionProgramType", errorCollector))
                .primDisabilityType(parseOptionalStringAttribute(examinee, "PrimaryDisabilityType", errorCollector))
                .gradeId(parseGradeId(examinee, errorCollector));

        return errorCollector.isEmpty() ? studentAttributesBuilder : null;
    }

    private Integer parseGenderId(final Examinee examinee, final DataElementErrorCollector errorCollector) {
        final String sexAttr = "Sex";
        final String sex = parseMandatoryStringAttribute(examinee, sexAttr, errorCollector);

        if (sex == null) return null;

        try {
            return genderRepository.findIdByCode(sex);
        } catch (final IllegalArgumentException e) {
            errorCollector.add(new DataElementError(sexAttr, sex, e.getMessage()));
            return null;
        }
    }

    private Integer parseGradeId(final Examinee examinee, final DataElementErrorCollector errorCollector) {
        final String gradeAttr = "GradeLevelWhenAssessed";
        final String grade = parseMandatoryStringAttribute(examinee, gradeAttr, errorCollector);

        if (grade == null) return null;

        try {
            return gradeRepository.findIdByCode(grade);
        } catch (final IllegalArgumentException e) {
            errorCollector.add(new DataElementError(gradeAttr, grade, e.getMessage()));
            return null;
        }
    }

    /**
     * Map of aliases for TRT attribute field names. The key is the documented TRT attribute field name,
     * while the value is an alternate name, typically from the DWSA (the CSV import file) spec.
     * These will be used when looking for attribute values; for now for efficiency, just string attributes.
     * Although it is unlikely that multiple entries will exist with different names, if that happens the
     * TRT-named attribute value will be favored.
     */
    private static final Map<String, String> FieldAliases = newHashMap();

    static {
        FieldAliases.put("StudentIdentifier", "SSID");
        FieldAliases.put("AlternateSSID", "ExternalSSID");
        FieldAliases.put("GradeLevelWhenAssessed", "Grade");
        FieldAliases.put("DistrictId", "ResponsibleDistrictIdentifier");
        FieldAliases.put("DistrictName", "OrganizationName");
        FieldAliases.put("SchoolId", "ResponsibleInstitutionIdentifier");
        FieldAliases.put("SchoolName", "NameOfInstitution");
    }

    private static String parseMandatoryStringAttribute(final Examinee examinee,
                                                        final String element,
                                                        final DataElementErrorCollector errorCollector) {
        ExamineeAttribute attribute = examinee.getBestAttribute(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        if (attribute != null) return parseMandatoryString(attribute.getValue(), element, errorCollector);

        errorCollector.add(new DataElementError(element, null, "missing value"));
        return null;
    }

    private static Boolean parseMandatoryBooleanAttribute(final Examinee examinee,
                                                          final String element,
                                                          final DataElementErrorCollector errorCollector) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute != null) return parseMandatoryBoolean(attribute.getValue(), element, errorCollector);

        errorCollector.add(new DataElementError(element, null, "missing value"));
        return null;
    }

    private static LocalDate parseMandatoryDateAttribute(final Examinee examinee,
                                                         final String element,
                                                         final DataElementErrorCollector errorCollector) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute != null) return parseMandatoryDate(attribute.getValue(), element, errorCollector);

        errorCollector.add(new DataElementError(element, null, "missing value"));
        return null;
    }


    private static Boolean parseOptionalBooleanAttribute(final Examinee examinee,
                                                         final String element,
                                                         final DataElementErrorCollector errorCollector) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryBoolean(attribute.getValue(), element, errorCollector);
    }

    private static String parseOptionalStringAttribute(final Examinee examinee,
                                                       final String element,
                                                       final DataElementErrorCollector errorCollector) {
        ExamineeAttribute attribute = examinee.getBestAttribute(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryString(attribute.getValue(), element, errorCollector);
    }

    private static LocalDate parseOptionalDateAttribute(final Examinee examinee,
                                                        final String element,
                                                        final DataElementErrorCollector errorCollector) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryDate(attribute.getValue(), element, errorCollector);
    }

    private static String parseMandatoryRelationship(final Examinee examinee,
                                                     final String element,
                                                     final DataElementErrorCollector errorCollector) {
        ExamineeRelationship attribute = examinee.getBestRelationship(element);
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestRelationship(FieldAliases.get(element));
        }

        if (attribute != null) return parseMandatoryString(attribute.getValue(), element, errorCollector);

        errorCollector.add(new DataElementError(element, null, "missing value"));
        return null;
    }

    private static Set<String> getBestGroupNames(final Examinee examinee) {
        // get attributes with "StudentGroupName"
        // if any are FINAL then only get FINAL else only get INITIAL
        final Set<String> finalNames = newHashSet();
        final Set<String> initialNames = newHashSet();
        for (final Object obj : examinee.getExamineeAttributeOrExamineeRelationship()) {
            if (!(obj instanceof ExamineeAttribute)) continue;
            final ExamineeAttribute attribute = (ExamineeAttribute) obj;
            if ("StudentGroupName".equals(attribute.getName())) {
                if (Context.FINAL.equals(attribute.getContext())) finalNames.add(attribute.getValue());
                else initialNames.add(attribute.getValue());
            }
        }
        return finalNames.isEmpty() ? initialNames : finalNames;
    }
}
