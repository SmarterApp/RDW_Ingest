package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.Year;
import java.util.List;
import java.util.Set;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.Examinee;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.common.repository.LanguageRepository;
import org.opentestsystem.rdw.utils.DataElementError;
import org.opentestsystem.rdw.utils.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.config.DataElementsConfiguration;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.StudentGroup;
import org.opentestsystem.rdw.ingest.processor.repository.ElasRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.MilitaryConnectedRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;

import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
import static org.opentestsystem.rdw.utils.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.utils.ParserHelper.toBoolean;
import static org.opentestsystem.rdw.utils.ParserHelper.toLocalDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.AliasName;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Birthdate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.EconomicDisadvantageStatus;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.EnglishLanguageAcquisitionStatus;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.EnglishLanguageAcquisitionStatusStartDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.EnglishLanguageProficiencyLevel;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Ethnicity;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.FirstEntryDateIntoUSSchool;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.FirstName;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.IDEAIndicator;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LEPExitDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LEPStatus;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LanguageCode;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LastOrSurname;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.LimitedEnglishProficiencyEntryDate;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.MiddleName;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.MigrantStatus;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.MilitaryConnectedStudentIndicator;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.PrimaryDisabilityType;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Section504Status;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Sex;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.TitleIIILanguageInstructionProgramType;
import static org.opentestsystem.rdw.ingest.processor.service.util.TrtUtils.getBestAttributeValue;
import static org.opentestsystem.rdw.ingest.processor.service.util.TrtUtils.getBestGroupNames;
import static org.opentestsystem.rdw.ingest.processor.service.util.TrtUtils.getBestRelationshipValue;
import static org.opentestsystem.rdw.ingest.processor.service.util.TrtUtils.toSection504Status;

@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private final GenderRepository genderRepository;
    private final EthnicityService ethnicityService;
    private final GradeRepository gradeRepository;
    private final SchoolRepository schoolRepository;
    private final ElasRepository elasRepository;
    private final LanguageRepository languageRepository;
    private final MilitaryConnectedRepository militaryConnectedRepository;
    private final DataElementsConfiguration optionalDataElements;

    @Autowired
    DefaultExamineeProcessor(final GenderRepository genderRepository,
                             final GradeRepository gradeRepository,
                             final EthnicityService ethnicityService,
                             final SchoolRepository schoolRepository,
                             final ElasRepository elasRepository,
                             final LanguageRepository languageRepository,
                             final MilitaryConnectedRepository militaryConnectedRepository,
                             final DataElementsConfiguration dataElementsConfiguration) {
        this.genderRepository = genderRepository;
        this.gradeRepository = gradeRepository;
        this.ethnicityService = ethnicityService;
        this.schoolRepository = schoolRepository;
        this.elasRepository = elasRepository;
        this.languageRepository = languageRepository;
        this.militaryConnectedRepository = militaryConnectedRepository;
        this.optionalDataElements = dataElementsConfiguration;
    }

    @Override
    public int parseSchoolId(final Examinee examinee) throws ImportException {
        final String naturalId = getBestRelationshipValue(examinee, "SchoolId");
        final Integer id = schoolRepository.findIdByNaturalId(naturalId);
        if (id == null) {
            // provide additional data about the missing school for forensics
            throw new ImportException(ImportStatus.UNKNOWN_SCHOOL,
                    "unable to find a school with natural id [" + naturalId + "]"
                    + ", name [" + getBestRelationshipValue(examinee, "SchoolName") + "]"
                    + ", district id [" + getBestRelationshipValue(examinee, "DistrictId") + "]"
                    + ", district name [" + getBestRelationshipValue(examinee, "DistrictName") + "]"
            );
        }
        return id;
    }

    @Override
    public Student parseStudent(final Examinee examinee, final Exam exam, final int schoolId, DataElementErrorCollector examErrorCollector) throws ImportException {
        final ExamParserHelper parserHelper = new ExamParserHelper(examErrorCollector, optionalDataElements.getOptionalDataElements());
        final DataElementErrorCollector studentExamErrorCollector = parserHelper.getElementErrorCollector();
        if (examinee.getIsDemo()) {
            studentExamErrorCollector.add(new DataElementError("isDemo", "true", "demo students are not supported"));
        }

        final Student.Builder studentBuilder = Student.builder()
                .firstName(parserHelper.validate(FirstName, getBestAttributeValue(examinee, FirstName), 60))
                .lastOrSurname(parserHelper.validate(LastOrSurname, getBestAttributeValue(examinee, LastOrSurname), 60))
                .middleName(parserHelper.validate(MiddleName, getBestAttributeValue(examinee, MiddleName), 60))
                .aliasName(parserHelper.validate(AliasName, getBestAttributeValue(examinee, AliasName), 60))
                .ssid(parserHelper.validate("StudentIdentifier", getBestAttributeValue(examinee, "StudentIdentifier"), 65, true))
                .birthday(parserHelper.validate(Birthdate, getBestAttributeValue(examinee, Birthdate), toLocalDate))
                .genderId(parserHelper.validate(Sex, getBestAttributeValue(examinee, Sex), checkNotBlank.andThen(genderRepository::findIdByCode)))
                .firsEntryIntoUSSchoolAt(parserHelper.validate(FirstEntryDateIntoUSSchool, getBestAttributeValue(examinee, FirstEntryDateIntoUSSchool), toLocalDate))
                .lepEntryAt(parserHelper.validate(LimitedEnglishProficiencyEntryDate, getBestAttributeValue(examinee, LimitedEnglishProficiencyEntryDate), toLocalDate))
                .lepExitAt(parserHelper.validate(LEPExitDate, getBestAttributeValue(examinee, LEPExitDate), toLocalDate))
                // each individual ethnicity value is validated by the ethnicity service,
                // but a validation of at least one ethnicity being required is done here
                .ethnicityIds(parserHelper.isNotEmpty(Ethnicity, ethnicityService.getEthnicity(examinee, studentExamErrorCollector)))
                .groups(parseGroups(examinee, exam, schoolId, parserHelper));

        if (studentExamErrorCollector.isEmpty()) return studentBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, studentExamErrorCollector.toJson());
    }

    @Override
    public StudentExamAttributes parseStudentExamAttributes(final Examinee examinee, final int schoolId, final DataElementErrorCollector errorCollector) {
        final ExamParserHelper parserHelper = new ExamParserHelper(errorCollector, optionalDataElements.getOptionalDataElements());
        final StudentExamAttributes.Builder builder = StudentExamAttributes.builder()
                .ideaIndicator(parserHelper.validate(IDEAIndicator, getBestAttributeValue(examinee, IDEAIndicator), toBoolean))
                .section504(parserHelper.validate(Section504Status, getBestAttributeValue(examinee, Section504Status), toSection504Status))
                .economicDisadvantage(parserHelper.validate(EconomicDisadvantageStatus, getBestAttributeValue(examinee, EconomicDisadvantageStatus), toBoolean))
                .migrantStatus(parserHelper.validate(MigrantStatus, getBestAttributeValue(examinee, MigrantStatus), toBoolean))
                .languageId(parserHelper.validate(LanguageCode, getBestAttributeValue(examinee, LanguageCode), checkNotBlank.andThen(languageRepository::findIdByCode)))
                .militaryConnectedId(parserHelper.validate(MilitaryConnectedStudentIndicator, getBestAttributeValue(examinee, MilitaryConnectedStudentIndicator), checkNotBlank.andThen(militaryConnectedRepository::findIdByCode)))
                .lep(parserHelper.validate(LEPStatus, getBestAttributeValue(examinee, LEPStatus), toBoolean))
                .engProfLvl(parserHelper.validate(EnglishLanguageProficiencyLevel, getBestAttributeValue(examinee, EnglishLanguageProficiencyLevel), 20))
                .t3ProgramType(parserHelper.validate(TitleIIILanguageInstructionProgramType, getBestAttributeValue(examinee, TitleIIILanguageInstructionProgramType), 30))
                .primDisabilityType(parserHelper.validate(PrimaryDisabilityType, getBestAttributeValue(examinee, PrimaryDisabilityType), 3))
                .gradeId(parserHelper.validate("GradeLevelWhenAssessed", getBestAttributeValue(examinee, "GradeLevelWhenAssessed"), checkNotBlank.andThen(gradeRepository::findIdByCode)))
                .responsibleSchoolId(schoolId)
                .examineeId(examinee.getKey())
                .elasId(parserHelper.validate(EnglishLanguageAcquisitionStatus, getBestAttributeValue(examinee, EnglishLanguageAcquisitionStatus), checkNotBlank.andThen(elasRepository::findIdByCode)))
                .elasStartDate(parserHelper.validate(EnglishLanguageAcquisitionStatusStartDate, getBestAttributeValue(examinee, EnglishLanguageAcquisitionStatusStartDate), toLocalDate));

        return errorCollector.isEmpty() ? builder.build() : null;
    }

    private List<StudentGroup> parseGroups(final Examinee examinee, final Exam exam, final int schoolId, final ExamParserHelper parserHelper) {
        // deal with student groups: create groups if they don't already exist then add student to them
        final List<StudentGroup> groups = newArrayList();
        final Set<String> groupNames = getBestGroupNames(examinee);
        // if the exam object is not null meaning that the validation for exam
        // passed.if the exam is null that means there are exam validation
        // failures, to be able to continue with the validation for StudentGroupName
        // set a dummy year, an exception will be thrown on the parent method
        final int schoolYear = exam != null ? exam.getSchoolYear() : Year.now().getValue();
        if (!groupNames.isEmpty()) {
            for (final String groupName : groupNames) {
                groups.add(StudentGroup.builder()
                        .name(parserHelper.validate("StudentGroupName", groupName, 255, true))
                        .schoolId(schoolId)
                        .schoolYear(schoolYear)
                        .active(true)
                        .build());
            }
        }
        return groups;
    }
}
