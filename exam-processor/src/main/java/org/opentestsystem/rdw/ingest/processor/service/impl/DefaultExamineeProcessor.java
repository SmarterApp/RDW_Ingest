package org.opentestsystem.rdw.ingest.processor.service.impl;

import java.util.Date;
import java.util.List;
import org.opentestsystem.rdw.ingest.model.ImportException;
import org.opentestsystem.rdw.ingest.model.ImportStatus;
import org.opentestsystem.rdw.ingest.processor.model.District;
import org.opentestsystem.rdw.ingest.processor.model.School;
import org.opentestsystem.rdw.ingest.processor.model.School.Builder;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.repository.EthnicityRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.repository.StudentRepository;
import org.opentestsystem.rdw.ingest.processor.service.DataElementError;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.model.Examinee;
import org.opentestsystem.rdw.model.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.model.Examinee.ExamineeRelationship;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import static com.google.common.base.Joiner.on;
import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.ingest.processor.utils.ParseUtil.parseMandatoryValue;

@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private final SchoolRepository schoolRepository;
    private final StudentRepository studentRepository;
    private final GenderRepository genderRepository;
    private final EthnicityRepository ethnicityRepository;
    private final GradeRepository gradeRepository;

    @Autowired
    public DefaultExamineeProcessor(final SchoolRepository schoolRepository,
                                    final StudentRepository studentRepository,
                                    final GenderRepository genderRepository,
                                    final EthnicityRepository ethnicityRepository,
                                    final GradeRepository gradeRepository) {
        this.genderRepository = genderRepository;
        this.ethnicityRepository = ethnicityRepository;
        this.gradeRepository = gradeRepository;
        this.schoolRepository = schoolRepository;
        this.studentRepository = studentRepository;
    }

    @Override
    public StudentExamAttributes process(final Examinee examinee, final School school) throws ImportException {

        // parse and collect all parsing issues before proceeding with other actions
        final List<String> errMsg = newArrayList();
        Student student = null;
        try {
            student = parseStudent(examinee);
        } catch (final ImportException e) {
            errMsg.add(e.getMessage());
        }

        StudentExamAttributes.Builder studentExamAttrBuilder = null;
        try {
            studentExamAttrBuilder = parseStudentAttributes(examinee);
        } catch (final ImportException e) {
            errMsg.add(e.getMessage());
        }

        if (!errMsg.isEmpty()) throw new ImportException(ImportStatus.BAD_DATA, on(",").join(errMsg));

        final int schoolId = schoolRepository.upsert(school);
        final long studentId = studentRepository.upsert(student);

        return studentExamAttrBuilder
                .withResponsibleSchoolId(schoolId)
                .withStudentId(studentId)
                .build();
    }

    @Override
    public School parseExamineeRelationship(final Examinee examinee) throws ImportException {
        final List<DataElementError> elementErrors = newArrayList();
        final Builder schoolBuilder = School.builder()
                .withDistrict(District.builder()
                        .withStateCode(parseMandatoryRelationship(examinee, "StateAbbreviation", elementErrors))
                        .withNaturalId(parseMandatoryRelationship(examinee, "ResponsibleDistrictIdentifier", elementErrors))
                        .withName(parseMandatoryRelationship(examinee, "OrganizationName", elementErrors))
                        .build())
                .withNaturalId(parseMandatoryRelationship(examinee, "ResponsibleInstitutionIdentifier", elementErrors))
                .withName(parseMandatoryRelationship(examinee, "NameOfInstitution", elementErrors));

        if (elementErrors.isEmpty()) return schoolBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private Student parseStudent(final Examinee examinee) throws ImportException {
        final List<DataElementError> elementErrors = newArrayList();
        final Student.Builder studentBuilder = Student.builder()
                .withFirstName(parseMandatoryAttribute(examinee, "FirstName", String.class, elementErrors))
                .withLastOrSurname(parseMandatoryAttribute(examinee, "LastOrSurname", String.class, elementErrors))
                .withMiddleName(parseOptionalAttribute(examinee, "MiddleName", String.class, elementErrors))
                .withSsid(parseMandatoryAttribute(examinee, "StudentIdentifier", String.class, elementErrors))
                .withBirthday(parseMandatoryAttribute(examinee, "Birthdate", Date.class, elementErrors))
                .withGenderId(parseGenderId(examinee, elementErrors))
                .withFirsEntryIntoUSSchoolAt(parseOptionalAttribute(examinee, "FirstEntryDateIntoUSSchool", Date.class, elementErrors))
                .withLepEntryAt(parseOptionalAttribute(examinee, "LimitedEnglishProficiencyEntryDate", Date.class, elementErrors))
                .withLepExitAt(parseOptionalAttribute(examinee, "LEPExitDate", Date.class, elementErrors))
                .withMiddleName(parseOptionalAttribute(examinee, "MiddleName", String.class, elementErrors))
                .withEthnicityId(parseEthnicityId(examinee, elementErrors));

        if (elementErrors.isEmpty()) return studentBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private StudentExamAttributes.Builder parseStudentAttributes(final Examinee examinee) throws ImportException {
        final List<DataElementError> elementErrors = newArrayList();
        final StudentExamAttributes.Builder studentAttributesBuilder = StudentExamAttributes.builder()

                .withIdeaIndicator(parseMandatoryAttribute(examinee, "IDEAIndicator", Boolean.class, elementErrors))
                .withLep(parseMandatoryAttribute(examinee, "LEPStatus", Boolean.class, elementErrors))
                .withSection504(parseMandatoryAttribute(examinee, "Section504Status", Boolean.class, elementErrors))
                .withEconomicDisadvantage(parseMandatoryAttribute(examinee, "EconomicDisadvantageStatus", Boolean.class, elementErrors))
                .withMigrantStatus(parseOptionalAttribute(examinee, "MigrantStatus", Boolean.class, elementErrors))
                .withLanguageCode(parseOptionalAttribute(examinee, "LanguageCode", String.class, elementErrors))
                .withEngProfLvl(parseOptionalAttribute(examinee, "EnglishLanguageProficiencyLevel", String.class, elementErrors))
                .withT3ProgramType(parseOptionalAttribute(examinee, "TitleIIILanguageInstructionProgramType", String.class, elementErrors))
                .withPrimDisabilityType(parseOptionalAttribute(examinee, "PrimaryDisabilityType", String.class, elementErrors))
                .withGradeId(parseGradeId(examinee, elementErrors));

        if (elementErrors.isEmpty()) return studentAttributesBuilder;
        throw new ImportException(ImportStatus.BAD_DATA, on(",").join(elementErrors));
    }

    private Integer parseEthnicityId(final Examinee examinee, final List<DataElementError> elementErrors) {
        // TODO: this assumes that a student can have only one ethnicity.
        // TODO: this has hardcoded ethnicity - may need to be changed
        final String[] ethnicityAttributes = {
                "HispanicOrLatinoEthnicity",
                "AmericanIndianOrAlaskaNative",
                "Asian",
                "BlackOrAfricanAmerican",
                "White",
                "NativeHawaiianOrOtherPacificIslander",
                "DemographicRaceTwoOrMoreRaces"};

        for (final String ethnicity : ethnicityAttributes) {
            final Boolean value = parseMandatoryAttribute(examinee, ethnicity, Boolean.class, elementErrors);
            if (value == null || !value) continue;

            try {
                return ethnicityRepository.findIdByName(ethnicity);
            } catch (final IllegalArgumentException e) {
                elementErrors.add(new DataElementError(ethnicity, ethnicity, e.getMessage()));
            }
        }

        return null;
    }

    private Integer parseGenderId(final Examinee examinee, final List<DataElementError> elementErrors) {
        final String sexAttr = "Sex";
        final String sex = parseMandatoryAttribute(examinee, sexAttr, String.class, elementErrors);

        if (sex == null) return null;

        try {
            return genderRepository.findIdByName(sex);
        } catch (final IllegalArgumentException e) {
            elementErrors.add(new DataElementError(sexAttr, sex, e.getMessage()));
            return null;
        }
    }

    private Integer parseGradeId(final Examinee examinee, final List<DataElementError> elementErrors) {
        final String gradeAttr = "GradeLevelWhenAssessed";
        final String grade = parseMandatoryAttribute(examinee, gradeAttr, String.class, elementErrors);

        if (grade == null) return null;

        try {
            return gradeRepository.findIdByCode(grade);
        } catch (final IllegalArgumentException e) {
            elementErrors.add(new DataElementError(gradeAttr, grade, e.getMessage()));
            return null;
        }
    }

    private static <T> T parseMandatoryAttribute(final Examinee examinee,
                                                 final String element,
                                                 final Class<T> parsedValue,
                                                 final List<DataElementError> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute != null) return parseMandatoryValue(attribute.getValue(), element, parsedValue, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value"));
        return null;
    }

    private static <T> T parseOptionalAttribute(final Examinee examinee,
                                                final String element,
                                                final Class<T> parsedValue,
                                                final List<DataElementError> elementErrors) {
        final ExamineeAttribute attribute = examinee.getBestAttribute(element);

        if (attribute == null || isNullOrEmpty(attribute.getValue())) return null;

        return parseMandatoryAttribute(examinee, element, parsedValue, elementErrors);
    }

    private static String parseMandatoryRelationship(final Examinee examinee,
                                                     final String element,
                                                     final List<DataElementError> elementErrors) {
        final ExamineeRelationship attribute = examinee.getBestRelationship(element);

        if (attribute != null) return parseMandatoryValue(attribute.getValue(), element, String.class, elementErrors);

        elementErrors.add(new DataElementError(element, null, "missing value"));
        return null;
    }
}
