package org.opentestsystem.rdw.ingest.processor.service.impl;

import config.DataElementsConfiguration;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.Context;
import org.opentestsystem.rdw.common.model.trt.Examinee;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeRelationship;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.DataElementError;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.model.DataElement;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.model.StudentGroup;
import org.opentestsystem.rdw.ingest.processor.repository.ElasRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GenderRepository;
import org.opentestsystem.rdw.ingest.processor.repository.GradeRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import utils.ExamParserHelper;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static org.hibernate.validator.internal.util.CollectionHelper.newArrayList;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toBoolean;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toLocalDate;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.Birthdate;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.EconomicDisadvantageStatus;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.EnglishLanguageAcquisitionStatus;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.EnglishLanguageAcquisitionStatusStartDate;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.EnglishLanguageProficiencyLevel;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.Ethnicity;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.FirstEntryDateIntoUSSchool;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.FirstName;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.GradeLevelWhenAssessed;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.IDEAIndicator;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.LEPExitDate;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.LEPStatus;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.LanguageCode;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.LastOrSurname;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.LimitedEnglishProficiencyEntryDate;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.MiddleName;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.MigrantStatus;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.PrimaryDisabilityType;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.SchoolId;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.Section504Status;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.Sex;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.StudentGroupName;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.StudentIdentifier;
import static org.opentestsystem.rdw.ingest.processor.model.DataElement.TitleIIILanguageInstructionProgramType;


@Service
class DefaultExamineeProcessor implements ExamineeProcessor {

    private final GenderRepository genderRepository;
    private final EthnicityService ethnicityService;
    private final GradeRepository gradeRepository;
    private final SchoolRepository schoolRepository;
    private final ElasRepository elasRepository;
    private final Set<DataElement> optionalDataElements;

    @Autowired
    DefaultExamineeProcessor(final GenderRepository genderRepository,
                             final GradeRepository gradeRepository,
                             final EthnicityService ethnicityService,
                             final SchoolRepository schoolRepository,
                             final ElasRepository elasRepository,
                             final DataElementsConfiguration requiredDataElementsConfiguration) {
        this.genderRepository = genderRepository;
        this.gradeRepository = gradeRepository;
        this.ethnicityService = ethnicityService;
        this.schoolRepository = schoolRepository;
        this.elasRepository = elasRepository;
        this.optionalDataElements = requiredDataElementsConfiguration.getOptionalDataElements();
    }

    @Override
    public int parseSchoolId(final Examinee examinee) throws ImportException {
        final String naturalId = getBestRelationshipValue(examinee, SchoolId.name());
        final Integer schoolId = schoolRepository.findIdByNaturalId(naturalId);
        if (schoolId != null) return schoolId;
        // put as much info as possible into the import message
        final String schoolName = getBestRelationshipValue(examinee, "SchoolName");
        final String districtId = getBestRelationshipValue(examinee, "DistrictId");
        final String districtName = getBestRelationshipValue(examinee, "DistrictName");
        throw new ImportException(ImportStatus.UNKNOWN_SCHOOL,
                "unable to find a school with natural id [" + naturalId + "]." +
                " School name: " + schoolName + ", district id: [" + districtId + "], district name: " + districtName);
    }

    @Override
    public Student parseStudent(final Examinee examinee, final int schoolYear, final int schoolId) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ExamParserHelper parserHelper = new ExamParserHelper(errorCollector, optionalDataElements);
        if (examinee.getIsDemo()) {
            errorCollector.add(new DataElementError("isDemo", "true", "demo students are not supported"));
        }

        final Student.Builder studentBuilder = Student.builder()
                .firstName(parserHelper.validate(FirstName, getBestAttributeValue(examinee, FirstName), 60))
                .lastOrSurname(parserHelper.validate(LastOrSurname, getBestAttributeValue(examinee, LastOrSurname), 60))
                .middleName(parserHelper.validate(MiddleName, getBestAttributeValue(examinee, MiddleName), 60))
                .ssid(parserHelper.validate(StudentIdentifier, getBestAttributeValue(examinee, StudentIdentifier), 65))
                .birthday(parserHelper.validate(Birthdate, getBestAttributeValue(examinee, Birthdate), toLocalDate))
                .genderId(parserHelper.validate(Sex, getBestAttributeValue(examinee, Sex), checkNotBlank.andThen(genderRepository::findIdByCode)))
                .firsEntryIntoUSSchoolAt(parserHelper.validate(FirstEntryDateIntoUSSchool, getBestAttributeValue(examinee, FirstEntryDateIntoUSSchool), toLocalDate))
                .lepEntryAt(parserHelper.validate(LimitedEnglishProficiencyEntryDate, getBestAttributeValue(examinee, LimitedEnglishProficiencyEntryDate), toLocalDate))
                .lepExitAt(parserHelper.validate(LEPExitDate, getBestAttributeValue(examinee, LEPExitDate), toLocalDate));

        final Collection<Integer> ethnicity = ethnicityService.getEthnicity(examinee, errorCollector);
        // each individual ethnicity value is validated by the ethnicity service,
        // but a validation of at least one ethnicity being required is done here
        if (!optionalDataElements.contains(Ethnicity) && ethnicity.isEmpty()) {
            errorCollector.add(new DataElementError(Ethnicity.name(), "none", "must provide an ethnicity"));
        }

        final List<StudentGroup> groups = parseGroups(examinee, schoolYear, schoolId, parserHelper);
        if (!optionalDataElements.contains(StudentGroupName) && groups.isEmpty()) {
            errorCollector.add(new DataElementError(StudentGroupName.name(), "none", "must provide a student group"));
        }

        studentBuilder
                .ethnicityIds(ethnicity)
                .groups(groups);

        if (errorCollector.isEmpty()) return studentBuilder.build();
        throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }

    @Override
    public StudentExamAttributes parseStudentExamAttributes(final Examinee examinee, final int schoolId, final DataElementErrorCollector errorCollector) {
        final ExamParserHelper parserHelper = new ExamParserHelper(errorCollector, optionalDataElements);
        final StudentExamAttributes.Builder builder = StudentExamAttributes.builder()
                .ideaIndicator(parserHelper.validate(IDEAIndicator, getBestAttributeValue(examinee, IDEAIndicator), toBoolean))
                .section504(parserHelper.validate(Section504Status, getBestAttributeValue(examinee, Section504Status), toSection504Status))
                .economicDisadvantage(parserHelper.validate(EconomicDisadvantageStatus, getBestAttributeValue(examinee, EconomicDisadvantageStatus), toBoolean))
                .migrantStatus(parserHelper.validate(MigrantStatus, getBestAttributeValue(examinee, MigrantStatus), toBoolean))
                .languageCode(parserHelper.validate(LanguageCode, getBestAttributeValue(examinee, LanguageCode), 3))
                .lep(parserHelper.validate(LEPStatus, getBestAttributeValue(examinee, LEPStatus), toBoolean))
                .engProfLvl(parserHelper.validate(EnglishLanguageProficiencyLevel, getBestAttributeValue(examinee, EnglishLanguageProficiencyLevel), 20))
                .t3ProgramType(parserHelper.validate(TitleIIILanguageInstructionProgramType, getBestAttributeValue(examinee, TitleIIILanguageInstructionProgramType), 30))
                .primDisabilityType(parserHelper.validate(PrimaryDisabilityType, getBestAttributeValue(examinee, PrimaryDisabilityType), 3))
                .gradeId(parserHelper.validate(GradeLevelWhenAssessed, getBestAttributeValue(examinee, GradeLevelWhenAssessed), checkNotBlank.andThen(gradeRepository::findIdByCode)))
                .responsibleSchoolId(schoolId)
                .examineeId(examinee.getKey())
                // ELAS (and its date) are optional
                .elasId(parserHelper.validate(EnglishLanguageAcquisitionStatus, getBestAttributeValue(examinee, EnglishLanguageAcquisitionStatus), checkNotBlank.andThen(elasRepository::findIdByCode)))
                .elasStartDate(parserHelper.validate(EnglishLanguageAcquisitionStatusStartDate, getBestAttributeValue(examinee, EnglishLanguageAcquisitionStatusStartDate), toLocalDate));

        return errorCollector.isEmpty() ? builder.build() : null;
    }

    private List<StudentGroup> parseGroups(final Examinee examinee, final int schoolYear, final int schoolId, final ExamParserHelper parserHelper) {
        // deal with student groups: create groups if they don't already exist then add student to them
        final List<StudentGroup> groups = newArrayList();
        final Set<String> groupNames = getBestGroupNames(examinee);
        if (!groupNames.isEmpty()) {
            for (final String groupName : groupNames) {
                groups.add(StudentGroup.builder()
                        .name(parserHelper.validate(StudentGroupName, groupName, 255))
                        .schoolId(schoolId)
                        .schoolYear(schoolYear)
                        .active(true)
                        .build());
            }
        }
        return groups;
    }

    /**
     * Map of aliases for TRT attribute field names. The key is the documented TRT attribute field name,
     * while the value is an alternate name, typically from the DWSA (the CSV import file) spec.
     * These will be used when looking for attribute values; for now for efficiency, just string attributes.
     * Although it is unlikely that multiple entries will exist with different names, if that happens the
     * TRT-named attribute value will be favored.
     */
    private static final Map<String, String> FieldAliases = newHashMap();

    static {
        FieldAliases.put(StudentIdentifier.name(), "SSID");
        FieldAliases.put(GradeLevelWhenAssessed.name(), "Grade");
        FieldAliases.put(SchoolId.name(), "ResponsibleInstitutionIdentifier");
        FieldAliases.put(LimitedEnglishProficiencyEntryDate.name(), "EnglishLearnerIdentificationDate");
        FieldAliases.put(LEPExitDate.name(), "ReclassifiedFluentEnglishProficientDate");
    }

    private static String getBestAttributeValue(final Examinee examinee,
                                                final DataElement element) {
        ExamineeAttribute attribute = examinee.getBestAttribute(element.name());
        if (attribute == null && FieldAliases.containsKey(element)) {
            attribute = examinee.getBestAttribute(FieldAliases.get(element));
        }

        return attribute == null ? null : attribute.getValue();
    }

    private static String getBestRelationshipValue(final Examinee examinee,
                                                   final String element) {
        ExamineeRelationship attribute = examinee.getBestRelationship(element);
        if (attribute != null) return attribute.getValue();

        if (FieldAliases.containsKey(element)) {
            attribute = examinee.getBestRelationship(FieldAliases.get(element));
        }
        return attribute == null ? null : attribute.getValue();
    }

    private static Set<String> getBestGroupNames(final Examinee examinee) {
        // get attributes with "StudentGroupName"
        // if any are FINAL then only get FINAL else only get INITIAL
        final Set<String> finalNames = newHashSet();
        final Set<String> initialNames = newHashSet();
        for (final Object obj : examinee.getExamineeAttributeOrExamineeRelationship()) {
            if (!(obj instanceof ExamineeAttribute)) continue;
            final ExamineeAttribute attribute = (ExamineeAttribute) obj;
            if (StudentGroupName.name().equals(attribute.getName())) {
                if (Context.FINAL.equals(attribute.getContext())) finalNames.add(attribute.getValue());
                else initialNames.add(attribute.getValue());
            }
        }
        return finalNames.isEmpty() ? initialNames : finalNames;
    }

    /**
     * The Section504Status attribute has a legacy value that indicates "unknown" which maps to null.
     * Otherwise it is a required boolean value.
     */
    static final Function<String, Boolean> toSection504Status = value -> {
        if ("Unknown/Cannot Provide".equalsIgnoreCase(value)) return null;
        return toBoolean.apply(value);
    };
}
