package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.Sets;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.repository.StudentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcCall;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.google.common.collect.Lists.newArrayList;

@Repository
class JdbcStudentRepository implements StudentRepository {

    private final JdbcTemplate jdbcTemplate;
    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    @Value("${sql.studentEthnicity.create}")
    private String sqlCreateStudentEthnicity;

    @Value("${sql.studentEthnicity.delete}")
    private String sqlDeleteStudentEthnicity;

    @Value("${sql.studentEthnicity.findAllIds}")
    private String sqlFindAllStudentEthnicityIds;

    @Value("${sql.student.updateImportId}")
    private String sqlUpdateStudentImportId;

    @Autowired
    JdbcStudentRepository(final JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);
    }

    @Override
    @Retryable(maxAttemptsExpression = "${jdbc.retry.default.max-attempts}", backoff = @Backoff(delayExpression = "${jdbc.retry.default.delay}", multiplierExpression = "${jdbc.retry.default.multiplier}", random = true))
    @Transactional
    public int upsert(final Student student, final long importId) {
        final Map<String, Object> retParams = new SimpleJdbcCall(jdbcTemplate)
                .withProcedureName("student_upsert")
                // in production environments procedure metadata may not be accessible so be explicit
                .withoutProcedureColumnMetaDataAccess()
                .useInParameterNames("p_ssid", "p_last_or_surname", "p_first_name", "p_middle_name", "p_gender_id",
                        "p_first_entry_into_us_school_at", "p_lep_entry_at", "p_lep_exit_at", "p_birthday", "p_exam_school_id", "p_exam_completed_at", "p_import_id")
                .declareParameters(
                        new SqlParameter("p_ssid", Types.VARCHAR),
                        new SqlParameter("p_last_or_surname", Types.VARCHAR),
                        new SqlParameter("p_first_name", Types.VARCHAR),
                        new SqlParameter("p_middle_name", Types.VARCHAR),
                        new SqlParameter("p_alias_name", Types.VARCHAR),
                        new SqlParameter("p_gender_id", Types.TINYINT),
                        new SqlParameter("p_first_entry_into_us_school_at", Types.DATE),
                        new SqlParameter("p_lep_entry_at", Types.DATE),
                        new SqlParameter("p_lep_exit_at", Types.DATE),
                        new SqlParameter("p_birthday", Types.DATE),
                        new SqlParameter("p_exam_school_id", Types.INTEGER),
                        new SqlParameter("p_exam_completed_at", Types.TIMESTAMP),
                        new SqlParameter("p_import_id", Types.BIGINT),
                        new SqlOutParameter("p_id", Types.INTEGER),
                        new SqlOutParameter("p_updated", Types.INTEGER))
                .execute(new MapSqlParameterSource()
                        .addValue("p_ssid", student.getSsid())
                        .addValue("p_last_or_surname", student.getLastOrSurname())
                        .addValue("p_first_name", student.getFirstName())
                        .addValue("p_middle_name", student.getMiddleName())
                        .addValue("p_alias_name", student.getAliasName())
                        .addValue("p_gender_id", student.getGenderId())
                        .addValue("p_first_entry_into_us_school_at", student.getFirsEntryIntoUSSchoolAt())
                        .addValue("p_lep_entry_at", student.getLepEntryAt())
                        .addValue("p_lep_exit_at", student.getLepExitAt())
                        .addValue("p_birthday", student.getBirthday())
                        .addValue("p_import_id", importId)
                        .addValue("p_exam_school_id", student.getSchool() == null ? null : student.getSchool().getSchoolId())
                        .addValue("p_exam_completed_at", student.getSchool() == null ? null : Timestamp.from(student.getSchool().getEffectiveDate())));

        final int studentId = (int) retParams.get("p_id");

        final boolean isStudentUnchanged = ((int) retParams.get("p_updated") == 0);
        // to adhere to the warehouse ingest rules we need to update student's import id if and only if there was a change
        // the stored procedure returns a code identifying if something has changed
        // if the stored procedure has not changed anything, but there is ethnicity change, we need to update the import id
        if (updateEthnicity(student.getEthnicityIds(), studentId) && isStudentUnchanged) {
            namedParameterJdbcTemplate.update(sqlUpdateStudentImportId, new MapSqlParameterSource("student_id", studentId).addValue("update_import_id", importId));
        }
        return studentId;
    }

    private boolean updateEthnicity(final List<Integer> newIds, final int studentId) {
        // if the existing ethnicity ids match the new ids, we have nothing to do here ...
        final List<Integer> existingIds = namedParameterJdbcTemplate.queryForList(sqlFindAllStudentEthnicityIds, new MapSqlParameterSource("student_id", studentId), Integer.class);

        if (newIds.size() == existingIds.size() && newIds.containsAll(existingIds)) return false;

        final Set<Integer> idsToAdd = Sets.difference(Sets.newHashSet(newIds), Sets.newHashSet(existingIds));
        final Set<Integer> idsToDelete = Sets.difference(Sets.newHashSet(existingIds), Sets.newHashSet(newIds));

        executeEthnicityChange(idsToDelete, studentId, sqlDeleteStudentEthnicity);
        executeEthnicityChange(idsToAdd, studentId, sqlCreateStudentEthnicity);
        return true;
    }

    private void executeEthnicityChange(final Set<Integer> idsToChange, final int studentId, final String sql) {
        if (!idsToChange.isEmpty()) {
            final List<SqlParameterSource> batchParameters = newArrayList();
            for (final int newId : idsToChange) {
                batchParameters.add(new MapSqlParameterSource("student_id", studentId).addValue("ethnicity_id", newId));
            }
            namedParameterJdbcTemplate.batchUpdate(sql, batchParameters.toArray(new SqlParameterSource[batchParameters.size()]));
        }
    }
}
