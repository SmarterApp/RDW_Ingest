package org.opentestsystem.rdw.ingest.processor.service.impl;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.rdw.ingest.processor.model.ExamTrait;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.Opportunity;
import org.opentestsystem.rdw.common.model.trt.Opportunity.Accommodation;
import org.opentestsystem.rdw.common.model.trt.Opportunity.Score;
import org.opentestsystem.rdw.common.model.trt.TDSReport;
import org.opentestsystem.rdw.common.model.trt.Test;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.utils.DataElementError;
import org.opentestsystem.rdw.utils.DataElementErrorCollector;
import org.opentestsystem.rdw.utils.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.config.DataElementsConfiguration;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.AssessmentScore;
import org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.model.ExamScore;
import org.opentestsystem.rdw.ingest.processor.model.ExamTarget;
import org.opentestsystem.rdw.ingest.processor.repository.AccommodationRepository;
import org.opentestsystem.rdw.ingest.processor.repository.AdminConditionRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CompletenessRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamItemProcessor;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.ingest.processor.service.StudentExamProcessor;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.utils.ParserHelper.toDoubleOrNull;
import static org.opentestsystem.rdw.utils.ParserHelper.toInteger;
import static org.opentestsystem.rdw.utils.ParserHelper.toYear;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.AdministrationCondition;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.Completeness;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.ExamItems;
import static org.opentestsystem.rdw.ingest.processor.model.ConfigurableDataElement.SessionId;
import static org.springframework.util.StringUtils.hasText;

@Service
class DefaultStudentExamProcessor implements StudentExamProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultStudentExamProcessor.class);

    private static final String RawScoreLabel = "RawScore";
    private static final String ScaleScoreMeasureLabel = "ScaleScore";
    private static final String ThetaScoreMeasureLabel = "ThetaScore";
    private static final String PerformanceLevelMeasureLabel = "PerformanceLevel";
    private static final String OverallScore = "Overall";
    private static final String StudentRelativeResidualScoreLabel = "StudentRelativeResidualScore";
    private static final String BenchmarkLabel = "Benchmark";               // alias for StudentRelativeResidualScore
    private static final String StandardMetRelativeResidualScoreLabel = "StandardMetRelativeResidualScore";
    private static final String ProficiencyDeltaLabel = "ProficiencyDelta"; // alias for StandardMetRelativeResidualScore
    private static final List<String> scoreLabelsToValidate = ImmutableList.of(StudentRelativeResidualScoreLabel, StandardMetRelativeResidualScoreLabel);
    private static final String ResetStatus = "reset";

    private final AdminConditionRepository adminConditionRepository;
    private final CompletenessRepository completenessRepository;
    private final ExamItemProcessor examItemProcessor;
    private final AccommodationRepository accommodationRepository;
    private final ExamineeProcessor examineeProcessor;
    private final Set<ConfigurableDataElement> optionalDataElements;

    @Autowired
    DefaultStudentExamProcessor(final ExamItemProcessor examItemProcessor,
                                final AdminConditionRepository adminConditionRepository,
                                final CompletenessRepository completenessRepository,
                                final AccommodationRepository accommodationRepository,
                                final ExamineeProcessor examineeProcessor,
                                final DataElementsConfiguration dataElementsConfiguration) {
        this.examItemProcessor = examItemProcessor;
        this.adminConditionRepository = adminConditionRepository;
        this.completenessRepository = completenessRepository;
        this.accommodationRepository = accommodationRepository;
        this.examineeProcessor = examineeProcessor;
        this.optionalDataElements = dataElementsConfiguration.getOptionalDataElements();
    }

    @Override
    public Exam parseExam(final TDSReport report, final int schoolId, final Assessment assessment) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ExamParserHelper parserHelper = new ExamParserHelper(errorCollector, optionalDataElements);

        final Test test = report.getTest();
        final Opportunity opportunity = report.getOpportunity();

        final Exam.Builder builder = parseScoreData(opportunity, assessment, parserHelper)
                .typeId(assessment.getTypeId())
                .examItems(parserHelper.isNotEmpty(ExamItems, examItemProcessor.parseExamItems(opportunity.getItem(), assessment, errorCollector)))
                .studentExamAttributes(examineeProcessor.parseStudentExamAttributes(report.getExaminee(), schoolId, errorCollector))
                .schoolYear(parserHelper.validate("Test AcademicYear", test.getAcademicYear(), toYear))
                .assessmentId(assessment.getId())
                .asmtVersion(parserHelper.validate("Test AssessmentVersion", test.getAssessmentVersion(), 30, false))
                .opportunity(opportunity.getOpportunity())
                .oppId(parserHelper.validate("OppId", opportunity.getOppId(), 60, true))
                .sessionId(parserHelper.validate(SessionId, opportunity.getSessionId(), 128))
                .completenessId(parserHelper.validate(Completeness, opportunity.getBestCompleteness(), this::toValidCompleteness))
                .administrationConditionId(parseAdministrationCondition(opportunity, assessment, parserHelper))
                .completedAt(parserHelper.validate("DateCompleted", opportunity.getDateCompleted(), new CheckNotNull<>()))
                .accommodationIds(parseAccommodations(opportunity.getAccommodation()))
                .statusDate(opportunity.getStatusDate())
                .deleted(ResetStatus.equalsIgnoreCase(opportunity.getStatus()))
                .deliverMode(test.getMode())
                .handScoreProject(test.getHandScoreProject())
                .contract(test.getContract())
                .testReason(opportunity.getTestReason())
                .assessmentAdminStartedAt(opportunity.getEffectiveDate())
                .startedAt(opportunity.getStartDate())
                .forceSubmittedAt(opportunity.getDateForceCompleted())
                .status(opportunity.getStatus())
                .itemCount(opportunity.getItemCount())
                .fieldTestCount(opportunity.getFtCount())
                .pauseCount(opportunity.getPauseCount())
                .gracePeriodRestarts(opportunity.getGracePeriodRestarts())
                .abnormalStarts(opportunity.getAbnormalStarts())
                .testWindowId(opportunity.getWindowId())
                .testAdministratorId(opportunity.getTaId())
                .responsibleOrganizationName(opportunity.getClientName())
                .testAdministratorName(opportunity.getTaName())
                .sessionPlatformUserAgent(opportunity.getAssessmentParticipantSessionPlatformUserAgent())
                .testDeliveryServer(opportunity.getServer())
                .testDeliveryDb(opportunity.getDatabase())
                .windowOpportunityCount(opportunity.getWindowOpportunity());

        if (errorCollector.isEmpty()) return builder.build();
        else throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }

    private Iterable<Integer> parseAccommodations(final List<Accommodation> accommodations) {

        if (accommodations.isEmpty()) return newArrayList();

        final List<String> accommodationCodes = newArrayList();
        for (final Opportunity.Accommodation acc : accommodations) {
            accommodationCodes.add(acc.getCode());
        }

        final List<Integer> accommodationIds = accommodationRepository.findIdsByCodes(accommodationCodes);

        if (accommodationCodes.size() > accommodationIds.size())
            logger.debug("Not all accommodation codes [" + accommodationCodes.toString() + "] passed validation, invalid [" + Math.abs(accommodationCodes.size() - accommodationIds.size()) + "] codes");
        return accommodationIds;
    }

    /**
     * Helper to parse the adminstration condition to its id:<ul>
     *     <li>if it is set, look up the code</li>
     *     <li>if it is blank and is allowed to be blank, return null</li>
     *     <li>if it is blank and isn't allowed to be null, use the default for the assessment type</li>
     * </ul>
     * @param opportunity opportunity containing admin condition
     * @param assessment assessment (to get type)
     * @param parserHelper helper to parse data and collect errors
     * @return administration condition id, may be null
     */
    private Integer parseAdministrationCondition(final Opportunity opportunity,
                                                 final Assessment assessment,
                                                 final ExamParserHelper parserHelper) {
        // if the value is blank and is allowed to be, validate will short-circuit and return null
        return parserHelper.validate(AdministrationCondition, opportunity.getAdministrationCondition(), rawValue ->
            (Integer) new CheckNotNull<>().apply(adminConditionRepository.findIdByCode(
                hasText(rawValue) ? rawValue : assessment.getTypeId() == AssessmentType.SUMMATIVE.id() ? "Valid" : "SD")));
    }

    private Integer toValidCompleteness(final String value) {
        return (Integer) new CheckNotNull<>().apply(completenessRepository.findIdByCode((value == null || value.isEmpty()) ? "Complete" : value));
    }

    /**
     * Helper to parse score data.<br/>
     * Score elements represent lots of different things: overall score, alternate
     * scores, target scores, trait scores; and for each of those there are
     * elements for scaled score, theta score, performance level, etc. Thus the
     * parsing and building is non-trivial. In particular, some exam objects
     * require data from multiple score elements so we need to carry around
     * builders to pull the pieces together.
     *
     * @param opportunity    opportunity containing score elements
     * @param assessment     assessment for this exam
     * @param parserHelper   helper to parse data and collect errors
     * @return exam builder with score values set
     */
    private Exam.Builder parseScoreData(final Opportunity opportunity,
                                        final Assessment assessment,
                                        final ParserHelper parserHelper) {
        final Exam.Builder examBuilder = Exam.builder();
        final Map<String, ExamScore.Builder> claimBuilders = newHashMap();
        final Map<String, ExamTarget.Builder> targetBuilders = newHashMap();

        final Map<String, AssessmentScore> scoresByCode = assessment.getScores()
                .stream().collect(Collectors.toMap(AssessmentScore::getCode, s -> s));
        final Map<String, Integer> targetCodeToId = assessment.getTargetCodeToId();
        final Map<String, Integer> traitCodeToId = assessment.getTraits();

        final Set<Integer> traitIds = newHashSet();

        for (final Score score : opportunity.getScore()) {
            final String measureOf = score.getMeasureOf();
            final String measureLabel = score.getMeasureLabel();

            if (OverallScore.equals(measureOf)) {
                // overall score is essentially hard-coded and is part of the main exam object
                final AssessmentScore assessmentScore = scoresByCode.get("OVERALL");

                if (ScaleScoreMeasureLabel.equals(measureLabel)) {
                    examBuilder.scaleScore(parserHelper.validate(measureOf + " " + measureLabel, score.getValue(), scoreChecker(assessmentScore)))
                        .scaleScoreStdErr(parserHelper.validate(measureOf + " " + measureLabel + " StandardError", score.getStandardError(), toPositiveDoubleOrNull));
                } else if (ThetaScoreMeasureLabel.equals(measureLabel)) {
                    examBuilder.thetaScore(parserHelper.validate(measureOf + " " + measureLabel, score.getValue(), toDoubleOrNull))
                        .thetaScoreStdErr(parserHelper.validate(measureOf + " " + measureLabel + " StandardError", score.getStandardError(), toPositiveDoubleOrNull));
                } else if (PerformanceLevelMeasureLabel.equals(measureLabel)) {
                    examBuilder.performanceLevel(parserHelper.validate(measureOf + " " + measureLabel, score.getValue(), toPositiveIntOrNull));
                }
            } else if (scoresByCode.containsKey(measureOf)) {
                // claim scores are identified by claim codes configured by subject for this assessment
                final AssessmentScore assessmentScore = scoresByCode.get(measureOf);

                final ExamScore.Builder builder = claimBuilders
                        .computeIfAbsent(measureOf, k -> ExamScore.builder().subjectScoreId(assessmentScore.getSubjectScoreId()));
                if (ScaleScoreMeasureLabel.equals(measureLabel)) {
                    builder.scaleScore(parserHelper.validate(measureOf + " " + measureLabel, score.getValue(), scoreChecker(assessmentScore)))
                        .scaleScoreStdErr(parserHelper.validate(measureOf + " " + measureLabel + " StandardError", score.getStandardError(), toPositiveDoubleOrNull));
                } else if (ThetaScoreMeasureLabel.equals(measureLabel)) {
                    builder.thetaScore(parserHelper.validate(measureOf + " " + measureLabel, score.getValue(), toDoubleOrNull))
                        .thetaScoreStdErr(parserHelper.validate(measureOf + " " + measureLabel + " StandardError", score.getStandardError(), toPositiveDoubleOrNull));
                } else if (PerformanceLevelMeasureLabel.equals(measureLabel)) {
                    builder.performanceLevel(parserHelper.validate(measureOf + " " + measureLabel, score.getValue(), toPositiveIntOrNull));
                }
            } else if (targetCodeToId.containsKey(measureOf)) {
                // target scores are identified by codes configured for this assessment
                final ExamTarget.Builder builder = targetBuilders
                        .computeIfAbsent(measureOf, k -> ExamTarget.builder().targetId(targetCodeToId.get(k)));
                if (StudentRelativeResidualScoreLabel.equals(measureLabel) || BenchmarkLabel.equals(measureLabel)) {
                    builder.studentRelativeResidualScore(parserHelper.validate(measureOf + " " + measureLabel, score.getValue(), toDoubleOrNull));
                } else if (StandardMetRelativeResidualScoreLabel.equals(measureLabel) || ProficiencyDeltaLabel.equals(measureLabel)) {
                    builder.standardMetRelativeResidualScore(parserHelper.validate(measureOf + " " + measureLabel, score.getValue(), toDoubleOrNull));
                }
            } else if (traitCodeToId.containsKey(measureOf)) {
                // trait scores are identified as RawScore for codes configured for this assessment's subject
                if (RawScoreLabel.equals(measureLabel)) {
                    final int traitId = traitCodeToId.get(measureOf);
                    if (!traitIds.add(traitId)) {
                        parserHelper.addError(new DataElementError("Score", measureOf, "duplicate trait score"));
                    } else {
                        // TODO - there is a maxScore we could validate the score against; would have to load into Assessment
                        examBuilder.examTrait(ExamTrait.builder()
                            .traitId(traitId)
                            .score(parserHelper.validate(measureOf, score.getValue(), toInteger))
                            .conditionCode(score.getConditionCode())
                            .build());
                    }
                }
            } else if (scoreLabelsToValidate.contains(measureLabel)) {
                parserHelper.addError(new DataElementError("scoreOf [" + measureOf + "] for label [" + measureLabel + "]", score.getValue(), "unrecognizable score for the asmt"));
            }
        }

        return examBuilder
                .examClaims(claimBuilders.values().stream().map(ExamScore.Builder::build).collect(toList()))
                .examTargets(targetBuilders.values().stream().map(ExamTarget.Builder::build).collect(toList()));
    }

    private static final Function<String, Double> toPositiveDoubleOrNull = value -> {
        if (!hasText(value)) return null;

        final Double parseDouble = Double.parseDouble(value);

        if (parseDouble >= 0) return parseDouble;

        throw new IllegalArgumentException("invalid value, must be a positive number");
    };

    private static Function<String, Double> scoreChecker(final AssessmentScore assessmentScore) {
        return value -> {
            if (!hasText(value)) return null;
            if ("NS".equalsIgnoreCase(value)) return null;

            final double score = Double.parseDouble(value);
            if (score == 0) return null;

            // this shouldn't happen (except in ill behaved tests) but ...
            if (assessmentScore == null) {
                return score;
            }

            final Double minScore = assessmentScore.getMinScore();
            final Double maxScore = assessmentScore.getMaxScore();
            if ((minScore == null || score >= minScore) && (maxScore == null || score <= maxScore)) {
                return score;
            }
            throw new IllegalArgumentException("invalid value, must be " + minScore + " - " + maxScore);
        };
    }

    private static final Function<String, Integer> toPositiveIntOrNull = value -> {
        if (!hasText(value)) return null;

        final Integer level = Integer.parseInt(value);
        if (level > 0) return level;

        throw new IllegalArgumentException("invalid value, must be a positive number");
    };
}
