package org.opentestsystem.rdw.ingest.processor.service.impl;

import org.opentestsystem.rdw.common.model.trt.Opportunity;
import org.opentestsystem.rdw.common.model.trt.Opportunity.Accommodation;
import org.opentestsystem.rdw.common.model.trt.Opportunity.Score;
import org.opentestsystem.rdw.common.model.trt.TDSReport;
import org.opentestsystem.rdw.common.model.trt.Test;
import org.opentestsystem.rdw.ingest.common.config.SbacScoreConfiguration;
import org.opentestsystem.rdw.ingest.common.model.ImportException;
import org.opentestsystem.rdw.ingest.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.util.CheckNotNull;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.common.util.ParserHelper;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.model.ExamClaim;
import org.opentestsystem.rdw.ingest.processor.model.ExamClaim.Builder;
import org.opentestsystem.rdw.ingest.processor.model.SubjectClaimScore;
import org.opentestsystem.rdw.ingest.processor.repository.AccommodationRepository;
import org.opentestsystem.rdw.ingest.processor.repository.AdminConditionRepository;
import org.opentestsystem.rdw.ingest.processor.repository.CompletenessRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamItemProcessor;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.ingest.processor.service.StudentExamProcessor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.function.Function;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.checkNotBlank;
import static org.opentestsystem.rdw.ingest.common.util.ParserHelper.toYear;
import static org.springframework.util.StringUtils.hasText;

@Service
class DefaultStudentExamProcessor implements StudentExamProcessor {
    private static final Logger logger = LoggerFactory.getLogger(DefaultStudentExamProcessor.class);

    private final static String ScaleScoreMeasureLabel = "ScaleScore";
    private final static String ThetaScoreMeasureLabel = "ThetaScore";
    private final static String PerformanceLevelMeasureLabel = "PerformanceLevel";
    private final static String OverallScore = "Overall";
    private final static String ResetStatus = "reset";

    private final SbacScoreConfiguration scoreConfiguration;
    private final AdminConditionRepository adminConditionRepository;
    private final CompletenessRepository completenessRepository;
    private final ExamItemProcessor examItemProcessor;
    private final AccommodationRepository accommodationRepository;
    private final ExamineeProcessor examineeProcessor;

    @Autowired
    DefaultStudentExamProcessor(final SbacScoreConfiguration scoreConfiguration,
                                final ExamItemProcessor examItemProcessor,
                                final AdminConditionRepository adminConditionRepository,
                                final CompletenessRepository completenessRepository,
                                final AccommodationRepository accommodationRepository,
                                final ExamineeProcessor examineeProcessor) {
        this.scoreConfiguration = scoreConfiguration;
        this.examItemProcessor = examItemProcessor;
        this.adminConditionRepository = adminConditionRepository;
        this.completenessRepository = completenessRepository;
        this.accommodationRepository = accommodationRepository;
        this.examineeProcessor = examineeProcessor;
    }

    @Override
    public Exam parseExam(final TDSReport report, final int schoolId, final Assessment assessment) throws ImportException {
        final DataElementErrorCollector errorCollector = new DataElementErrorCollector();
        final ParserHelper parserHelper = new ParserHelper(errorCollector);

        final Test test = report.getTest();
        final Opportunity opportunity = report.getOpportunity();

        final Exam.Builder builder = parseScoreData(opportunity, assessment.getSubjectClaimScores(), parserHelper)
                .typeId(assessment.getTypeId())
                .examItems(examItemProcessor.parseExamItems(opportunity.getItem(), assessment, errorCollector))
                .studentExamAttributes(examineeProcessor.parseStudentExamAttributes(report.getExaminee(), schoolId, errorCollector))
                .schoolYear(parserHelper.validate("Test AcademicYear", test.getAcademicYear(), toYear))
                .assessmentId(assessment.getId())
                .asmtVersion(parserHelper.validate("Test AssessmentVersion", test.getAssessmentVersion(), 30, false))
                .opportunity(opportunity.getOpportunity())
                .oppId(parserHelper.validate("Opportunity oppId", opportunity.getOppId(), 60, false))
                .sessionId(parserHelper.validate("sessionId", opportunity.getSessionId(), 128, true))
                .completenessId(parserHelper.validate("completeness", opportunity.getBestCompleteness(), checkNotBlank.andThen(completenessRepository::findIdByCode).andThen(new CheckNotNull<>())))
                .administrationConditionId(parserHelper.validate("AdministrationCondition", opportunity.getAdministrationCondition(), checkNotBlank.andThen(adminConditionRepository::findIdByCode).andThen(new CheckNotNull<>())))
                .completedAt(parserHelper.validate("DateCompleted", opportunity.getDateCompleted(), new CheckNotNull<>()))
                .accommodationIds(parseAccommodations(opportunity.getAccommodation()))
                .statusDate(opportunity.getStatusDate())
                .deleted(ResetStatus.equalsIgnoreCase(opportunity.getStatus()))
                .deliverMode(test.getMode())
                .handScoreProject(test.getHandScoreProject())
                .contract(test.getContract())
                .testReason(opportunity.getTestReason())
                .assessmentAdminStartedAt(opportunity.getEffectiveDate())
                .startedAt(opportunity.getStartDate())
                .forceSubmittedAt(opportunity.getDateForceCompleted())
                .status(opportunity.getStatus())
                .itemCount(opportunity.getItemCount())
                .fieldTestCount(opportunity.getFtCount())
                .pauseCount(opportunity.getPauseCount())
                .gracePeriodRestarts(opportunity.getGracePeriodRestarts())
                .abnormalStarts(opportunity.getAbnormalStarts())
                .testWindowId(opportunity.getWindowId())
                .testAdministratorId(opportunity.getTaId())
                .responsibleOrganizationName(opportunity.getClientName())
                .testAdministratorName(opportunity.getTaName())
                .sessionPlatformUserAgent(opportunity.getAssessmentParticipantSessionPlatformUserAgent())
                .testDeliveryServer(opportunity.getServer())
                .testDeliveryDb(opportunity.getDatabase())
                .windowOpportunityCount(opportunity.getWindowOpportunity());

        if (errorCollector.isEmpty()) return builder.build();
        else throw new ImportException(ImportStatus.BAD_DATA, errorCollector.toJson());
    }

    private Iterable<Integer> parseAccommodations(final List<Accommodation> accommodations) {

        if (accommodations.isEmpty()) return newArrayList();

        final List<String> accommodationCodes = newArrayList();
        for (final Opportunity.Accommodation acc : accommodations) {
            accommodationCodes.add(acc.getCode());
        }

        final List<Integer> accommodationIds = accommodationRepository.findIdsByCodes(accommodationCodes);

        if (accommodationCodes.size() > accommodationIds.size())
            logger.debug("Not all accommodation codes [" + accommodationCodes.toString() + "] passed validation, invalid [" + Math.abs(accommodationCodes.size() - accommodationIds.size()) + "] codes");
        return accommodationIds;
    }

    private Exam.Builder parseScoreData(final Opportunity opportunity, final List<SubjectClaimScore> claims, final ParserHelper parserHelper) {
        final Exam.Builder examBuilder = Exam.builder();
        final Map<String, Builder> claimBuilders = getClaimBuilders(claims);

        for (final Score score : opportunity.getScore()) {
            final String scoreOf = score.getMeasureOf();
            final String label = score.getMeasureLabel();

            if (OverallScore.equals(scoreOf)) {
                if (ScaleScoreMeasureLabel.equals(label)) {
                    examBuilder
                            .scaleScore(parserHelper.validate(scoreOf + " " + ScaleScoreMeasureLabel, score.getValue(), this::toScaleScore))
                            .scaleScoreStdErr(parserHelper.validate(scoreOf + " " + ScaleScoreMeasureLabel + " StandardError", score.getStandardError(), toPositiveDoubleOrNull));
                } else if (ThetaScoreMeasureLabel.equals(label)) {
                    examBuilder
                            .thetaScore(parserHelper.validate(scoreOf + " " + ThetaScoreMeasureLabel, score.getValue(), this::toThetaScore))
                            .thetaScoreStdErr(parserHelper.validate(scoreOf + " " + ThetaScoreMeasureLabel + " StandardError", score.getStandardError(), toPositiveDoubleOrNull));
                } else if (PerformanceLevelMeasureLabel.equals(label)) {
                    examBuilder
                            .performanceLevel(parserHelper.validate(scoreOf + " " + ScaleScoreMeasureLabel + " PerformanceLevel", score.getValue(), toPositiveIntOrNull));
                }
            } else if (claimBuilders.containsKey(scoreOf)) {
                if (ScaleScoreMeasureLabel.equals(label)) {
                    claimBuilders.get(scoreOf)
                            .scaleScore(parserHelper.validate(scoreOf + " " + ScaleScoreMeasureLabel, score.getValue(), this::toScaleScore))
                            .scaleScoreStdErr(parserHelper.validate(scoreOf + " " + ScaleScoreMeasureLabel + " StandardError", score.getStandardError(), toPositiveDoubleOrNull));
                } else if (ThetaScoreMeasureLabel.equals(label)) {
                    claimBuilders.get(scoreOf)
                            .thetaScore(parserHelper.validate(scoreOf + " " + ThetaScoreMeasureLabel, score.getValue(), this::toThetaScore))
                            .thetaScoreStdErr(parserHelper.validate(scoreOf + " " + ThetaScoreMeasureLabel + " StandardError", score.getStandardError(), toPositiveDoubleOrNull));
                } else if (PerformanceLevelMeasureLabel.equals(label)) {
                    claimBuilders.get(scoreOf)
                            .category(parserHelper.validate(scoreOf + " " + PerformanceLevelMeasureLabel + " Category", score.getValue(), toPositiveIntOrNull));
                }
            }
        }

        final List<ExamClaim> examClaims = newArrayList();
        for (final ExamClaim.Builder claimBuilder : claimBuilders.values()) {
            examClaims.add(claimBuilder.build());
        }

        return examBuilder.examClaims(examClaims);
    }

    private Map<String, Builder> getClaimBuilders(final List<SubjectClaimScore> claims) {
        final Map<String, Builder> claimBuilders = newHashMap();
        for (final SubjectClaimScore subjectClaimScore : claims) {
            claimBuilders.put(subjectClaimScore.getCode(), ExamClaim.builder().claimId(subjectClaimScore.getId()));
        }
        return claimBuilders;
    }

    public static final Function<String, Double> toPositiveDoubleOrNull = value -> {
        if (!hasText(value)) return null;

        final Double parseDouble = Double.parseDouble(value);

        if (parseDouble >= 0) return parseDouble;

        throw new IllegalArgumentException("invalid value, must be a positive number");
    };

    private Double toScaleScore(final String value) {
        if (!hasText(value)) return null;

        final Double score = Double.parseDouble(value);
        if (score >= scoreConfiguration.getScaleScore().getMin() && score <= scoreConfiguration.getScaleScore().getMax()) return score;

        throw new IllegalArgumentException("invalid value, must be " + scoreConfiguration.getScaleScore().getMin() + " - " + scoreConfiguration.getScaleScore().getMax());
    }

    private Double toThetaScore(final String value) {
        if (!hasText(value)) return null;

        final Double score = Double.parseDouble(value);
        if (score >= scoreConfiguration.getThetaScore().getMin() && score <= scoreConfiguration.getThetaScore().getMax()) return score;

        throw new IllegalArgumentException("invalid value, must be " + scoreConfiguration.getThetaScore().getMin() + " - " + scoreConfiguration.getThetaScore().getMax());
    }

    private static final Function<String, Integer> toPositiveIntOrNull = value -> {
        if (!hasText(value)) return null;

        final Integer level = Integer.parseInt(value);
        if (level > 0) return level;

        throw new IllegalArgumentException("invalid value, must be a positive number");
    };
}