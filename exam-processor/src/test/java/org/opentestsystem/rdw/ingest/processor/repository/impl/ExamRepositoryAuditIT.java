package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.ImmutableMap;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.model.ExamScore;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.ExamItemSubScore;
import org.opentestsystem.rdw.ingest.processor.model.ExamTarget;
import org.opentestsystem.rdw.ingest.processor.model.ExamTrait;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.repository.ExamRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.jdbc.Sql;

import java.time.Instant;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTableWhere;

@SuppressWarnings({"SqlNoDataSourceInspection", "SqlResolve"})
@Import(JdbcExamRepository.class)
@Sql(statements = {
    "INSERT INTO import (id,status,content,contentType,digest,created) VALUES " +
        "(-1,0,1, 'application/xml','1D849A91956B74350FF895F067F115E6',CURRENT_DATE)," +
        "(-2,0,1, 'application/xml','1D849A91956B74350FF895F067F115E7',CURRENT_DATE)," +
        "(-3,0,1, 'application/xml','1D849A91956B74350FF895F067F125E6',CURRENT_DATE)," +
        "(-4,0,1, 'application/xml','1D849A91956B74350FF895F067F135E6',CURRENT_DATE)," +
        "(-5,0,1, 'application/xml','1D849A91956B74350FF895F067F145E7',CURRENT_DATE);" +
        "INSERT IGNORE INTO district (id, name, natural_id) VALUES\n" +
        "  (-11, 'Sample District 1', 'District1NaturalId');",
    "INSERT IGNORE INTO school (id, district_id, name, natural_id, import_id, update_import_id) VALUES\n" +
        "  (-12, -11, 'Sample School 1', 'School1NaturalId', -1, -1);",
    "INSERT INTO student (id, ssid, last_or_surname, first_name, middle_name, alias_name, gender_id, first_entry_into_us_school_at, lep_entry_at, lep_exit_at, birthday, import_id, update_import_id) VALUES\n" +
        "  (-11, '6666666666', 'LastName6', 'FirstName6', 'MiddleName6', 'AliasName6', 1, '2015-09-01', null, null, '2006-01-01', -1, -1)," +
        "  (-12, '7777777777', 'LastName7', 'FirstName7', 'MiddleName7', 'AliasName7', 1, '2015-09-01', null, null, '2006-01-01', -1, -1);",
    "INSERT INTO asmt (id, natural_id, grade_id,type_id, subject_id, school_year, name, label, version, import_id, update_import_id) VALUES\n" +
        "  (-1, '(SBAC)SBAC-ICA-FIXED-G5E-COMBINED-2017', 5, 1, 2, 2016, 'SBAC-ICA-FIXED-G5E-COMBINED-2017', 'Grade 5 ELA', '9831', -1, -1);\n",
    "INSERT INTO item (id, claim_id, target_id, natural_id, asmt_id, dok_id, difficulty, max_points, math_practice, allow_calc) VALUES \n" +
        " (-1, 1, 1, 'item1', -1, 1, 0.5, 5, null, null)," +
        " (-2, 1, 1, 'item3', -1, 1, 0.5, 5, null, null)," +
        " (-3, 1, 1, 'item4', -1, 1, 0.5, 5, null, null)," +
        " (-4, 1, 1, 'item4.2', -1, 1, 0.5, 5, null, null)," +
        " (-5, 1, 1, 'item5', -1, 1, 0.5, 5, null, null)," +
        " (-6, 1, 1, 'item6', -1, 1, 0.5, 5, null, null);",
    "INSERT INTO accommodation (id, code) VALUES " +
        " (-99, 'ACC_CODE1')," +
        " (-98, 'ACC_CODE2')," +
        " (-97, 'ACC_CODE3')," +
        " (-96, 'ACC_CODE4')," +
        " (-95, 'ACC_CODE5')," +
        " (-94, 'ACC_CODE6');",
    "INSERT INTO subject_trait (id, subject_id, code, purpose, category, max_score) VALUES \n" +
        "(-21, 2, 'T1', 'ARGU', 'ORG', 3);"
})
public class ExamRepositoryAuditIT extends TenantAwareIT {

    @Autowired
    private ExamRepository repository;

    @Autowired
    private JdbcTemplate jdbcTemplate;
    private NamedParameterJdbcTemplate namedParameterTemplate;

    private Exam.Builder builder;

    @Before
    public void setUp() {
        namedParameterTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);

        builder = Exam.builder()
                .typeId(AssessmentType.ICA.id())
                .performanceLevel(5)
                .administrationConditionId(1)
                .asmtVersion("345")
                .assessmentId(-1)
                .completedAt(Instant.parse("2007-01-02T14:30:00Z"))
                .schoolYear(2015)
                .completenessId(1)
                .opportunity(7L)
                .oppId("22840351")
                .scaleScore(77.7)
                .scaleScoreStdErr(6.6)
                .sessionId("session")
                .studentExamAttributes(StudentExamAttributes.builder()
                        .studentId(-11)
                        .economicDisadvantage(true)
                        .engProfLvl("engl prof")
                        .gradeId(1)
                        .ideaIndicator(true)
                        .languageId(0)
                        .militaryConnectedId(1)
                        .lep(false)
                        .migrantStatus(false)
                        .primDisabilityType("PD")
                        .responsibleSchoolId(-12)
                        .section504(true)
                        .t3ProgramType("t3")
                        .examineeId(-1111L)
                        .elasId(1)
                        .elasStartDate(LocalDate.of(2011, 1, 7))
                        .build());

        final List<ExamScore> claims = newArrayList();
        for (int claim = 1; claim < 4; claim++) {
            claims.add(ExamScore.builder()
                    .subjectScoreId(-1 * claim)
                    .performanceLevel(1)
                    .scaleScore((double) claim)
                    .scaleScoreStdErr((double) claim + 1)
                    .build());
        }
        builder.examClaims(claims);

        builder.examTargets(newArrayList(
                ExamTarget.builder().targetId(1).studentRelativeResidualScore(0.2).standardMetRelativeResidualScore(0.5).build()));

        final List<ExamItem> items = newArrayList();
        final List<ExamItemSubScore> subScores = newArrayList();
        subScores.add(new ExamItemSubScore(1, 1.1, "status1"));
        subScores.add(new ExamItemSubScore(2, 2.2, "status2"));
        subScores.add(new ExamItemSubScore(3, 3.3, "status3"));
        items.add(ExamItem.builder()
                .itemId(-1)
                .score(3.7)
                .scoreStatus("status A")
                .response("test response A")
                .position(1)
                .submitted(1)
                .numberOfVisits(2L)
                .pageNumber(1L)
                .pageTime(3)
                .pageVisits(4L)
                .responseContentType("type")
                .responseDuration(1.1)
                .responseTypeId(1)
                .subScoreList(subScores)
                .administeredAt(Instant.parse("2007-05-02T14:30:00Z"))
                .submittedAt(Instant.parse("2007-05-03T14:30:00Z"))
                .build());
        items.add(ExamItem.builder()
                .itemId(-2)
                .score(7.8)
                .scoreStatus("status B")
                .response("test response B")
                .position(2)
                .administeredAt(Instant.parse("2007-05-02T15:30:00Z"))
                .submittedAt(Instant.parse("2007-05-03T15:30:00Z"))
                .build());

        builder.examItems(items);

        final List<Integer> accommodations = newArrayList();
        accommodations.add(-99);
        builder.accommodationIds(accommodations);

        // Enable and disable of triggers is an operational concern, these tests must have them on
        jdbcTemplate.update("UPDATE setting s SET s.value = 'TRUE' WHERE s.name = 'AUDIT_TRIGGER_ENABLE';");
        assertThat(countRowsInTableWhere(jdbcTemplate, "setting s", " s.name = 'AUDIT_TRIGGER_ENABLE' and s.value = 'TRUE'")).isEqualTo(1);
    }

    @Test
    public void itShouldAuditExamUpdates() {
        final String updateAction = "update";

        final Exam originalExam = builder
                .completenessId(1)
                .build();
        final long originalExamId = repository.upsert(originalExam, -1);
        final Map<String, Object> originalExamValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalExamId));

        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(0);

        final Exam secondExam = builder
                .completenessId(1)
                .administrationConditionId(2)
                .schoolYear(2018)
                .deleted(false)
                .statusDate(Instant.parse("2011-01-01T14:30:00Z"))
                .deliverMode("mode")
                .handScoreProject(-99L)
                .contract("contract")
                .testReason("testReason")
                .assessmentAdminStartedAt(LocalDate.of(2011, 1, 7))
                .startedAt(Instant.parse("2011-01-02T14:30:00Z"))
                .forceSubmittedAt((Instant.parse("2011-01-03T14:30:00Z")))
                .status("status")
                .itemCount(9L)
                .fieldTestCount(7L)
                .pauseCount(1L)
                .gracePeriodRestarts(2L)
                .abnormalStarts(3L)
                .testWindowId("testWindowId")
                .testAdministratorId("testAdministratorId")
                .responsibleOrganizationName("responsibleOrganizationName")
                .testAdministratorName("testAdministratorName")
                .sessionPlatformUserAgent("sessionPlatformUserAgent")
                .testDeliveryServer("testDeliveryServer")
                .testDeliveryDb("testDeliveryDb")
                .windowOpportunityCount("999")
                .thetaScore(0.99)
                .thetaScoreStdErr(0.009)
                .build();
        final long secondExamId = repository.upsert(secondExam, -2);
        final Map<String, Object> secondExamValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalExamId));
        final Map<String, Object> firstAuditValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM audit_exam WHERE exam_id = :exam_id",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));

        // At least one comparison between audit and actual must have no null values in actual to assure all columns are audited.
        secondExamValues.forEach((k, v) -> assertThat(v).as(k).isNotNull());

        assertThat(originalExamId).isEqualTo(secondExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(1);

        assertThat(originalExamValues.remove("id")).isEqualTo(originalExamId);
        assertThat(firstAuditValues.remove("id")).isNotNull();
        assertThat(firstAuditValues.remove("action")).isEqualTo(updateAction);
        assertThat(firstAuditValues.remove("audited")).isNotNull();
        assertThat(firstAuditValues.remove("database_user")).isNotNull();
        assertThat(firstAuditValues.remove("exam_id")).isEqualTo(originalExamId);
        assertThat(originalExamValues).isEqualTo(firstAuditValues);

        final Exam thirdExam = builder
                .completenessId(2)
                .administrationConditionId(2)
                .schoolYear(2018)
                .deleted(false)
                .build();
        final long thirdExamId = repository.upsert(thirdExam, -3);

        final Map<String, Object> secondAuditValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM audit_exam ae WHERE ae.exam_id = :exam_id ORDER BY ae.audited DESC LIMIT 1",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));

        assertThat(originalExamId).isEqualTo(thirdExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(2);

        assertThat(secondExamValues.remove("id")).isEqualTo(originalExamId);
        assertThat(secondAuditValues.remove("id")).isNotNull();
        assertThat(secondAuditValues.remove("action")).isEqualTo(updateAction);
        assertThat(secondAuditValues.remove("audited")).isNotNull();
        assertThat(secondAuditValues.remove("database_user")).isNotNull();
        assertThat(secondAuditValues.remove("exam_id")).isEqualTo(originalExamId);
        assertThat(secondExamValues).isEqualTo(secondAuditValues);
    }

    @Test
    public void itShouldAuditExamDeletes() {
        final String updateAction = "update";

        final Exam originalExam = builder
                .completenessId(1)
                .build();
        final long originalExamId = repository.upsert(originalExam, -1);
        final Map<String, Object> originalExamValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalExamId));

        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(0);

        final Exam secondExam = builder
                .deleted(true)
                .build();
        repository.delete(secondExam, -2);
        final long secondExamId = repository.findOne(secondExam.getAssessmentId(), secondExam.getOppId()).getId();

        final Map<String, Object> secondExamValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalExamId));
        final Map<String, Object> firstAuditValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM audit_exam WHERE exam_id = :exam_id",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));

        assertThat(originalExamId).isEqualTo(secondExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(1);

        assertThat(originalExamValues.remove("id")).isEqualTo(originalExamId);
        assertThat(firstAuditValues.remove("id")).isNotNull();
        assertThat(firstAuditValues.remove("action")).isEqualTo(updateAction);
        assertThat(firstAuditValues.remove("audited")).isNotNull();
        assertThat(firstAuditValues.remove("database_user")).isNotNull();
        assertThat(firstAuditValues.remove("exam_id")).isEqualTo(originalExamId);
        assertThat(originalExamValues).isEqualTo(firstAuditValues);

        final Exam thirdExam = builder
                .completenessId(2)
                .administrationConditionId(2)
                .schoolYear(2018)
                .deleted(false)
                .build();
        final long thirdExamId = repository.upsert(thirdExam, -3);

        final Map<String, Object> secondAuditValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM audit_exam ae WHERE ae.exam_id = :exam_id ORDER BY ae.audited DESC LIMIT 1",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));

        assertThat(originalExamId).isEqualTo(thirdExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(2);

        assertThat(secondExamValues.remove("id")).isEqualTo(originalExamId);
        assertThat(secondAuditValues.remove("id")).isNotNull();
        assertThat(secondAuditValues.remove("action")).isEqualTo(updateAction);
        assertThat(secondAuditValues.remove("audited")).isNotNull();
        assertThat(secondAuditValues.remove("database_user")).isNotNull();
        assertThat(secondAuditValues.remove("exam_id")).isEqualTo(originalExamId);
        assertThat(secondExamValues).isEqualTo(secondAuditValues);
    }

    @Test
    public void itShouldAuditExamAvailableAccommodations() {

        // *** Create exam with no accommodations ***
        final Exam originalExam = builder
                .build();
        final long originalExamId = repository.upsert(originalExam, -1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_available_accommodation", " exam_id = " + originalExamId)).isEqualTo(0);

        // *** First Update exam adding 3 accommodations ***
        final List<Integer> accommodations = newArrayList();
        accommodations.add(-99);
        accommodations.add(-98);
        accommodations.add(-97);
        final Exam secondExam = builder
                .accommodationIds(accommodations)
                .build();
        final long secondExamId = repository.upsert(secondExam, -2);

        assertThat(originalExamId).isEqualTo(secondExamId);
        // The first update adds 3 accommodations making the total for the exam 3. (only deletes are audited)
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_available_accommodation", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_available_accommodation", " exam_id = " + originalExamId)).isEqualTo(3);

        // *** Second Update exam remove 2(-98, -97) and add 2 accommodations ***
        // Save exam_available_accommodation records to be deleted by update to compare with audit records.
        final List<Map<String, Object>> secondExamAccList = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_available_accommodation WHERE exam_id = :exam_id AND accommodation_id IN (-98, -97)",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));
        assertThat(secondExamAccList.size()).isEqualTo(2);

        // At least one comparison between audit and actual must have no null values in actual to assure all columns are audited.
        secondExamAccList.get(0).forEach((k, v) -> assertThat(v).isNotNull());

        accommodations.clear();
        accommodations.add(-99);
        accommodations.add(-96);
        accommodations.add(-95);
        repository.upsert(builder.accommodationIds(accommodations).build(), -3);

        // The second update removes 2 accommodations and adds 2 others. (only deletes are audited)
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_available_accommodation", " exam_id = " + originalExamId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_available_accommodation", " exam_id = " + originalExamId)).isEqualTo(3);
        compareAuditExamAvailableAccommodationToActual(secondExamAccList, originalExamId);

        // *** Third update ***
        accommodations.clear();
        accommodations.add(-99);
        accommodations.add(-98);
        accommodations.add(-97);
        accommodations.add(-96);
        accommodations.add(-95);
        repository.upsert(builder.accommodationIds(accommodations).build(), -4);

        // *** Fourth update ***
        accommodations.clear();
        accommodations.add(-97);
        // Save exam_available_accommodation records to be deleted by update to compare with audit records.
        final List<Map<String, Object>> fourthExamAccList = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_available_accommodation WHERE exam_id = :exam_id AND accommodation_id IN (-99, -98, -96, -95)",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));
        assertThat(fourthExamAccList.size()).isEqualTo(4);
        repository.upsert(builder.accommodationIds(accommodations).build(), -5);

        // The third and fourth updates add 2 then delete 4. (only deletes are audited)
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(4);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_available_accommodation", " exam_id = " + originalExamId)).isEqualTo(6);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_available_accommodation", " exam_id = " + originalExamId)).isEqualTo(1);
        compareAuditExamAvailableAccommodationToActual(fourthExamAccList, originalExamId);
    }

    private void compareAuditExamAvailableAccommodationToActual(final List<Map<String, Object>> examAccList, final long originalExamId) {
        examAccList.forEach((examAccValues) -> {
            final Map<String, Object> auditAccValues = namedParameterTemplate.queryForMap(
                    "SELECT * FROM audit_exam_available_accommodation WHERE exam_id = :exam_id " +
                            "AND accommodation_id = :accommodation_id " +
                            "ORDER BY audited DESC LIMIT 1",
                    new MapSqlParameterSource()
                            .addValue("exam_id", originalExamId)
                            .addValue("accommodation_id", examAccValues.get("accommodation_id")));

            assertThat(auditAccValues.remove("id")).isNotNull();
            assertThat(auditAccValues.remove("action")).isEqualTo("delete");
            assertThat(auditAccValues.remove("audited")).isNotNull();
            assertThat(auditAccValues.remove("database_user")).isNotNull();
            assertThat(examAccValues).isEqualTo(auditAccValues);
        });
    }

    @Test
    public void itShouldAuditExamItem() {

        // *** Create exam with 4 items ***
        final Exam originalExam = builder
                .examItems(createItemsForAudit(ImmutableMap.<Integer, Integer>builder().put(-1, 1).put(-2, 1).put(-3, 1).put(-4, 1).build()))
                .build();
        final long originalExamId = repository.upsert(originalExam, -1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_item", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_item", " exam_id = " + originalExamId)).isEqualTo(4);

        // *** First Update delete two items and modify two ***
        // Save items for comparison with audit
        final List<Map<String, Object>> originalExamItemListToDelete = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_item WHERE exam_id = :exam_id AND item_id IN (-1, -3)",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));
        assertThat(originalExamItemListToDelete.size()).isEqualTo(2);

        final List<Map<String, Object>> originalExamItemListToUpdate = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_item WHERE exam_id = :exam_id AND item_id IN (-2, -4)",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));
        assertThat(originalExamItemListToUpdate.size()).isEqualTo(2);

        // At least one comparison between audit and actual must have no null values in actual to assure all columns are audited.
        originalExamItemListToDelete.get(0).forEach((k, v) -> assertThat(v).isNotNull());
        originalExamItemListToUpdate.get(0).forEach((k, v) -> assertThat(v).isNotNull());

        final Exam secondExam = builder
                .examItems(createItemsForAudit(ImmutableMap.<Integer, Integer>builder().put(-2, 2).put(-4, 2).build()))
                .build();
        final long secondExamId = repository.upsert(secondExam, -2);

        assertThat(originalExamId).isEqualTo(secondExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_item", " exam_id = " + originalExamId)).isEqualTo(4);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_item", " exam_id = " + originalExamId + " AND action = 'delete'")).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_item", " exam_id = " + originalExamId + " AND action = 'update'")).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_item", " exam_id = " + originalExamId)).isEqualTo(2);
        compareAuditExamItemToActual(originalExamItemListToDelete, originalExamId, "delete");
        compareAuditExamItemToActual(originalExamItemListToUpdate, originalExamId, "update");

        // *** Second Update adds one, updates one and leaves on unchanged ***
        // Save items for comparison with audit
        final List<Map<String, Object>> secondExamItemListToUpdate = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_item WHERE exam_id = :exam_id AND item_id IN (-2)",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));
        assertThat(secondExamItemListToUpdate.size()).isEqualTo(1);

        final Exam thirdExam = builder
                .examItems(createItemsForAudit(ImmutableMap.<Integer, Integer>builder().put(-1, 1).put(-2, 3).put(-4, 2).build()))
                .build();
        final long thirdExamId = repository.upsert(thirdExam, -3);

        assertThat(originalExamId).isEqualTo(thirdExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_item", " exam_id = " + originalExamId)).isEqualTo(5);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_item", " exam_id = " + originalExamId + " AND action = 'delete'")).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_item", " exam_id = " + originalExamId + " AND action = 'update'")).isEqualTo(3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_item", " exam_id = " + originalExamId)).isEqualTo(3);
        compareAuditExamItemToActual(secondExamItemListToUpdate, originalExamId, "update");
    }

    private List<ExamItem> createItemsForAudit(final Map<Integer, Integer> itemIdMap) {
        final String scoreStatus = "score status:";
        final String response = "response:";
        final Long numberOfVisits = 0L;
        final Integer pageTime = 10;
        final List<ExamItem> items = newArrayList();
        final List<ExamItemSubScore> subScores = newArrayList();
        subScores.add(new ExamItemSubScore(1, 1.1, "status1"));
        subScores.add(new ExamItemSubScore(2, 2.2, "status2"));
        subScores.add(new ExamItemSubScore(3, 3.3, "status3"));

        itemIdMap.forEach(
                (itemId, version) -> items.add(ExamItem.builder()
                        .itemId(itemId)
                        .score(3.7)
                        .scoreStatus(scoreStatus + version)
                        .response(response + version)
                        .position(itemId * -1)
                        .submitted(1)
                        .numberOfVisits(numberOfVisits + version)
                        .pageNumber(1L)
                        .pageTime(pageTime + version)
                        .pageVisits(4L)
                        .responseContentType("type")
                        .responseDuration(1.1)
                        .responseTypeId(1)
                        .subScoreList(subScores)
                        .administeredAt(Instant.parse("2007-05-02T14:30:00Z"))
                        .submittedAt(Instant.parse("2007-05-03T14:30:00Z"))
                        .build())
        );
        return items;
    }

    private void compareAuditExamItemToActual(final List<Map<String, Object>> examItemList, final long originalExamId, final String action) {
        examItemList.forEach((examItemValues) -> {
            final Map<String, Object> auditItemValues = namedParameterTemplate.queryForMap(
                    "SELECT * FROM audit_exam_item WHERE exam_id = :exam_id " +
                            "AND item_id = :item_id " +
                            "AND action = '" + action + "' " +
                            "ORDER BY audited DESC LIMIT 1",
                    new MapSqlParameterSource()
                            .addValue("exam_id", originalExamId)
                            .addValue("item_id", examItemValues.get("item_id")));

            assertThat(auditItemValues.remove("id")).isNotNull();
            assertThat(auditItemValues.remove("action")).isEqualTo(action);
            assertThat(auditItemValues.remove("audited")).isNotNull();
            assertThat(auditItemValues.remove("database_user")).isNotNull();
            assertThat(auditItemValues.remove("exam_item_id")).isEqualTo(examItemValues.remove("id"));
            assertThat(examItemValues).isEqualTo(auditItemValues);
        });
    }

    @Test
    public void itShouldAuditExamClaimScore() {
        // *** Create exam with no claim scores ***
        final Exam originalExam = builder
                .examClaims(null)
                .build();
        final long originalExamId = repository.upsert(originalExam, -1);

        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_score", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", " id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", " exam_id = " + originalExamId)).isEqualTo(0);

        // *** Second upsert add three claim scores to exam ***
        final Exam secondExam = builder
                .examClaims(createClaimsForAudit(ImmutableMap.<Integer, Integer>builder().put(-1, 1).put(-2, 1).put(-3, 1).build()))
                .build();
        final long secondExamId = repository.upsert(secondExam, -2);

        assertThat(originalExamId).isEqualTo(secondExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_score", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", " id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", " exam_id = " + originalExamId)).isEqualTo(3);

        // *** Third upsert update two claim scores and keep one unchanged ***
        // Save second exam claim scores to compare
        final List<Map<String, Object>> secondExamClaimScoreListToUpdate = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_score WHERE exam_id = :exam_id AND subject_score_id IN (-1, -3)",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));
        assertThat(secondExamClaimScoreListToUpdate.size()).isEqualTo(2);

        final Exam thirdExam = builder
                .examClaims(createClaimsForAudit(ImmutableMap.<Integer, Integer>builder().put(-1, 2).put(-2, 1).put(-3, 2).build()))
                .build();
        final long thirdExamId = repository.upsert(thirdExam, -3);

        assertThat(originalExamId).isEqualTo(thirdExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_score", " exam_id = " + originalExamId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", " id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", " exam_id = " + originalExamId)).isEqualTo(3);
        compareAuditExamClaimScoreToActual(secondExamClaimScoreListToUpdate, originalExamId, "update");

        // *** Fourth upsert.  Delete one, update one, leave one unchanged and add one. ***
        // Save third exam claim scores to compare with audit
        final List<Map<String, Object>> thirdExamClaimScoreListToUpdate = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_score WHERE exam_id = :exam_id AND subject_score_id IN (-2)",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));
        assertThat(thirdExamClaimScoreListToUpdate.size()).isEqualTo(1);

        final List<Map<String, Object>> thirdExamClaimScoreListToDelete = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_score WHERE exam_id = :exam_id AND subject_score_id IN (-1)",
                new MapSqlParameterSource().addValue("exam_id", originalExamId));
        assertThat(thirdExamClaimScoreListToDelete.size()).isEqualTo(1);

        // At least one comparison between audit and actual must have no null values in actual to assure all columns are audited.
        thirdExamClaimScoreListToUpdate.get(0).forEach((k, v) -> assertThat(v).isNotNull());
        thirdExamClaimScoreListToDelete.get(0).forEach((k, v) -> assertThat(v).isNotNull());

        final Exam fourthExam = builder
                .examClaims(createClaimsForAudit(ImmutableMap.<Integer, Integer>builder().put(-2, 2).put(-3, 2).put(-4, 1).build()))
                .build();
        final long fourthExamId = repository.upsert(fourthExam, -4);

        assertThat(originalExamId).isEqualTo(fourthExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_score", " exam_id = " + originalExamId)).isEqualTo(4);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", " id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", " exam_id = " + originalExamId)).isEqualTo(3);
        compareAuditExamClaimScoreToActual(thirdExamClaimScoreListToDelete, originalExamId, "delete");
        compareAuditExamClaimScoreToActual(thirdExamClaimScoreListToUpdate, originalExamId, "update");
    }

    private List<ExamScore> createClaimsForAudit(final Map<Integer, Integer> claimIdMap) {
        final List<ExamScore> claims = newArrayList();

        claimIdMap.forEach(
                (claimId, version) -> claims.add(ExamScore.builder()
                        .subjectScoreId(claimId)
                        .performanceLevel(1)
                        .scaleScore(2200.0 + 17.3 * version)
                        .scaleScoreStdErr(30.0 + 7 * version)
                        .thetaScore(-3.0 + 2.5 * version)
                        .thetaScoreStdErr(0.12 + .13 * version)
                        .build())
        );
        return claims;
    }

    private void compareAuditExamClaimScoreToActual(final List<Map<String, Object>> examClaimScoreList, final long originalExamId, final String action) {
        examClaimScoreList.forEach((examClaimScoreValues) -> {
            final Map<String, Object> auditClaimScoreValues = namedParameterTemplate.queryForMap(
                    "SELECT * FROM audit_exam_score WHERE exam_id = :exam_id " +
                            "AND subject_score_id = :subject_score_id " +
                            "AND action = '" + action + "' " +
                            "ORDER BY audited DESC LIMIT 1",
                    new MapSqlParameterSource()
                            .addValue("exam_id", originalExamId)
                            .addValue("subject_score_id", examClaimScoreValues.get("subject_score_id")));

            assertThat(auditClaimScoreValues.remove("id")).isNotNull();
            assertThat(auditClaimScoreValues.remove("action")).isEqualTo(action);
            assertThat(auditClaimScoreValues.remove("audited")).isNotNull();
            assertThat(auditClaimScoreValues.remove("database_user")).isNotNull();
            assertThat(auditClaimScoreValues.remove("exam_score_id")).isEqualTo(examClaimScoreValues.remove("id"));
            assertThat(examClaimScoreValues).isEqualTo(auditClaimScoreValues);
        });
    }

    @Test
    public void itShouldAuditExamTargetScore() {
        // *** Create exam with no target scores ***
        final Exam originalExam = builder
                .examTargets(null)
                .build();
        final long originalExamId = repository.upsert(originalExam, -1);

        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_target_score", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", " id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_target_score", " exam_id = " + originalExamId)).isEqualTo(0);

        // *** Second upsert add two target scores ***
        final Exam secondExam = builder.examTargets(newArrayList(
                ExamTarget.builder().targetId(1).studentRelativeResidualScore(0.2).standardMetRelativeResidualScore(0.5).build(),
                ExamTarget.builder().targetId(2).studentRelativeResidualScore(-0.1).standardMetRelativeResidualScore(-0.4).build()))
                .build();

        final long secondExamId = repository.upsert(secondExam, -2);

        assertThat(originalExamId).isEqualTo(secondExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_target_score", " exam_id = " + originalExamId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", " id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_target_score", " exam_id = " + originalExamId)).isEqualTo(2);

        // *** Third upsert change one of the existing scores ***
        final Exam thirdExam = builder.examTargets(newArrayList(
                ExamTarget.builder().targetId(1).studentRelativeResidualScore(0.2).standardMetRelativeResidualScore(0.5).build(),
                ExamTarget.builder().targetId(2).studentRelativeResidualScore(-0.2).standardMetRelativeResidualScore(-0.5).build()))
                .build();

        final long thirdExamId = repository.upsert(thirdExam, -3);

        assertThat(originalExamId).isEqualTo(thirdExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_target_score", " exam_id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", " id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_target_score", " exam_id = " + originalExamId)).isEqualTo(2);

        // *** Fourth upsert delete one and add one
        final Exam fourthExam = builder.examTargets(newArrayList(
                ExamTarget.builder().targetId(1).studentRelativeResidualScore(0.2).standardMetRelativeResidualScore(0.5).build(),
                ExamTarget.builder().targetId(3).studentRelativeResidualScore(-0.2).standardMetRelativeResidualScore(-0.5).build()))
                .build();

        final long fourthExamId = repository.upsert(fourthExam, -4);

        assertThat(originalExamId).isEqualTo(fourthExamId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam", " exam_id = " + originalExamId)).isEqualTo(3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_target_score", " exam_id = " + originalExamId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", " id = " + originalExamId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_target_score", " exam_id = " + originalExamId)).isEqualTo(2);
    }

    @Test
    public void itShouldAuditExamTraits() {
        // create exam (without traits)
        final Exam originalExam = builder.build();
        final long originalExamId = repository.upsert(originalExam, -1);

        // which shouldn't produce any audit records
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_target_score", " exam_id = " + originalExamId)).isEqualTo(0);

        // upsert exam after adding an exam trait
        final Exam updatedExam = builder.examClaims(null).examTargets(null).examItems(null)
            .examTraits(newArrayList(ExamTrait.builder().traitId(-21).score(2).build()))
            .build();
        final long updatedExamId = repository.upsert(updatedExam, -2);
        assertThat(updatedExamId).isEqualTo(originalExamId);    // just in case upsert detection breaks

        // and we should have an audit record
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_exam_target_score", " exam_id = " + originalExamId)).isEqualTo(1);
    }
}
