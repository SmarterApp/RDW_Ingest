package org.opentestsystem.rdw.ingest.processor.repository.impl;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.ExamItemSubScore;
import org.opentestsystem.rdw.ingest.processor.model.ExamScore;
import org.opentestsystem.rdw.ingest.processor.model.ExamTarget;
import org.opentestsystem.rdw.ingest.processor.model.ExamTrait;
import org.opentestsystem.rdw.ingest.processor.model.StudentExamAttributes;
import org.opentestsystem.rdw.ingest.processor.repository.ExamRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.jdbc.Sql;

import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTable;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTableWhere;

@SuppressWarnings({"SqlNoDataSourceInspection", "SqlResolve"})
@Import(JdbcExamRepository.class)
@Sql(statements = {
    "INSERT INTO import (id,status,content,contentType,digest,created) VALUES " +
        "(-1,0,1, 'application/xml','1D849A91956B74350FF895F067F115E6',CURRENT_DATE)," +
        "(-2,0,1, 'application/xml','1D849A91956B74350FF895F067F115E7',CURRENT_DATE)," +
        "(-3,0,1, 'application/xml','1D849A91956B74350FF895F067F125E6',CURRENT_DATE)," +
        "(-4,0,1, 'application/xml','1D849A91956B74350FF895F067F135E6',CURRENT_DATE)," +
        "(-5,0,1, 'application/xml','1D849A91956B74350FF895F067F145E7',CURRENT_DATE);",
    "INSERT IGNORE INTO district (id, name, natural_id) VALUES\n" +
        "  (-11, 'Sample District 1', 'District1NaturalId');",
    "INSERT IGNORE INTO school (id, district_id, name, natural_id, import_id, update_import_id) VALUES\n" +
        "  (-12, -11, 'Sample School 1', 'School1NaturalId', -1, -1);",
    "INSERT INTO student (id, ssid, last_or_surname, first_name, middle_name, alias_name, gender_id, first_entry_into_us_school_at, lep_entry_at, lep_exit_at, birthday, import_id, update_import_id) VALUES\n" +
        "  (-11, '6666666666', 'LastName6', 'FirstName6', 'MiddleName6', 'AliasName6', 1, '2015-09-01', null, null, '2006-01-01', -1, -1)," +
        "  (-12, '7777777777', 'LastName7', 'FirstName7', 'MiddleName7', 'AliasName7', 1, '2015-09-01', null, null, '2006-01-01', -1, -1);",
    "INSERT INTO asmt (id, natural_id, grade_id, type_id, subject_id, school_year, name, label, version, import_id, update_import_id) VALUES\n" +
        "  (-1, '(SBAC)SBAC-ICA-FIXED-G5E-COMBINED-2017', 5, 1, 2, 2016, 'SBAC-ICA-FIXED-G5E-COMBINED-2017', 'Grade 5 ELA', '9831', -1, -1);\n",
    "INSERT INTO item (id, claim_id, target_id, natural_id, asmt_id, dok_id, difficulty, max_points, math_practice, allow_calc) VALUES \n" +
        " (-1, 1, 1, 'item1', -1, 1, 0.5, 5, null, null)," +
        " (-2, 1, 1, 'item3', -1, 1, 0.5, 5, null, null)," +
        " (-3, 1, 1, 'item4', -1, 1, 0.5, 5, null, null)," +
        " (-4, 1, 1, 'item4.2', -1, 1, 0.5, 5, null, null)," +
        " (-5, 1, 1, 'item5', -1, 1, 0.5, 5, null, null)," +
        " (-6, 1, 1, 'item6', -1, 1, 0.5, 5, null, null);",
    "INSERT INTO accommodation (id, code) VALUES " +
        " (-99, 'ACC_CODE1')," +
        " (-98, 'ACC_CODE2')," +
        " (-97, 'ACC_CODE3')," +
        " (-96, 'ACC_CODE4')," +
        " (-95, 'ACC_CODE5')," +
        " (-94, 'ACC_CODE6');",
    "INSERT INTO subject_trait (id, subject_id, code, purpose, category, max_score) VALUES \n" +
        "(-21, 2, 'T1', 'ARGU', 'ORG', 3);"
})
public class ExamRepositoryIT extends TenantAwareIT {

    @Autowired
    private ExamRepository repository;

    @Autowired
    private JdbcTemplate jdbcTemplate;
    private NamedParameterJdbcTemplate namedParameterTemplate;

    //since we do not have a referential integrity enforced on the warehouse we can use any data.
    private final String examClaim1ScoreWhereSql = "subject_score_id = - 1 and cast(scale_score as decimal(5,2)) = 1 and cast(scale_score_std_err as decimal(5,2))= 2 and performance_level = 1";
    private final String examClaim2ScoreWhereSql = "subject_score_id = - 2 and cast(scale_score as decimal(5,2)) = 2 and cast(scale_score_std_err as decimal(5,2))= 3 and performance_level = 1";
    private final String examClaim3ScoreWhereSql = "subject_score_id = - 3 and cast(scale_score as decimal(5,2)) = 3 and cast(scale_score_std_err as decimal(5,2))= 4 and performance_level = 1";

    private final String examWhereSql = "type_id = 1 and school_year = 2015 and performance_level = 5 and " +
            "administration_condition_id = 1 and " +
            "asmt_version = '345' and " +
            "asmt_id = -1 and " +
            "completed_at = convert_tz(timestamp('2007-01-02T14:30:00Z'), '+00:00', @@session.time_zone) and " +
            "completeness_id = 1 and " +
            "opportunity = 7 and " +
            "cast(scale_score as decimal(5,2)) =  77.7 and " +
            "cast(scale_score_std_err as decimal(5,2)) =  6.6 and " +
            "session_id =  'session' and " +
            "student_id in (-11, -12) and " +
            "economic_disadvantage = 1 and " +
            "eng_prof_lvl = 'engl prof' and " +
            "grade_id = 1 and " +
            "iep = 1 and " +
            "language_id = 0 and " +
            "military_connected_id = 1 and " +
            "lep = 0 and " +
            "migrant_status = 0 and " +
            "prim_disability_type = 'PD' and " +
            "school_id = -12 and " +
            "section504 = 1 and " +
            "t3_program_type = 't3'";

    private Exam.Builder builder;

    @Before
    public void setUp() {
        namedParameterTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);

        builder = Exam.builder()
                .typeId(AssessmentType.ICA.id())
                .performanceLevel(5)
                .administrationConditionId(1)
                .asmtVersion("345")
                .assessmentId(-1)
                .completedAt(Instant.parse("2007-01-02T14:30:00Z"))
                .schoolYear(2015)
                .completenessId(1)
                .opportunity(7L)
                .oppId("22840351")
                .scaleScore(77.7)
                .scaleScoreStdErr(6.6)
                .sessionId("session")
                .studentExamAttributes(StudentExamAttributes.builder()
                        .studentId(-11)
                        .economicDisadvantage(true)
                        .engProfLvl("engl prof")
                        .gradeId(1)
                        .ideaIndicator(true)
                        .languageId(0)
                        .militaryConnectedId(1)
                        .lep(false)
                        .elasId(1)
                        .migrantStatus(false)
                        .primDisabilityType("PD")
                        .responsibleSchoolId(-12)
                        .section504(true)
                        .t3ProgramType("t3")
                        .examineeId(-1111L)
                        .build());

        final List<ExamScore> claims = newArrayList();
        for (int claim = 1; claim < 4; claim++) {
            claims.add(ExamScore.builder()
                    .subjectScoreId(-1 * claim)
                    .performanceLevel(1)
                    .scaleScore((double) claim)
                    .scaleScoreStdErr((double) claim + 1)
                    .build());
        }
        builder.examClaims(claims);

        builder.examTargets(newArrayList(
                ExamTarget.builder().targetId(1).studentRelativeResidualScore(0.2).standardMetRelativeResidualScore(0.5).build()));

        final List<ExamItem> items = newArrayList();
        final List<ExamItemSubScore> subScores = newArrayList();
        subScores.add(new ExamItemSubScore(1, 1.1, "status1"));
        subScores.add(new ExamItemSubScore(2, 2.2, "status2"));
        subScores.add(new ExamItemSubScore(3, 3.3, "status3"));
        items.add(ExamItem.builder()
                .itemId(-1)
                .score(3.7)
                .scoreStatus("status A")
                .response("test response A")
                .position(1)
                .submitted(1)
                .numberOfVisits(2L)
                .pageNumber(1L)
                .pageTime(3)
                .pageVisits(4L)
                .responseContentType("type")
                .responseDuration(1.1)
                .responseTypeId(1)
                .subScoreList(subScores)
                .administeredAt(Instant.parse("2007-05-02T14:30:00Z"))
                .submittedAt(Instant.parse("2007-05-03T14:30:00Z"))
                .build());
        items.add(ExamItem.builder()
                .itemId(-2)
                .score(7.8)
                .scoreStatus("status B")
                .response("test response B")
                .position(2)
                .administeredAt(Instant.parse("2007-05-02T15:30:00Z"))
                .submittedAt(Instant.parse("2007-05-03T15:30:00Z"))
                .build());

        builder.examItems(items);

        final List<Integer> accommodations = newArrayList();
        accommodations.add(-99);
        builder.accommodationIds(accommodations);
    }

    @Test
    public void itShouldCreateExamsWithNoClaimsTargetsItems() {
        final int beforeExamCount = countRowsInTableWhere(jdbcTemplate, "exam", examWhereSql);
        final int beforeExamClaimScoreCount = countRowsInTable(jdbcTemplate, "exam_score");
        final int beforeExamTargetScoreCount = countRowsInTable(jdbcTemplate, "exam_target_score");
        final int beforeExamItemCount = countRowsInTable(jdbcTemplate, "exam_item");
        final int beforeExamAccommodationCount = countRowsInTable(jdbcTemplate, "exam_available_accommodation");

        final Exam exam = builder.examClaims(null).examTargets(null).examItems(null).build();
        exam.getStudentExamAttributes().setStudentId(-11);

        repository.upsert(exam, -1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", examWhereSql)).isEqualTo(beforeExamCount + 1);

        assertThat(countRowsInTable(jdbcTemplate, "exam_item")).isEqualTo(beforeExamItemCount);
        assertThat(countRowsInTable(jdbcTemplate, "exam_score")).isEqualTo(beforeExamClaimScoreCount);
        assertThat(countRowsInTable(jdbcTemplate, "exam_target_score")).isEqualTo(beforeExamTargetScoreCount);
        assertThat(countRowsInTable(jdbcTemplate, "exam_available_accommodation")).isEqualTo(beforeExamAccommodationCount + 1);
    }

    @Test
    public void itShouldCreateExamsWithClaimsAndTargets() {
        final int beforeExamCount = countRowsInTableWhere(jdbcTemplate, "exam", examWhereSql);
        final int beforeExamItemCount = countRowsInTable(jdbcTemplate, "exam_item");
        final int beforeExamClaimScoreCount = countRowsInTable(jdbcTemplate, "exam_score");
        final int beforeExamTargetScoreCount = countRowsInTable(jdbcTemplate, "exam_target_score");
        final int beforeExamAccommodationCount = countRowsInTable(jdbcTemplate, "exam_available_accommodation");

        final Exam exam = builder.examItems(null).build();
        exam.getStudentExamAttributes().setStudentId(-11);

        final long examId = repository.upsert(exam, -1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", examWhereSql)).isEqualTo(beforeExamCount + 1);

        assertThat(countRowsInTable(jdbcTemplate, "exam_item")).isEqualTo(beforeExamItemCount);

        assertThat(countRowsInTable(jdbcTemplate, "exam_score")).isEqualTo(beforeExamClaimScoreCount + 3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", examClaim1ScoreWhereSql + " and exam_id = " + examId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", examClaim2ScoreWhereSql + " and exam_id = " + examId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", examClaim3ScoreWhereSql + " and exam_id = " + examId)).isEqualTo(1);
        assertThat(countRowsInTable(jdbcTemplate, "exam_target_score")).isEqualTo(beforeExamTargetScoreCount + 1);
        assertThat(countRowsInTable(jdbcTemplate, "exam_available_accommodation")).isEqualTo(beforeExamAccommodationCount + 1);
    }

    @Test
    public void itShouldCreateExamsWithTraits() {
        final int beforeExamTraitScoreCount = countRowsInTable(jdbcTemplate, "exam_trait_score");

        final Exam exam = builder.examClaims(null).examTargets(null).examItems(null)
            .examTraits(newArrayList(ExamTrait.builder().traitId(-21).score(2).build()))
            .build();

        repository.upsert(exam, -1);

        assertThat(countRowsInTable(jdbcTemplate, "exam_trait_score")).isEqualTo(beforeExamTraitScoreCount + 1);
    }

    @Test
    public void itShouldCreateExams() {
        final int beforeExamCount = countRowsInTableWhere(jdbcTemplate, "exam", examWhereSql);
        final int beforeExamItemCount = countRowsInTable(jdbcTemplate, "exam_item");
        final int beforeExamClaimScoreCount = countRowsInTable(jdbcTemplate, "exam_score");
        final int beforeExamTargetScoreCount = countRowsInTable(jdbcTemplate, "exam_target_score");
        final int beforeExamAccommodationCount = countRowsInTable(jdbcTemplate, "exam_available_accommodation");

        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);

        final long examId = repository.upsert(exam, -1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", examWhereSql)).isEqualTo(beforeExamCount + 1);

        assertThat(countRowsInTable(jdbcTemplate, "exam_item")).isEqualTo(beforeExamItemCount + 2);

        assertThat(countRowsInTable(jdbcTemplate, "exam_score")).isEqualTo(beforeExamClaimScoreCount + 3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", examClaim1ScoreWhereSql + " and exam_id = " + examId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", examClaim2ScoreWhereSql + " and exam_id = " + examId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_score", examClaim3ScoreWhereSql + " and exam_id = " + examId)).isEqualTo(1);

        assertThat(countRowsInTable(jdbcTemplate, "exam_target_score")).isEqualTo(beforeExamTargetScoreCount + 1);

        final String examItem1WhereSql = "item_id = -1 and cast(score as decimal(5,2)) = 3.7 and score_status = 'status A' and response = 'test response A'" +
                " and cast(trait_evidence_elaboration_score as decimal(5,2)) = 1.1 and trait_evidence_elaboration_score_status ='status1'" +
                " and cast(trait_organization_purpose_score as decimal(5,2)) = 2.2 and trait_organization_purpose_score_status = 'status2'" +
                " and cast(trait_conventions_score as decimal(5,2)) = 3.3 and trait_conventions_score_status = 'status3'";
        final String examItem2WhereSql = "item_id = -2 and cast(score as decimal(5,2)) = 7.8 and score_status = 'status B' and response = 'test response B'" +
                " and trait_evidence_elaboration_score is null and trait_evidence_elaboration_score_status is null" +
                " and trait_organization_purpose_score is null and trait_organization_purpose_score_status is null" +
                " and trait_conventions_score is null and trait_conventions_score_status is null";

        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_item", examItem1WhereSql + " and exam_id = " + examId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "exam_item", examItem2WhereSql + " and exam_id = " + examId)).isEqualTo(1);

        // verify that another request to create an exam with a different oppId will insert a new record
        final Exam newExam = builder.oppId("54321").build();
        newExam.getStudentExamAttributes().setStudentId(-11);
        assertThat(repository.upsert(newExam, -1)).isNotEqualTo(examId);

        assertThat(countRowsInTableWhere(jdbcTemplate, "exam", examWhereSql)).isEqualTo(beforeExamCount + 2);
        assertThat(countRowsInTable(jdbcTemplate, "exam_score")).isEqualTo(beforeExamClaimScoreCount + 6);
        assertThat(countRowsInTable(jdbcTemplate, "exam_item")).isEqualTo(beforeExamItemCount + 4);
        assertThat(countRowsInTable(jdbcTemplate, "exam_available_accommodation")).isEqualTo(beforeExamAccommodationCount + 2);
    }

    @Test
    public void itShouldNotModifyAnUnchangedExamWithNullValues() {
        final List<ExamScore> claims = newArrayList();
        for (int claim = 1; claim < 4; claim++) {
            claims.add(ExamScore.builder()
                    .subjectScoreId(-1 * claim)
                    .build());
        }
        final List<ExamItem> items = newArrayList();
        final List<ExamItemSubScore> subScores = newArrayList();
        subScores.add(new ExamItemSubScore(1, null, "status1"));
        subScores.add(new ExamItemSubScore(2, null, "status2"));
        subScores.add(new ExamItemSubScore(3, null, "status3"));
        items.add(ExamItem.builder().itemId(-1).score(1.1).scoreStatus("status A").response("test response A").position(1).subScoreList(subScores).build());
        items.add(ExamItem.builder().itemId(-2).score(1.1).scoreStatus("status B").response("test response B").position(2).build());

        final Exam exam = builder.examClaims(claims).examItems(items).build();
        exam.getStudentExamAttributes().setStudentId(-11);

        final long originalExamId = repository.upsert(exam, -1);
        final long updatedExamId = repository.upsert(exam, -2);
        assertThat(originalExamId).isEqualTo(updatedExamId);

        final Map<String, Object> values = namedParameterTemplate.queryForMap(
                "SELECT update_import_id FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", updatedExamId));
        assertThat(values.get("update_import_id")).isEqualTo(-1L);
    }

    @Test
    public void itShouldNotModifyAnUnchangedExam() {
        final Exam exam = builder
                .statusDate(Instant.parse("2011-01-01T14:30:00Z"))
                .deliverMode("mode")
                .handScoreProject(-99L)
                .contract("contract")
                .testReason("testReason")
                .assessmentAdminStartedAt(LocalDate.of(2011, 1, 7))
                .startedAt(Instant.parse("2011-01-02T14:30:00Z"))
                .forceSubmittedAt((Instant.parse("2011-01-03T14:30:00Z")))
                .status("status")
                .itemCount(9L)
                .fieldTestCount(7L)
                .pauseCount(1L)
                .gracePeriodRestarts(2L)
                .abnormalStarts(3L)
                .testWindowId("testWindowId")
                .testAdministratorId("testAdministratorId")
                .responsibleOrganizationName("responsibleOrganizationName")
                .testAdministratorName("testAdministratorName")
                .sessionPlatformUserAgent("sessionPlatformUserAgent")
                .testDeliveryServer("testDeliveryServer")
                .testDeliveryDb("testDeliveryDb")
                .windowOpportunityCount("999")
                .thetaScore(0.99)
                .thetaScoreStdErr(0.009)
                .build();
        exam.getStudentExamAttributes().setStudentId(-11);

        final long originalExamId = repository.upsert(exam, -1);
        final long updatedExamId = repository.upsert(exam, -2);
        assertThat(originalExamId).isEqualTo(updatedExamId);

        final Map<String, Object> values = namedParameterTemplate.queryForMap(
                "SELECT update_import_id FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", updatedExamId));
        assertThat(values.get("update_import_id")).isEqualTo(-1L);
    }

    @Test
    public void itShouldModifyAChangedExamWithNullValues() {
        final Exam original = builder
                .scaleScore(null)
                .scaleScoreStdErr(null)
                .performanceLevel(null)
                .completenessId(1)
                .build();
        final long originalExamId = repository.upsert(original, -1);

        final Exam updated = builder
                .completenessId(2)
                .build();
        final long updatedExamId = repository.upsert(updated, -2);
        assertThat(originalExamId).isEqualTo(updatedExamId);

        final Map<String, Object> values = namedParameterTemplate.queryForMap(
                "SELECT update_import_id, completeness_id, deleted FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", updatedExamId));
        assertThat(values.get("update_import_id")).isEqualTo(-2L);
        assertThat(values.get("completeness_id")).isEqualTo(updated.getCompletenessId());
    }

    @Test
    public void itShouldModifyAChangedExam() {
        final Exam original = builder
                .statusDate(Instant.parse("2011-01-01T14:30:00Z"))
                .deliverMode("mode")
                .handScoreProject(-99L)
                .contract("contract")
                .testReason("testReason")
                .assessmentAdminStartedAt(LocalDate.of(2011, 1, 7))
                .startedAt(Instant.parse("2011-01-02T14:30:00Z"))
                .forceSubmittedAt((Instant.parse("2011-01-03T14:30:00Z")))
                .status("status")
                .itemCount(9L)
                .fieldTestCount(7L)
                .pauseCount(1L)
                .gracePeriodRestarts(2L)
                .abnormalStarts(3L)
                .testWindowId("testWindowId")
                .testAdministratorId("testAdministratorId")
                .responsibleOrganizationName("responsibleOrganizationName")
                .testAdministratorName("testAdministratorName")
                .sessionPlatformUserAgent("sessionPlatformUserAgent")
                .testDeliveryServer("testDeliveryServer")
                .testDeliveryDb("testDeliveryDb")
                .windowOpportunityCount("999")
                .thetaScore(0.99)
                .thetaScoreStdErr(0.009)
                .build();
        final long originalExamId = repository.upsert(original, -1);

        final Exam updated = builder
                .completenessId(2)
                .build();
        final long updatedExamId = repository.upsert(updated, -2);
        assertThat(originalExamId).isEqualTo(updatedExamId);

        final Map<String, Object> values = namedParameterTemplate.queryForMap(
                "SELECT update_import_id, completeness_id, deleted FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", updatedExamId));
        assertThat(values.get("update_import_id")).isEqualTo(-2L);
        assertThat(values.get("completeness_id")).isEqualTo(updated.getCompletenessId());
    }

    @Test
    public void itShouldModifyAChangedExamStudent() {
        final Exam original = builder
                .build();
        original.getStudentExamAttributes().setStudentId(-11);

        final long examId = repository.upsert(original, -1);
        final Map<String, Object> originalValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", examId));

        final Exam updated = builder
                .studentExamAttributes(StudentExamAttributes.builder()
                        .studentId(-11)
                        .economicDisadvantage(true)
                        .engProfLvl("engl prof 2")
                        .gradeId(1)
                        .ideaIndicator(true)
                        .languageId(0)
                        .militaryConnectedId(1)
                        .lep(false)
                        .elasId(2)
                        .elasStartDate(LocalDate.of(2014, 8, 15))
                        .migrantStatus(false)
                        .primDisabilityType("PD")
                        .responsibleSchoolId(-12)
                        .section504(true)
                        .t3ProgramType("t3")
                        .build())
                .build();
        repository.upsert(updated, -2);
        final Map<String, Object> updatedValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", examId));

        assertThat(originalValues.get("id")).isEqualTo(updatedValues.get("id"));
        assertThat(updatedValues.get("eng_prof_lvl")).isEqualTo(updated.getStudentExamAttributes().getEngProfLvl());
        assertThat(updatedValues.get("elas_id")).isEqualTo(updated.getStudentExamAttributes().getElasId());

        // clear some things and make sure null updates work
        final Exam again = builder
                .studentExamAttributes(StudentExamAttributes.builder()
                        .studentId(-11)
                        .economicDisadvantage(false)
                        .engProfLvl(null)
                        .gradeId(1)
                        .ideaIndicator(false)
                        .languageId(null)
                        .militaryConnectedId(null)
                        .lep(false)
                        .elasId(null)
                        .elasStartDate(null)
                        .migrantStatus(null)
                        .primDisabilityType(null)
                        .responsibleSchoolId(-12)
                        .section504(null)
                        .t3ProgramType(null)
                        .build())
                .build();
        repository.upsert(again, -3);
        final Map<String, Object> againValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(againValues.get("id")).isEqualTo(originalValues.get("id"));
        assertThat(againValues.get("economic_disadvantage")).isEqualTo(0);
        assertThat(againValues.get("eng_prof_lvl")).isNull();
        assertThat(againValues.get("language_id")).isNull();
        assertThat(againValues.get("military_connected_id")).isNull();
        assertThat(againValues.get("lep")).isEqualTo(0);
        assertThat(againValues.get("migrant_status")).isNull();
        assertThat(againValues.get("t3_program_type")).isNull();
        assertThat(againValues.get("elas_id")).isNull();
        assertThat(againValues.get("elas_start_at")).isNull();
    }

    @Test
    public void itShouldHandleNullableAttributesDuringUpdate() {
        // migrant status (and section504) may be null; there was a bug where updating with the
        // same null value would result in an update being executed because the null in the
        // existing record was being mapped to false, and false != null ...

        final Exam original = builder
                .studentExamAttributes(StudentExamAttributes.builder()
                        .studentId(-11)
                        .economicDisadvantage(true)
                        .engProfLvl("engl prof")
                        .gradeId(1)
                        .ideaIndicator(true)
                        .languageId(0)
                        .lep(false)
                        .migrantStatus(null)
                        .primDisabilityType("PD")
                        .responsibleSchoolId(-12)
                        .section504(null)
                        .t3ProgramType("t3")
                        .examineeId(-1111L)
                        .build())
                .build();
        original.getStudentExamAttributes().setStudentId(-11);

        final long examId = repository.upsert(original, -1);
        final Map<String, Object> originalValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", examId));

        final Exam updated = builder.build();
        assertThat(repository.upsert(updated, -2)).isEqualTo(examId);
        final Map<String, Object> updatedValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", examId));

        assertThat(updatedValues.get("updated")).isEqualTo(originalValues.get("updated"));
    }

    @Test
    public void itShouldAddANewExamClaim() {
        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);
        final long examId = repository.upsert(exam, -1);

        final List<ExamScore> claims = newArrayList(exam.getExamScores());
        claims.add(ExamScore.builder()
                .subjectScoreId(-7)
                .performanceLevel(1)
                .scaleScore(-7d)
                .scaleScoreStdErr(-1d)
                .build());
        final Exam updated = builder
                .examClaims(claims)
                .build();
        repository.upsert(updated, -2);

        final List<Map<String, Object>> updatedValues = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_score WHERE exam_id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues).hasSameSizeAs(claims);

        final Map<String, Object> newClaim = updatedValues.stream()
                .filter(values -> (Integer) values.get("subject_score_id") == -7)
                .findFirst()
                .orElseThrow(() -> new RuntimeException("New claim not found"));
        assertThat(newClaim.get("performance_level")).isEqualTo(1);
        assertThat(newClaim.get("scale_score")).isEqualTo(-7f);
        assertThat(newClaim.get("scale_score_std_err")).isEqualTo(-1f);
    }

    @Test
    public void itShouldUpdateAnExistingExamClaim() {
        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);
        final long examId = repository.upsert(exam, -1);

        final List<ExamScore> claims = newArrayList(exam.getExamScores());
        final ExamScore originalClaim = claims.remove(0);
        final ExamScore updatedClaim = ExamScore.builder()
                .subjectScoreId(originalClaim.getSubjectScoreId())
                .performanceLevel(originalClaim.getPerformanceLevel() + 1)
                .scaleScore(originalClaim.getScaleScore() - 1)
                .scaleScoreStdErr(originalClaim.getScaleScoreStdErr() - 1)
                .build();
        claims.add(updatedClaim);
        final Exam updated = builder
                .examClaims(claims)
                .build();
        repository.upsert(updated, -2);

        final List<Map<String, Object>> updatedValues = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_score WHERE exam_id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues).hasSameSizeAs(claims);

        final Map<String, Object> newClaim = updatedValues.stream()
                .filter(values -> (Integer) values.get("subject_score_id") == updatedClaim.getSubjectScoreId())
                .findFirst()
                .orElseThrow(() -> new RuntimeException("New claim not found"));
        assertThat(newClaim.get("performance_level")).isEqualTo(updatedClaim.getPerformanceLevel());
        assertThat(newClaim.get("scale_score")).isEqualTo(updatedClaim.getScaleScore().floatValue());
        assertThat(newClaim.get("scale_score_std_err")).isEqualTo(updatedClaim.getScaleScoreStdErr().floatValue());
    }

    @Test
    public void itShouldRemoveStaleExamClaims() {
        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);
        final long examId = repository.upsert(exam, -1);

        final List<ExamScore> claims = newArrayList(exam.getExamScores());
        claims.remove(0);
        final Exam updated = builder
                .examClaims(claims)
                .build();
        repository.upsert(updated, -2);

        final List<Map<String, Object>> updatedValues = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_score WHERE exam_id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues).hasSameSizeAs(claims);
    }

    @Test
    public void itShouldAddANewExamItem() {
        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);
        final long examId = repository.upsert(exam, -1);

        final List<ExamItem> examItems = newArrayList(exam.getExamItems());
        final ExamItem newItem = ExamItem.builder()
                .response("response")
                .position(3)
                .scoreStatus("status")
                .score(1.23)
                .itemId(-3)
                .build();
        examItems.add(newItem);
        final Exam updated = builder
                .examItems(examItems)
                .build();
        repository.upsert(updated, -2);

        final List<Map<String, Object>> updatedValues = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_item WHERE exam_id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues).hasSameSizeAs(examItems);

        final Map<String, Object> newItemValues = updatedValues.stream()
                .filter(values -> (Integer) values.get("item_id") == -3)
                .findFirst()
                .orElseThrow(() -> new RuntimeException("New item not found"));
        assertThat(newItemValues.get("score")).isEqualTo(newItem.getScore().floatValue());
        assertThat(newItemValues.get("score_status")).isEqualTo(newItem.getScoreStatus());
    }

    @Test
    public void itShouldUpdateAnExistingExamItem() {
        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);
        final long examId = repository.upsert(exam, -1);

        final List<ExamItem> items = exam.getExamItems();
        final ExamItem originalItem = items.stream()
                .filter(item -> item.getConventionsSubScore() != null)
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Unable to find exam item with subscores"));
        items.remove(originalItem);

        final ExamItemSubScore originalSubScore = originalItem.getConventionsSubScore();
        final ExamItemSubScore updatedSubScore = new ExamItemSubScore(
                originalSubScore.getTraitId(),
                originalSubScore.getScore() + 1,
                originalSubScore.getScoreStatus());

        final ExamItem updatedItem = ExamItem.builder()
                .itemId(originalItem.getItemId())
                .score(originalItem.getScore())
                .scoreStatus(originalItem.getScoreStatus())
                .position(originalItem.getPosition())
                .response(originalItem.getResponse())
                .subScoreList(ImmutableList.of(
                        updatedSubScore,
                        originalItem.getEvidenceAndElaborationSubScore(),
                        originalItem.getOrganizationAndPurposeSubScore()))
                .build();
        items.add(updatedItem);
        final Exam updated = builder
                .examItems(items)
                .build();
        repository.upsert(updated, -2);

        final List<Map<String, Object>> updatedValues = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_item WHERE exam_id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues).hasSameSizeAs(items);

        final Map<String, Object> newClaim = updatedValues.stream()
                .filter(values -> values.get("item_id").equals(updatedItem.getItemId()))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Updated item not found"));
        assertThat(newClaim.get("trait_conventions_score")).isEqualTo(updatedSubScore.getScore().floatValue());
    }

    @Test
    public void itShouldRemoveStaleExamItems() {
        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);
        final long examId = repository.upsert(exam, -1);

        final List<ExamItem> items = newArrayList(exam.getExamItems());
        items.remove(0);
        final Exam updated = builder
                .examItems(items)
                .build();
        repository.upsert(updated, -2);

        final List<Map<String, Object>> updatedValues = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_item WHERE exam_id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues).hasSameSizeAs(items);
    }

    @Test
    public void itShouldAddANewAccommodationId() {
        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);
        final long examId = repository.upsert(exam, -1);

        final List<Integer> accommodations = newArrayList(exam.getAccommodationIds());
        accommodations.add(-98);
        final Exam updated = builder
                .accommodationIds(accommodations)
                .build();
        repository.upsert(updated, -2);

        final List<Map<String, Object>> updatedValues = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_available_accommodation WHERE exam_id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues).hasSameSizeAs(accommodations);

        final Map<String, Object> newItemValues = updatedValues.stream()
                .filter(values -> (Integer) values.get("accommodation_id") == -98)
                .findFirst()
                .orElseThrow(() -> new RuntimeException("New accommodation not found"));
        assertThat(newItemValues).isNotNull();
    }

    @Test
    public void itShouldRemoveStaleAccommodationIds() {
        final Exam exam = builder.build();
        exam.getStudentExamAttributes().setStudentId(-11);
        final long examId = repository.upsert(exam, -1);

        final Exam updated = builder
                .accommodationIds(newArrayList())
                .build();
        repository.upsert(updated, -2);

        final List<Map<String, Object>> updatedValues = namedParameterTemplate.queryForList(
                "SELECT * FROM exam_available_accommodation WHERE exam_id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues).isEmpty();
    }

    @Test(expected = IllegalArgumentException.class)
    public void itShouldFailToDeletedExam() {
        final Exam exam = builder
                .deleted(false)
                .build();
        repository.delete(exam, -1);
    }

    @Test
    public void itShouldNotUpdateAnExamWithALaterStatusDate() {
        final Exam exam = builder
                .statusDate(Instant.now())
                .build();
        final long examId = repository.upsert(exam, -1);

        final Exam updated = builder
                .schoolYear(exam.getSchoolYear() - 1)
                .statusDate(exam.getStatusDate().minus(1, ChronoUnit.SECONDS))
                .build();
        repository.upsert(updated, -2);

        final Map<String, Object> updatedValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM exam WHERE id = :id",
                new MapSqlParameterSource().addValue("id", examId));
        assertThat(updatedValues.get("school_year")).isEqualTo(exam.getSchoolYear());
    }
}
