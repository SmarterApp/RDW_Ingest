package org.opentestsystem.rdw.ingest.processor;

import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.opentestsystem.rdw.common.model.trt.Opportunity;
import org.opentestsystem.rdw.common.model.trt.TDSReport;
import org.opentestsystem.rdw.common.model.trt.XmlUtils;
import org.opentestsystem.rdw.script.PipelineScript;
import org.opentestsystem.rdw.script.ScriptCompiler;
import org.opentestsystem.rdw.script.ScriptCompilers;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

public class ExternalVendorScriptTest {
    private PipelineScript script;

    @Before
    public void setup() throws Exception {
        final ScriptCompiler compiler = ScriptCompilers.toScriptCompiler(
                IOUtils.toString(this.getClass().getResourceAsStream("/scripts/DSLScriptBase.groovy"), UTF_8)
        );

        final String scriptCode = IOUtils.toString(
                this.getClass().getResourceAsStream("/scripts/ExternalVendor.groovy"), UTF_8);
        script = compiler.compile(scriptCode, "ExternalVendor.groovy").newInstance();
    }

    @Test
    public void testScript() throws Exception {
        final byte [] trt = IOUtils.toByteArray(
                this.getClass().getResourceAsStream("/TDSReport-external-vendor.xml"));

        final TDSReport before = XmlUtils.tdsReportFromXml(new ByteArrayInputStream(trt));

        final Object output = script.bindInput(trt).execute();
        final TDSReport after = XmlUtils.tdsReportFromXml(new ByteArrayInputStream((byte[])output));

        //
        // Test rule that string leading "10" from bank keys.
        //
        assertThat(before.getTest().getBankKey()).isEqualTo(10200L);
        assertThat(after.getTest().getBankKey()).isEqualTo(200L);

        // Find all "bad" bank keys among the items in the before data
        final List<Long> keyList = before.getOpportunity().getItem()
                .stream()
                .filter(item -> item.getBankKey() == 10200L)
                .map(Opportunity.Item::getKey)
                .collect(Collectors.toList());
        assertThat(keyList.size()).isNotZero();

        // Find matching items in after data and check that the bank keys have be fixed
        final List<Opportunity.Item> afterItemList = after.getOpportunity().getItem()
                .stream()
                .filter(item -> keyList.contains(item.getKey()))
                .collect(Collectors.toList());

        assertThat(afterItemList.size()).isEqualTo(keyList.size());

        for (Opportunity.Item item : afterItemList) {
            assertThat(item.getBankKey()).isEqualTo(200L);
        }

        //
        // Test rule that school id is left-padded with “0"s to make them 14 characters long.
        //
        final String beforeSchoolId = before.getExaminee().getBestRelationship("SchoolId").getValue();
        final String afterSchoolId = after.getExaminee().getBestRelationship("SchoolId").getValue();

        assertThat(beforeSchoolId.length()).isLessThan(14);
        assertThat(afterSchoolId.length()).isEqualTo(14);
        assertThat(afterSchoolId).endsWith(beforeSchoolId);
        assertThat(afterSchoolId).startsWith("0");

        //
        // Test rule that score measureLabel changed from “BenchmarkScore” to “StudentRelativeResidualScore”
        //
        final List<Opportunity.Score> beforeScores = before.getOpportunity().getScore();

        // Scores don't have an obvious unique identifier to match on, so just capture the indexes of the bad entries.
        final List<Integer> badLabelIndexes = IntStream.range(0, beforeScores.size())
                .boxed()
                .collect(Collectors.toMap(beforeScores::get, i -> i))
                .entrySet()
                .stream()
                .filter(entry -> entry.getKey().getMeasureLabel().equals("BenchmarkScore"))
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());

        assertThat(badLabelIndexes.size()).isNotZero();

        for (final Integer index : badLabelIndexes) {
            final Opportunity.Score afterScore = after.getOpportunity().getScore().get(index);
            assertThat(afterScore.getMeasureLabel()).isEqualTo("StudentRelativeResidualScore");
        }
    }
}
