package org.opentestsystem.rdw.ingest.processor.service.impl;


import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.trt.Opportunity;
import org.opentestsystem.rdw.common.model.trt.Opportunity.Item;
import org.opentestsystem.rdw.common.model.trt.ScoreInfoType;
import org.opentestsystem.rdw.common.model.trt.ScoreInfoType.SubScoreList;
import org.opentestsystem.rdw.ingest.common.config.SbacScoreConfiguration;
import org.opentestsystem.rdw.ingest.common.config.SbacScoreConfiguration.Score;
import org.opentestsystem.rdw.utils.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.ExamItem;
import org.opentestsystem.rdw.ingest.processor.model.ItemTrait;
import org.opentestsystem.rdw.ingest.processor.repository.ItemTraitRepository;
import org.opentestsystem.rdw.ingest.processor.repository.ResponseTypeRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamItemProcessor;

import java.time.Instant;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;
import static java.util.stream.Collectors.toList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class DefaultExamItemProcessorTest {

    private ExamItemProcessor processor;
    private Assessment assessment;
    private DataElementErrorCollector elementErrorCollector;
    private Opportunity.Item item1;
    private Opportunity.Item item2;
    private ScoreInfoType subScore3;
    private List<Opportunity.Item> items;
    private ResponseTypeRepository responseTypeRepository;

    @Before
    public void setUp() {
        final SbacScoreConfiguration.Score itemScore = new Score();
        itemScore.setMin(-1.0);
        itemScore.setMax(10.0);

        final SbacScoreConfiguration scoreConfiguration = new SbacScoreConfiguration();
        scoreConfiguration.setItemScore(itemScore);

        final List<ItemTrait> traits = newArrayList();
        traits.add(new ItemTrait(1, "dim_1"));
        traits.add(new ItemTrait(2, "dim_2"));
        traits.add(new ItemTrait(3, "dim_3"));
        final ItemTraitRepository itemTraitRepository = mock(ItemTraitRepository.class);
        when(itemTraitRepository.findAll()).thenReturn(traits);

        responseTypeRepository = mock(ResponseTypeRepository.class);
        when(responseTypeRepository.findIdByCode(any(String.class))).thenAnswer(invocation -> {
            final String value = invocation.getArgument(0);
            if ("value".equals(value)) return 1;
            if ("reference".equals(value)) return 2;
            return null;
        });

        processor = new DefaultExamItemProcessor(scoreConfiguration, itemTraitRepository, responseTypeRepository);
        final Map<String, Integer> asmtItems = newHashMap();
        asmtItems.put("77-1", 1);
        asmtItems.put("77-2", 2);
        asmtItems.put("77-3", 3);
        asmtItems.put("77-4", 4);
        assessment = Assessment.builder().items(asmtItems).build();

        elementErrorCollector = new DataElementErrorCollector();
        item1 = new Item();
        item1.setBankKey(77);
        item1.setKey(1);
        item1.setResponse(null);
        item1.setScore("0.89");
        item1.setScoreStatus("scoreStatus1");
        item1.setPosition(11);
        item1.setScoreInfo(null);

        final ScoreInfoType scoreInfoType2 = new ScoreInfoType();
        scoreInfoType2.setSubScoreList(null);
        item2 = new Item();
        item2.setBankKey(77);
        item2.setKey(2);
        item2.setResponse(new Item.Response());
        item2.setScore("2.89");
        item2.setScoreStatus("scoreStatus2");
        item2.setPosition(21);
        item2.setScoreInfo(scoreInfoType2);
        item2.getResponse().setDate(Instant.parse("2007-05-02T14:30:00Z"));
        item2.getResponse().setType("reference");
        item2.setAdminDate(Instant.parse("2007-03-02T14:30:00Z"));
        item2.setIsSelected((short) 1);
        item2.setNumberVisits(3);
        item2.setPageVisits(4);
        item2.setPageTime(5);
        item2.setPageNumber(6);
        item2.setResponseDuration(6.6);

        final ScoreInfoType scoreInfoType3 = new ScoreInfoType();
        subScore3 = new ScoreInfoType();
        subScore3.setScoreDimension("dim_2");
        subScore3.setScorePoint("2.0");
        subScore3.setScoreStatus("dim2ScoreStatus");

        final SubScoreList subScoreList = mock(SubScoreList.class);
        when(subScoreList.getScoreInfo()).thenReturn(ImmutableList.of(subScore3));
        scoreInfoType3.setSubScoreList(subScoreList);

        final Item.Response response3 = new Item.Response();
        response3.setContent("response3");
        final Item item3 = new Item();
        item3.setBankKey(77);
        item3.setKey(3);
        item3.setResponse(response3);
        item3.setScore("3.89");
        item3.setScoreStatus("scoreStatus3");
        item3.setPosition(31);
        item3.setScoreInfo(scoreInfoType3);
        item3.getResponse().setType("value");

        items = newArrayList(item1, item2, item3);
    }

    @Test
    public void itShouldProcessEmptyItemsList() {
        assertThat(processor.parseExamItems(newArrayList(), assessment, elementErrorCollector)).isEmpty();
        assertThat(elementErrorCollector.isEmpty()).isTrue();
    }

    @Test
    public void itShouldProcessItems() {
        final List<ExamItem> examItems = processor.parseExamItems(items, assessment, elementErrorCollector);

        assertThat(examItems.stream().map(ExamItem::getItemId).collect(toList())).containsExactlyInAnyOrder(1, 2, 3);
        assertThat(examItems.stream().map(ExamItem::getScore).collect(toList())).containsExactlyInAnyOrder(0.89, 2.89, 3.89);
        assertThat(examItems.stream().map(ExamItem::getScoreStatus).collect(toList())).containsExactlyInAnyOrder("scoreStatus1", "scoreStatus2", "scoreStatus3");
        assertThat(examItems.stream().map(ExamItem::getResponse).collect(toList())).containsExactlyInAnyOrder(null, null, "response3");
        assertThat(elementErrorCollector.isEmpty()).isTrue();

        assertThat(examItems.get(1).getSubmittedAt()).isEqualTo(Instant.parse("2007-05-02T14:30:00Z"));
        assertThat(examItems.get(1).getResponseTypeId()).isEqualTo(2);
        assertThat(examItems.get(1).getAdministeredAt()).isEqualTo(Instant.parse("2007-03-02T14:30:00Z"));
        assertThat(examItems.get(1).getSubmitted()).isEqualTo(1);
        assertThat(examItems.get(1).getNumberOfVisits()).isEqualTo(3);
        assertThat(examItems.get(1).getPageVisits()).isEqualTo(4);
        assertThat(examItems.get(1).getPageTime()).isEqualTo(5);
        assertThat(examItems.get(1).getPageNumber()).isEqualTo(6);
        assertThat(examItems.get(1).getResponseDuration()).isEqualTo(6.6);

        assertThat(examItems.get(2).getResponseTypeId()).isEqualTo(1);
    }

    @Test
    public void itShouldReportErrors() {
        item1.setScore("11");
        item1.setScoreStatus("veryLongScoreStatus0123456789012345678901234567890123456789");
        item2.setKey(99);
        subScore3.setScorePoint("");
        subScore3.setScoreStatus("dim2ScoreStatusThatIsVeryLong0123456789012345678901234567890123456789");

        processor.parseExamItems(items, assessment, elementErrorCollector);

        //Note that un-scored items are ignored
        assertThat(elementErrorCollector.toJson()).isEqualTo("{\"messages\":[" +
                "{\"elementName\":\"item\",\"value\":\"11\",\"error\":\"invalid value, must be -1.0 - 10.0\"}," +
                "{\"elementName\":\"score status\",\"value\":\"veryLongScoreStatus0123456789012345678901234567890123456789\",\"error\":\"string is too long, max length is 50\"}," +
                "{\"elementName\":\"item\",\"value\":\"77-99\",\"error\":\"Missing item with id \\u003d 77-99\"}," +
                "{\"elementName\":\"item,subScore,status\",\"value\":\"dim2ScoreStatusThatIsVeryLong0123456789012345678901234567890123456789\",\"error\":\"string is too long, max length is 50\"}" +
                "]}");
    }
}