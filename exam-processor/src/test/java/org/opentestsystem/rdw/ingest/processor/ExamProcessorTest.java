package org.opentestsystem.rdw.ingest.processor;

import com.amazonaws.util.IOUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.http.MediaType;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.GenericMessage;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Properties;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.common.model.trt.TDSReport;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.processor.service.TDSReportProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineResults;
import org.opentestsystem.rdw.script.ScriptRuntimeException;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ExamProcessorTest {

    @Mock
    private TDSReportProcessor reportProcessor;
    @Mock
    private ImportRepository importRepository;
    @Mock
    private PipelineFactory pipelineFactory;
    @Mock
    private ArchiveService archiveService;

    private static final long importId = 42;
    private Message message;

    private ExamProcessor examProcessor;

    @Before
    public void createProcessor() throws IOException {
        // use accessor to set message headers
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(null);
        accessor.setImportId(importId);
        accessor.setContentType(MediaType.APPLICATION_XML);
        accessor.setTenantId("CA");

        // read payload from a good TDSReport
        // (we have to do this because of the call to the static helper, tdsReportFromXml)
        final byte[] payload = IOUtils.toByteArray(this.getClass().getResourceAsStream("/TDSReport.iab.sample.xml"));

        message = new GenericMessage<>(payload, accessor.getMessageHeaders());

        examProcessor = new ExamProcessor(reportProcessor, importRepository, pipelineFactory, archiveService);
    }

    @Test
    public void itShouldDoNothingIfTenantIdIsNotSet() {
        // use accessor to set message headers
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(null);
        accessor.setImportId(importId);
        accessor.setContentType(MediaType.APPLICATION_XML);
        final Message badMessage = new GenericMessage<>("DEADBEEF".getBytes(StandardCharsets.UTF_8), accessor.getMessageHeaders());

        examProcessor.process(badMessage);
        verifyZeroInteractions(reportProcessor);
        verifyZeroInteractions(importRepository);
        verifyZeroInteractions(pipelineFactory);
        verifyZeroInteractions(archiveService);
    }

    @Test
    public void itShouldAllowNoPipeline() {
        when(pipelineFactory.getPipeline(ExamProcessor.PipelineName, "1")).thenReturn(null);

        examProcessor.process(message);
        verifyZeroInteractions(archiveService);
        verify(reportProcessor).process(any(TDSReport.class), eq(importId));
        verify(importRepository).updateStatusAndMessageById(importId, ImportStatus.PROCESSED, null);
    }

    @Test
    public void itIgnoresPipelineBuildExceptions() {
        // not sure this is right, but a test for it anyway ...
        when(pipelineFactory.getPipeline(ExamProcessor.PipelineName, "1")).thenThrow(PipelineBuildException.class);

        examProcessor.process(message);
        verifyZeroInteractions(archiveService);
        verify(reportProcessor).process(any(TDSReport.class), eq(importId));
        verify(importRepository).updateStatusAndMessageById(importId, ImportStatus.PROCESSED, null);
    }

    @Test
    public void itShouldUseAPipeline() {
        // a pipeline that makes no changes ...
        final Pipeline pipeline = mock(Pipeline.class);
        when(pipelineFactory.getPipeline(ExamProcessor.PipelineName, "1")).thenReturn(pipeline);
        when(pipeline.run(any())).thenAnswer(invocation -> new PipelineResults(invocation.getArguments()[0], false));

        examProcessor.process(message);
        verifyZeroInteractions(archiveService);
        verify(reportProcessor).process(any(TDSReport.class), eq(importId));
        verify(importRepository).updateStatusAndMessageById(importId, ImportStatus.PROCESSED, null);
    }

    @Test
    public void itShouldArchiveTransformedPayloads() {
        final Pipeline pipeline = mock(Pipeline.class);
        when(pipelineFactory.getPipeline(ExamProcessor.PipelineName, "1")).thenReturn(pipeline);
        when(pipeline.run(any())).thenAnswer(invocation -> new PipelineResults(invocation.getArguments()[0], true));

        examProcessor.process(message);
        verify(archiveService).writeResource(anyString(), any(byte[].class), any(Properties.class));
        verify(reportProcessor).process(any(TDSReport.class), eq(importId));
        verify(importRepository).updateStatusAndMessageById(importId, ImportStatus.PROCESSED, null);
    }

    @Test
    public void itShouldHandleScriptRuntimeExceptions() {
        final Pipeline pipeline = mock(Pipeline.class);
        when(pipelineFactory.getPipeline(ExamProcessor.PipelineName, "1")).thenReturn(pipeline);
        when(pipeline.run(any()))
                .thenThrow(new ScriptRuntimeException(new ImportException(ImportStatus.UNKNOWN_ASMT, "wha?")));

        examProcessor.process(message);
        verify(importRepository).updateStatusAndMessageById(importId, ImportStatus.UNKNOWN_ASMT, "wha?");
    }

    @Test
    public void itShouldHandleImportExeceptions() {
        when(pipelineFactory.getPipeline(ExamProcessor.PipelineName, "1")).thenReturn(null);
        doThrow(new ImportException(ImportStatus.BAD_FORMAT, "buggers"))
                .when(reportProcessor).process(any(TDSReport.class), eq(importId));

        examProcessor.process(message);
        verify(importRepository).updateStatusAndMessageById(importId, ImportStatus.BAD_FORMAT, "buggers");
    }

    @Test
    public void itShouldHandleProcessingExceptions() {
        when(pipelineFactory.getPipeline(ExamProcessor.PipelineName, "1")).thenReturn(null);
        doThrow(new RuntimeException("darn"))
                .when(reportProcessor).process(any(TDSReport.class), eq(importId));

        examProcessor.process(message);
        verify(importRepository).updateStatusAndMessageById(importId, ImportStatus.BAD_DATA, "darn");
    }
}
