package org.opentestsystem.rdw.ingest.processor;

import org.junit.Test;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.context.jdbc.SqlGroup;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static org.springframework.test.context.jdbc.Sql.ExecutionPhase.BEFORE_TEST_METHOD;

@SuppressWarnings({"SqlNoDataSourceInspection", "SqlResolve"})
/*
 * Percentile tables will be loaded similar to packages.
 * Load two tables each for one assessment.
 * Load the provided percent and score for each percentile table along with a min and max to be calculated.
 * The min and max provide for more efficient queries to select the percentile for a given score for a given assessment.
 */
@SqlGroup({
        @Sql(executionPhase = BEFORE_TEST_METHOD, scripts = {"classpath:/PreloadAsmtOrgStudentExam.sql"}),
        @Sql(executionPhase = BEFORE_TEST_METHOD, statements = {
                "INSERT INTO percentile (id, asmt_id, start_date, end_date, count, mean, standard_deviation, min_score, max_score, import_id, update_import_id)\n" +
                        "VALUES\n" +
                        "  (1, 1, '2018-01-01', '2018-03-31', 835430, 2420.1, 88.9, 1111, 4444, 1, 1),\n" +
                        "  (2, 2, '2018-01-01', '2018-03-31', 830430, 2410.5, 77.9, 1111, 4444, 1, 1);\n" +
                        "INSERT INTO percentile_score (percentile_id, percentile_rank, score, min_inclusive, max_exclusive)\n" +
                        "VALUES\n" +
                        "  (1,  5, 2278, 1111, 2303),\n" +
                        "  (1, 10, 2303, 2303, 2322),\n" +
                        "  (1, 15, 2322, 2322, 2338),\n" +
                        "  (1, 20, 2338, 2338, 2354),\n" +
                        "  (1, 25, 2354, 2354, 2368),\n" +
                        "  (1, 30, 2368, 2368, 2382),\n" +
                        "  (1, 35, 2382, 2382, 2395),\n" +
                        "  (1, 40, 2395, 2395, 2408),\n" +
                        "  (1, 45, 2408, 2408, 2420),\n" +
                        "  (1, 50, 2420, 2420, 2433),\n" +
                        "  (1, 55, 2433, 2433, 2445),\n" +
                        "  (1, 60, 2445, 2445, 2458),\n" +
                        "  (1, 65, 2458, 2458, 2471),\n" +
                        "  (1, 70, 2471, 2471, 2485),\n" +
                        "  (1, 75, 2485, 2485, 2500),\n" +
                        "  (1, 80, 2500, 2500, 2517),\n" +
                        "  (1, 85, 2517, 2517, 2538),\n" +
                        "  (1, 90, 2538, 2538, 2566),\n" +
                        "  (1, 95, 2566, 2566, 4444),\n" +
                        "  (2,  5, 2278, 1111, 2303),\n" +
                        "  (2, 10, 2303, 2303, 2322),\n" +
                        "  (2, 15, 2322, 2322, 2338),\n" +
                        "  (2, 20, 2338, 2338, 2354),\n" +
                        "  (2, 25, 2354, 2354, 2368),\n" +
                        "  (2, 30, 2368, 2368, 2382),\n" +
                        "  (2, 35, 2382, 2382, 2395),\n" +
                        "  (2, 40, 2395, 2395, 2408),\n" +
                        "  (2, 45, 2408, 2408, 2420),\n" +
                        "  (2, 50, 2420, 2420, 2433),\n" +
                        "  (2, 55, 2433, 2433, 2445),\n" +
                        "  (2, 60, 2445, 2445, 2458),\n" +
                        "  (2, 65, 2458, 2458, 2471),\n" +
                        "  (2, 70, 2471, 2471, 2485),\n" +
                        "  (2, 75, 2485, 2485, 2500),\n" +
                        "  (2, 80, 2500, 2500, 2517),\n" +
                        "  (2, 85, 2517, 2517, 2538),\n" +
                        "  (2, 90, 2538, 2538, 2566),\n" +
                        "  (2, 95, 2566, 2566, 4444);"
        })
})
public class PercentileSchemaIT extends RepositoryBackedIT {

    @Autowired
    private NamedParameterJdbcTemplate namedParameterTemplate;

    /**
     * Simulate a query that returns one exam that must include the percentile rank.
     */
    @Test
    public void itShouldFindPercentileForOneExam() {
        assertThat(namedParameterTemplate.queryForObject(
                "SELECT ps.percentile_rank FROM exam e\n" +
                        "LEFT JOIN percentile p ON e.asmt_id = p.asmt_id\n" +
                        "LEFT JOIN percentile_score ps ON ps.percentile_id = p.id\n" +
                        "WHERE e.oppId = :oppId\n" +
                        "      AND e.scale_score >= ps.min_inclusive AND e.scale_score < ps.max_exclusive",
                new MapSqlParameterSource().addValue("oppId", "100000000060"), Integer.class)
        ).isEqualTo(75);
    }

    /**
     * Simulate a query that returns multiple exams that must include the percentile rank for each.
     */
    @Test
    public void itShouldFindPercentileForMultipleExams() {
        final List<Map<String, Object>> examList = namedParameterTemplate.getJdbcOperations().queryForList(
                "SELECT e.id, e.asmt_id, e.oppId, e.scale_score, ps.percentile_rank FROM exam e\n" +
                        "LEFT JOIN percentile p ON e.asmt_id = p.asmt_id\n" +
                        "LEFT JOIN percentile_score ps ON ps.percentile_id = p.id AND e.scale_score >= ps.min_inclusive AND e.scale_score < ps.max_exclusive");

        assertThat(examList.size()).isEqualTo(9);

        for (Map<String, Object> examMap : examList) {
            switch ((String) examMap.get("OppId")) {
                case "100000000030":
                    assertThat(examMap.get("scale_score")).isEqualTo(2100.2f);
                    assertThat(examMap.get("percentile_rank")).isEqualTo(5);
                    break;
                case "100000000010":
                    assertThat(examMap.get("scale_score")).isEqualTo(2325.1f);
                    assertThat(examMap.get("percentile_rank")).isEqualTo(15);
                    break;
                case "100000000050":
                    assertThat(examMap.get("scale_score")).isEqualTo(2395.2f);
                    assertThat(examMap.get("percentile_rank")).isEqualTo(40);
                    break;
                case "100000000035":
                    assertThat(examMap.get("scale_score")).isEqualTo(2408.2f);
                    assertThat(examMap.get("percentile_rank")).isEqualTo(45);
                    break;
                case "100000000060":
                    assertThat(examMap.get("scale_score")).isEqualTo(2491f);
                    assertThat(examMap.get("percentile_rank")).isEqualTo(75);
                    break;
                case "100000000080":
                    assertThat(examMap.get("scale_score")).isEqualTo(2600f);
                    assertThat(examMap.get("percentile_rank")).isEqualTo(95);
                    break;
                case "100000000020":
                case "100000000040":
                case "100000000070":
                    // Three exams are for an assessment with no percentile table loaded.
                    assertThat(examMap.get("percent")).isNull();
                    break;
                default:
                    throw new IllegalStateException("Each case should be covered");
            }
        }
    }

}