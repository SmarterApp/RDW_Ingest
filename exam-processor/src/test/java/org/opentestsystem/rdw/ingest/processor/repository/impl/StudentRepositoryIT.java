package org.opentestsystem.rdw.ingest.processor.repository.impl;

import org.junit.Before;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Import;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.jdbc.JdbcTestUtils;

import java.sql.Date;
import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Map;
import org.opentestsystem.rdw.ingest.processor.model.ExamSchool;
import org.opentestsystem.rdw.ingest.processor.model.Student;
import org.opentestsystem.rdw.ingest.processor.repository.StudentRepository;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.jdbc.JdbcTestUtils.countRowsInTableWhere;

@Import(JdbcStudentRepository.class)
public class StudentRepositoryIT extends TenantAwareIT {

    @Autowired
    private StudentRepository repository;

    @Autowired
    private JdbcTemplate jdbcTemplate;
    private NamedParameterJdbcTemplate namedParameterTemplate;

    private Student.Builder studentBuilder;

    private final int studentId = -999;
    private final String studentSQL = "INSERT INTO student (id, ssid, last_or_surname, first_name, middle_name, alias_name, gender_id, first_entry_into_us_school_at, lep_entry_at, lep_exit_at, birthday, import_id, update_import_id, latest_info_update) " +
            "VALUES  (-999, '6666666669', 'LastName6', 'FirstName6', 'MiddleName6', 'AliasName6', 1, '2015-09-02', null, null, '2006-07-08', -99, -99, '2015-01-01')";

    @Before
    public void setUp() {
        namedParameterTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);

        studentBuilder = Student.builder()
                .ssid("6666666669")
                .firstName("FirstName6")
                .lastOrSurname("LastName6")
                .middleName("MiddleName6")
                .aliasName("AliasName6")
                .birthday(LocalDate.parse("2006-07-08"))
                .firsEntryIntoUSSchoolAt(LocalDate.parse("2015-09-02"))
                .lepEntryAt(null)
                .lepExitAt(null)
                .genderId(1);
    }

    @Test
    @Sql(statements = {
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -99, 0, 1, 'type', 'digest')",
            studentSQL,
            "INSERT INTO student_ethnicity (student_id, ethnicity_id) VALUES (-999, 6), (-999, 4)"
    })
    public void itShouldFindExisting() {
        final int countRowInStudentBefore = JdbcTestUtils.countRowsInTable(jdbcTemplate, "student");
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student_ethnicity", "student_id = " + studentId)).isEqualTo(2);

        final List<Integer> ethnicity = newArrayList();
        ethnicity.add(4);
        ethnicity.add(6);

        assertThat(repository.upsert(studentBuilder.ethnicityIds(ethnicity).build(), -100)).isEqualTo(studentId);

        //verify that number of rows has not changed
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student_ethnicity", "student_id =" + studentId)).isEqualTo(2);
        assertThat(JdbcTestUtils.countRowsInTable(jdbcTemplate, "student")).isEqualTo(countRowInStudentBefore);

        //verify that import id has not changed
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -99 and inferred_school_id is null")).isEqualTo(1);
    }

    @Test
    @Sql(statements = {
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -99, 0, 1, 'type', 'digest'),( -100, 0, 1, 'type', 'digest')",
            studentSQL,
            "INSERT INTO district (id, name, natural_id) VALUES (-22, 'Sample District 1', 'DistrictNaturalId');",
            "INSERT INTO school (id, district_id, name, natural_id, import_id, update_import_id) VALUES " +
                    "(-27, -22, 'Sample School 1', 'SchoolNaturalId', -99, -99)," +
                    "(-26, -22, 'Sample School 2', 'SchoolNaturalId2', -99, -99)," +
                    "(-25, -22, 'Sample School 3', 'SchoolNaturalId3', -99, -99);",
            "INSERT INTO asmt (id, natural_id, grade_id,type_id, subject_id, school_year, name, label, version, import_id, update_import_id) VALUES\n" +
                    "  (-1, '(SBAC)SBAC-ICA-FIXED-G5E-COMBINED-2017', 5, 1, 2, 2016, 'SBAC-ICA-FIXED-G5E-COMBINED-2017', 'Grade 5 ELA', '9831', -99, -99);\n",
            "INSERT INTO  exam ( id, type_id, school_year, asmt_id, asmt_version, opportunity, completeness_id,\n" +
                    "                    administration_condition_id, military_connected_id, session_id, performance_level, scale_score, scale_score_std_err, completed_at,\n" +
                    "                    import_id, update_import_id, deleted, created, updated, grade_id, student_id, school_id, iep, lep, section504, economic_disadvantage,\n" +
                    "                    migrant_status, eng_prof_lvl, t3_program_type, language_id, prim_disability_type) VALUES\n" +
                    "  (-88, 1, 2016, -1,  null, 1, 1, 1, 1, 'session', 1, 2145, 0.17, '2016-08-14 19:05:33.000000', -99, -99, 1, '2017-05-18 19:05:33.967000', '2017-07-18 19:06:07.966000', 3, -999, -27, 1, 1, 0, 0, 1, 'eng_prof_lvl', 't3_program_type', 0, null),\n" +
                    "  (-87, 1, 2016, -1,  null, 1, 1, 1, 1, 'session', 1, null, null, '2016-07-14 19:05:33.000000', -99, -99, 0, '2017-07-18 19:06:07.966000', '2017-07-18 19:06:07.966000', 3, -999, -27, 1, 1, 0, 0, 1, 'eng_prof_lvl', 't3_program_type', 0, null),\n" +
                    "  (-86, 2, 2016, -1,  null, 1, 1, 1, 1, 'session', 1, null, null, '2016-06-14 19:05:33.000000', -99, -99, 0, '2017-07-18 19:06:07.966000', '2017-07-18 19:06:07.966000', 3, -999, -27, 1, 1, 0, 0, 1, 'eng_prof_lvl', 't3_program_type', 0, null),\n" +
                    "  (-85, 1, 2016, -1,  null, 1, 1, 1, 1, 'session', 1, 2145, 0.17, '2016-07-14 19:05:33.000001', -99, -99, 0, '2017-07-18 19:06:07.966001', '2017-07-18 19:06:07.966000', 3, -999, -26, 1, 1, 0, 0, 1, 'eng_prof_lvl', 't3_program_type', 0, null);\n"
    })
    public void itShouldFindExistingAndUpdateSchoolBasedOnExams() {

        final Student student = studentBuilder.build();
        student.setSchool(null);
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -99 and inferred_school_id IS NULL")).isEqualTo(1);

        repository.upsert(student, -100);
        //derived the school from exams by taking the one that is not deleted, has the latest completed_at and the highest id
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -100 and inferred_school_id = -26")).isEqualTo(1);

        //force the inferred school date to be before the last exam
        student.setSchool(new ExamSchool(-27, Instant.parse("2016-01-02T14:30:00Z")));
        repository.upsert(student, -99);
        //verify that the school is has not been changed since there is an exam with a more recent date
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -100 and inferred_school_id = -26")).isEqualTo(1);

        //force the inferred school date to be before the last exam and make another change to the student
        final Student updatedStudent = studentBuilder.firstName("new name").build();
        updatedStudent.setSchool(new ExamSchool(-27, Instant.parse("2016-01-02T14:30:00Z")));
        repository.upsert(updatedStudent, -99);
        //verify that the import id has changed but the school id has not been updated since there is an exam with a more recent date
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -99 and inferred_school_id = -26")).isEqualTo(1);

        //force the inferred school date to be past all the exams
        student.setSchool(new ExamSchool(-27, Instant.parse("2017-01-02T14:30:00Z")));
        repository.upsert(student, -99);
        //verify that the school id has been updated
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -99 and inferred_school_id = -27")).isEqualTo(1);

        //remove all exams and make sure that the inferred school is deleted. NOTE that it happens regardless of the school inferred date
        jdbcTemplate.execute("DELETE FROM exam WHERE student_id = " + studentId);
        student.setSchool(null);
        repository.upsert(student, -100);
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -100 and inferred_school_id IS NULL")).isEqualTo(1);
    }

    @Test
    @Sql(statements = {
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -99, 0, 1, 'type', 'digest')",
            "INSERT INTO district (id, name, natural_id) VALUES (-22, 'Sample District 1', 'DistrictNaturalId');",
            "INSERT INTO school (id, district_id, name, natural_id, import_id, update_import_id) VALUES (-27, -22, 'Sample School 1', 'SchoolNaturalId', -99, -99);",
    })
    public void itShouldCreateNew() {

        final int countRowInStudentBefore = JdbcTestUtils.countRowsInTable(jdbcTemplate, "student");
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "ssid = '6666666669'")).isZero();

        final Student student = studentBuilder.build();
        student.setSchool(new ExamSchool(-27, Instant.parse("2007-01-02T14:30:00Z")));
        repository.upsert(student, -99);

        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "ssid = '6666666669' and import_id = -99 and update_import_id = -99  and inferred_school_id = -27")).isEqualTo(1);
        assertThat(JdbcTestUtils.countRowsInTable(jdbcTemplate, "student")).isEqualTo(countRowInStudentBefore + 1);
    }

    @Test
    @Sql(statements = {
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -99, 0, 1, 'type', 'digest')",
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -100, 0, 1, 'type', 'digest')",
            studentSQL,
            "INSERT INTO student_ethnicity (student_id, ethnicity_id) VALUES (-999, 6), (-999, 4)"
    })
    public void itShouldFindAndUpdateExistingWithNoChangeToEthnicity() {
        final String newStudentSQL = "id=" + studentId + " and first_name ='FirstName - New Name' and " +
                "last_or_surname = 'LastName - New Name' and middle_name='MiddleName - New Name' and birthday='1999-05-01' and " +
                "gender_id=0";

        assertThat(countRowsInTableWhere(jdbcTemplate, "student", newStudentSQL)).isZero();
        final int countRowInStudentBefore = JdbcTestUtils.countRowsInTable(jdbcTemplate, "student");

        final List<Integer> ethnicity = newArrayList();
        ethnicity.add(4);
        ethnicity.add(6);

        assertThat(repository.upsert(Student.builder()
                .ssid("6666666669")
                .firstName("FirstName - New Name")
                .lastOrSurname("LastName - New Name")
                .middleName("MiddleName - New Name")
                .aliasName("AliasName - New Name")
                .birthday(LocalDate.parse("1999-05-01"))
                .ethnicityIds(ethnicity)
                .genderId(0)
                .build(), -100)).isEqualTo(-999);

        assertThat(JdbcTestUtils.countRowsInTable(jdbcTemplate, "student")).isEqualTo(countRowInStudentBefore);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", newStudentSQL)).isEqualTo(1);

        //verify that import id has changed
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and import_id = -99 and update_import_id = -100")).isEqualTo(1);
    }

    @Test
    @Sql(statements = {
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -99, 0, 1, 'type', 'digest')",
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -100, 0, 1, 'type', 'digest')",
            studentSQL,
            "INSERT INTO student_ethnicity (student_id, ethnicity_id) VALUES (-999, 6), (-999, 4)"
    })
    public void itShouldFindAndUpdateExistingIfOnlyEthnicityChanges() {

        final int countRowInStudentBefore = JdbcTestUtils.countRowsInTable(jdbcTemplate, "student");
        final int countRowInEthnBefore = JdbcTestUtils.countRowsInTable(jdbcTemplate, "student_ethnicity");

        final List<Integer> ethnicity = newArrayList();
        ethnicity.add(4);
        ethnicity.add(5);

        assertThat(repository.upsert(studentBuilder.ethnicityIds(ethnicity).build(), -100)).isEqualTo(studentId);

        assertThat(JdbcTestUtils.countRowsInTable(jdbcTemplate, "student")).isEqualTo(countRowInStudentBefore);
        assertThat(JdbcTestUtils.countRowsInTable(jdbcTemplate, "student_ethnicity")).isEqualTo(countRowInEthnBefore);
        //verify that import id has changed
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -100")).isEqualTo(1);

        assertThat(repository.upsert(studentBuilder.ethnicityIds(newArrayList()).build(), -99)).isEqualTo(studentId);

        assertThat(JdbcTestUtils.countRowsInTable(jdbcTemplate, "student")).isEqualTo(countRowInStudentBefore);
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student_ethnicity", "student_id = -999 and ethnicity_id in (4,5)")).isEqualTo(countRowInEthnBefore - 2);
        //verify that import id has changed
        assertThat(JdbcTestUtils.countRowsInTableWhere(jdbcTemplate, "student", "id =" + studentId + " and update_import_id = -99")).isEqualTo(1);
    }

    @Test
    @Sql(statements = {
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -99, 0, 1, 'type', 'digest')",
            "INSERT INTO import (id, status, content, contentType, digest) VALUES ( -100, 0, 1, 'type', 'digest')",
            studentSQL
    })
    public void itShouldHandleNullableDatesComparison() {

        final int countRowInStudentBefore = JdbcTestUtils.countRowsInTable(jdbcTemplate, "student");

        assertThat(repository.upsert(studentBuilder.firsEntryIntoUSSchoolAt(null).build(), -100)).isEqualTo(studentId);

        assertThat(JdbcTestUtils.countRowsInTable(jdbcTemplate, "student")).isEqualTo(countRowInStudentBefore);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student",
                "id = " + studentId + " and first_entry_into_us_school_at is null and lep_entry_at is null and lep_exit_at is null and update_import_id = -100")).isEqualTo(1);

        assertThat(repository.upsert(studentBuilder.lepExitAt(LocalDate.parse("2017-05-03")).build(), -99)).isEqualTo(studentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student",
                "id = " + studentId + " and first_entry_into_us_school_at is null and lep_entry_at is null and lep_exit_at = '2017-05-03' and update_import_id = -99")).isEqualTo(1);

        assertThat(repository.upsert(studentBuilder.lepEntryAt(LocalDate.parse("2017-05-03")).build(), -100)).isEqualTo(studentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student",
                "id = " + studentId + " and first_entry_into_us_school_at is null and lep_entry_at = '2017-05-03' and lep_exit_at = '2017-05-03' and update_import_id = -100")).isEqualTo(1);
    }


    @Test
    @Sql(statements = {
            "INSERT INTO import (id, status, content, contentType, digest) VALUES " +
                    "( -99, 0, 1, 'type', 'digest')," +
                    "( -98, 0, 1, 'type', 'digest')," +
                    "( -97, 0, 1, 'type', 'digest')," +
                    "( -96, 0, 1, 'type', 'digest')," +
                    "( -95, 0, 1, 'type', 'digest')",
            "INSERT INTO district (id, name, natural_id) VALUES (-22, 'Sample District 1', 'DistrictNaturalId');",
            "INSERT INTO school (id, district_id, name, natural_id, import_id, update_import_id) VALUES " +
                "(-27, -22, 'Sample School 1', 'SchoolNaturalId1', -99, -99)," +
                "(-28, -22, 'Sample School 2', 'SchoolNaturalId2', -99, -99);",
    })
    public void itShouldAuditStudent() {
        jdbcTemplate.update("UPDATE setting s SET s.value = 'TRUE' WHERE s.name = 'AUDIT_TRIGGER_ENABLE';");
        assertThat(countRowsInTableWhere(jdbcTemplate, "setting s", " s.name = 'AUDIT_TRIGGER_ENABLE' and s.value = 'TRUE'")).isEqualTo(1);

        studentBuilder
                .ssid("SSID001")
                .firstName("FirstName001")
                .lastOrSurname("LastName001")
                .middleName("MiddleName001")
                .aliasName("AliasName001")
                .birthday(LocalDate.parse("2006-01-01"))
                .firsEntryIntoUSSchoolAt(LocalDate.parse("2017-01-01"))
                .lepEntryAt(LocalDate.parse("2017-01-01"))
                .lepExitAt(LocalDate.parse("2017-01-01"))
                .genderId(1);

        final Student studentOne = studentBuilder.build();
        studentOne.setSchool(new ExamSchool(-27, Instant.parse("2017-02-02T00:00:00.00Z")));

        // *** Create original student ***
        final int originalStudentId = repository.upsert(studentOne, -99);

        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);

        // *** First update to student ***
        // Save original student to compare
        final Map<String, Object> originalStudentToUpdate = namedParameterTemplate.queryForMap(
                "SELECT * FROM student WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalStudentId));

        final Student secondStudent = studentBuilder.lepEntryAt(LocalDate.parse("2006-02-02")).build();
        secondStudent.setSchool(new ExamSchool(-28, Instant.parse("2017-03-03T00:00:00.00Z")));
        final int secondStudentId = repository.upsert(secondStudent, -98);

        final Map<String, Object> firstAuditValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM audit_student WHERE student_id = :student_id",
                new MapSqlParameterSource().addValue("student_id", originalStudentId));

        assertThat(originalStudentId).isEqualTo(secondStudentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);

        // New field latest_info_update currently not copied over to the audit.
        assertThat(originalStudentToUpdate.remove("latest_info_update")).isNotNull();

        assertThat(firstAuditValues.remove("id")).isNotNull();
        assertThat(firstAuditValues.remove("action")).isEqualTo("update");
        assertThat(firstAuditValues.remove("audited")).isNotNull();
        assertThat(firstAuditValues.remove("database_user")).isNotNull();
        assertThat(firstAuditValues.remove("student_id")).isEqualTo(originalStudentToUpdate.remove("id"));
        assertThat(originalStudentToUpdate).isEqualTo(firstAuditValues);

        // *** Second update to student ***
        // Save original student to compare
        final Map<String, Object> secondStudentToUpdate = namedParameterTemplate.queryForMap(
                "SELECT * FROM student WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalStudentId));

        final Student thirdStudent = studentBuilder.build();
        thirdStudent.setSchool(new ExamSchool(-27, Instant.parse("2017-03-03T00:00:00.00Z")));

        final int thirdStudentId = repository.upsert(thirdStudent, -97);

        final Map<String, Object> secondAuditValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM audit_student WHERE student_id = :student_id ORDER BY audited DESC LIMIT 1",
                new MapSqlParameterSource().addValue("student_id", originalStudentId));

        assertThat(originalStudentId).isEqualTo(thirdStudentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);

        // New field latest_info_update currently not copied over to the audit.
        assertThat(secondStudentToUpdate.remove("latest_info_update")).isNotNull();

        assertThat(secondAuditValues.remove("id")).isNotNull();
        assertThat(secondAuditValues.remove("action")).isEqualTo("update");
        assertThat(secondAuditValues.remove("audited")).isNotNull();
        assertThat(secondAuditValues.remove("database_user")).isNotNull();
        assertThat(secondAuditValues.remove("student_id")).isEqualTo(secondStudentToUpdate.remove("id"));
        assertThat(secondStudentToUpdate).isEqualTo(secondAuditValues);

        // *** Third update student ***
        // Save original student to compare
        final Map<String, Object> thirdStudentToUpdate = namedParameterTemplate.queryForMap(
                "SELECT * FROM student WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalStudentId));

        final int fourthStudentId = repository.upsert(
                studentBuilder
                        .lastOrSurname("LastNameChanged")
                        .birthday(LocalDate.parse("2006-02-03"))
                        .build(), -96);

        final Map<String, Object> thirdAuditValues = namedParameterTemplate.queryForMap(
                "SELECT * FROM audit_student WHERE student_id = :student_id ORDER BY audited DESC LIMIT 1",
                new MapSqlParameterSource().addValue("student_id", originalStudentId));

        // At least on comparison between audit and actual must have no null values in actual to assure all columns are audited.
        thirdStudentToUpdate.forEach((k, v) -> assertThat(v).isNotNull());

        assertThat(originalStudentId).isEqualTo(fourthStudentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);

        // New field latest_info_update currently not copied over to the audit.
        assertThat(thirdStudentToUpdate.remove("latest_info_update")).isNotNull();

        assertThat(thirdAuditValues.remove("id")).isNotNull();
        assertThat(thirdAuditValues.remove("action")).isEqualTo("update");
        assertThat(thirdAuditValues.remove("audited")).isNotNull();
        assertThat(thirdAuditValues.remove("database_user")).isNotNull();
        assertThat(thirdAuditValues.remove("student_id")).isEqualTo(thirdStudentToUpdate.remove("id"));
        assertThat(thirdStudentToUpdate).isEqualTo(thirdAuditValues);

        // *** Last upsert student with no changes ***
        final Map<String, Object> beforeLastUpsert = namedParameterTemplate.queryForMap(
                "SELECT updated FROM student WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalStudentId));

        repository.upsert(studentBuilder.build(), -95);

        final Map<String, Object> afterLastUpsert = namedParameterTemplate.queryForMap(
                "SELECT updated FROM student WHERE id = :id",
                new MapSqlParameterSource().addValue("id", originalStudentId));

        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);
        assertThat(beforeLastUpsert.get("updated")).isEqualTo(afterLastUpsert.get("updated"));
    }

    @Test
    @Sql(statements = {
            "INSERT INTO import (id, status, content, contentType, digest) VALUES " +
                    "( -99, 0, 1, 'type', 'digest')," +
                    "( -98, 0, 1, 'type', 'digest')," +
                    "( -97, 0, 1, 'type', 'digest')," +
                    "( -96, 0, 1, 'type', 'digest')," +
                    "( -95, 0, 1, 'type', 'digest')",
            "INSERT INTO district (id, name, natural_id) VALUES (-22, 'Sample District 1', 'DistrictNaturalId');",
            "INSERT INTO school (id, district_id, name, natural_id, import_id, update_import_id) VALUES (-27, -22, 'Sample School 1', 'SchoolNaturalId', -99, -99);",
    })
    public void itShouldAuditStudentEthnicity() {
        // Enable and disable of triggers is an operational concern, this test must have them on.
        jdbcTemplate.update("UPDATE setting s SET s.value = 'TRUE' WHERE s.name = 'AUDIT_TRIGGER_ENABLE';");
        assertThat(countRowsInTableWhere(jdbcTemplate, "setting s", " s.name = 'AUDIT_TRIGGER_ENABLE' and s.value = 'TRUE'")).isEqualTo(1);

        studentBuilder
                .ssid("SSID001")
                .firstName("FirstName001")
                .lastOrSurname("LastName001")
                .middleName("MiddleName001")
                .aliasName("AliasName001")
                .birthday(LocalDate.parse("2006-01-01"))
                .firsEntryIntoUSSchoolAt(LocalDate.parse("2017-01-01"))
                .lepEntryAt(LocalDate.parse("2017-01-01"))
                .lepExitAt(LocalDate.parse("2017-01-01"))
                .genderId(1);

        // *** Create original student ***
        final int originalStudentId = repository.upsert(studentBuilder.ethnicityIds(null).build(), -99);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);

        // *** First update to student adds 4 ethnicity codes for student ***
        final List<Integer> ethnicityList = newArrayList();
        ethnicityList.add(1);
        ethnicityList.add(2);
        ethnicityList.add(3);
        ethnicityList.add(4);
        final int secondStudentId = repository.upsert(studentBuilder.ethnicityIds(ethnicityList).build(), -98);

        assertThat(originalStudentId).isEqualTo(secondStudentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(1);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(4);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);

        // *** Second update to student, add one and delete two ethnicity ***
        // Save student_ethnicity records to be deleted by update to compare with audit records.
        // student_ethnicity is created or deleted, rows are not updated.
        final List<Map<String, Object>> secondEthnicityListToDelete = namedParameterTemplate.queryForList(
                "SELECT * FROM student_ethnicity WHERE student_id = :student_id AND ethnicity_id IN (2, 4)",
                new MapSqlParameterSource().addValue("student_id", originalStudentId));
        assertThat(secondEthnicityListToDelete.size()).isEqualTo(2);

        // At least one comparison between audit and actual must have no null values in actual to assure all columns are audited.
        secondEthnicityListToDelete.get(0).forEach((k, v) -> assertThat(v).isNotNull());

        ethnicityList.clear();
        ethnicityList.add(1);
        ethnicityList.add(3);
        ethnicityList.add(5);
        final int thirdStudentId = repository.upsert(studentBuilder.ethnicityIds(ethnicityList).build(), -97);

        assertThat(originalStudentId).isEqualTo(thirdStudentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(2);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);
        compareAuditStudentEthnicityToActual(secondEthnicityListToDelete, originalStudentId);

        // *** Third update to student, add two and delete two ethnicity ***
        // Save student_ethnicity records to be deleted by update to compare with audit records.
        final List<Map<String, Object>> thirdEthnicityListToDelete = namedParameterTemplate.queryForList(
                "SELECT * FROM student_ethnicity WHERE student_id = :student_id AND ethnicity_id IN (1, 3)",
                new MapSqlParameterSource().addValue("student_id", originalStudentId));
        assertThat(thirdEthnicityListToDelete.size()).isEqualTo(2);

        ethnicityList.clear();
        ethnicityList.add(2);
        ethnicityList.add(5);
        ethnicityList.add(6);
        final int fourthStudentId = repository.upsert(studentBuilder.ethnicityIds(ethnicityList).build(), -96);

        assertThat(originalStudentId).isEqualTo(fourthStudentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(4);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(3);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);
        compareAuditStudentEthnicityToActual(thirdEthnicityListToDelete, originalStudentId);

        // *** Fourth update to student, delete three ethnicity ***
        // Save student_ethnicity records to be deleted by update to compare with audit records.
        final List<Map<String, Object>> fourthEthnicityListToDelete = namedParameterTemplate.queryForList(
                "SELECT * FROM student_ethnicity WHERE student_id = :student_id AND ethnicity_id IN (2,5,6)",
                new MapSqlParameterSource().addValue("student_id", originalStudentId));
        assertThat(fourthEthnicityListToDelete.size()).isEqualTo(3);

        ethnicityList.clear();
        final int fifthStudentId = repository.upsert(studentBuilder.ethnicityIds(ethnicityList).build(), -95);

        assertThat(originalStudentId).isEqualTo(fifthStudentId);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student", " student_id = " + originalStudentId)).isEqualTo(4);
        assertThat(countRowsInTableWhere(jdbcTemplate, "audit_student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(7);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student_ethnicity", " student_id = " + originalStudentId)).isEqualTo(0);
        assertThat(countRowsInTableWhere(jdbcTemplate, "student", " id = " + originalStudentId)).isEqualTo(1);
        compareAuditStudentEthnicityToActual(fourthEthnicityListToDelete, originalStudentId);
    }

    private void compareAuditStudentEthnicityToActual(final List<Map<String, Object>> studentEthnicityList, final long originalStudentId) {
        studentEthnicityList.forEach((studentEthnicityValues) -> {
            final Map<String, Object> auditEthnicityValues = namedParameterTemplate.queryForMap(
                    "SELECT * FROM audit_student_ethnicity WHERE student_id = :student_id " +
                            "AND ethnicity_id = :ethnicity_id " +
                            "AND action = 'delete' " +
                            "ORDER BY audited DESC LIMIT 1",
                    new MapSqlParameterSource()
                            .addValue("student_id", originalStudentId)
                            .addValue("ethnicity_id", studentEthnicityValues.get("ethnicity_id")));

            assertThat(auditEthnicityValues.remove("id")).isNotNull();
            assertThat(auditEthnicityValues.remove("action")).isEqualTo("delete");
            assertThat(auditEthnicityValues.remove("audited")).isNotNull();
            assertThat(auditEthnicityValues.remove("database_user")).isNotNull();
            assertThat(studentEthnicityValues).isEqualTo(auditEthnicityValues);
        });
    }

}
