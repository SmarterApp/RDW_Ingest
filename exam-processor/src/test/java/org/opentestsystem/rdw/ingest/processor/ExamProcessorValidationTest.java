package org.opentestsystem.rdw.ingest.processor;

import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Test;
import org.springframework.http.MediaType;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.GenericMessage;
import org.springframework.test.context.ActiveProfiles;

import java.io.IOException;
import java.util.Optional;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.common.script.PipelineService;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.ingest.processor.service.StudentExamProcessor;
import org.opentestsystem.rdw.ingest.processor.service.TDSReportProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.script.ConfigurationCompiler;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScriptDefinition;
import org.opentestsystem.rdw.script.PipelineScriptType;
import org.opentestsystem.rdw.script.PropertyResolver;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.impl.DefaultConfigurationCompiler;
import org.opentestsystem.rdw.script.impl.DefaultPipelineFactory;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.opentestsystem.rdw.script.security.AbstractToggleableSecurityManager;
import org.opentestsystem.rdw.script.security.DefaultSandboxPermissions;
import org.opentestsystem.rdw.script.security.DefaultSandboxSecurityManager;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.mockito.AdditionalMatchers.and;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.startsWith;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.PipelineScriptType.Base;
import static org.opentestsystem.rdw.script.PipelineScriptType.Post;
import static org.testng.Assert.fail;

@ActiveProfiles("test")
public class ExamProcessorValidationTest {

    // Sample (and other) data should match (not match) values in specified sample TRT file.
    private static final long importId = 1L;
    private static final String SAMPLE_TRT_TEST_SUBJECT = "MATH";
    private static final String SAMPLE_TRT_TEST_GRADE = "04";
    private static final String OTHER_TEST_SUBJECT = "ELA";
    private static final String OTHER_TEST_GRADE = "11";

    private ExamProcessor processor;

    private ExamineeProcessor examineeProcessor;
    private StudentExamProcessor studentExamProcessor;
    private TDSReportProcessor tdsReportProcessor;

    private AssessmentRepository assessmentRepository;
    private ImportRepository importRepository;
    private SchoolRepository schoolRepository;
    private ArchiveService archiveService;

    private Message message;
    private Assessment assessment;

    @Before
    public void createProcessor() {
        // Set up mocked repos to a good state to be able to ingest the sample TRT
        setReposToSunnyDay();

        final Pipeline pipeline = setupPipeline();
        final PipelineService pipelineService = mock(PipelineService.class);
        when(pipelineService.getPipeline(ExamProcessor.PipelineName)).thenReturn(Optional.of(pipeline));

        archiveService = mock(ArchiveService.class);

        processor = new ExamProcessor(tdsReportProcessor, importRepository, pipelineService, archiveService);
    }

    @Before
    public void createMessage() throws Exception {
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(null);
        accessor.setContent(ImportContent.EXAM.name());
        accessor.setContentType(MediaType.APPLICATION_XML);
        accessor.setImportId(importId);
        accessor.setTenantId("CA");

        final byte[] payload = IOUtils.toByteArray(this.getClass().getResourceAsStream("/TDSReport.iab.2018_AIR_format.xml"));
        message = new GenericMessage<>(payload, accessor.getMessageHeaders());
    }

    @Test
    public void itShouldProcessValidTrtWithNoErrors() {
        // Run the processor, which should now validate the TRT
        processor.process(message);

        verifyZeroInteractions(archiveService); // No archival because no transformation
        verify(importRepository).updateStatusAndMessageById(
                importId,
                ImportStatus.PROCESSED,
                null);
    }

    @Test
    public void itShouldErrorOnSchoolNotFound() {
        // Alter repos so that TRT's school isn't found.
        when(schoolRepository.findIdByNaturalId(any())).thenReturn(null);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.UNKNOWN_SCHOOL),
                startsWith("unable to find a school with natural id") );
    }

    @Test
    public void itShouldErrorOnAssessmentNotFound() {
        // Alter repos so that TRTs test doesn't match an assessment.
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(null);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.UNKNOWN_ASMT),
                startsWith("Unable to find an assessment by natural id") );
    }

    @Test
    public void itShouldErrorOnSubjectMismatch() {
        when(assessment.getSubjectCode()).thenReturn(OTHER_TEST_SUBJECT);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.BAD_DATA),
                contains("exam subject does not match asmt subject") );
    }

    @Test
    public void itShouldErrorOnGradeMismatch() {
        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        final Assessment assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(SAMPLE_TRT_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(OTHER_TEST_GRADE);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.BAD_DATA),
                contains("exam grade does not match asmt grade") );
    }

    @Test
    public void itShouldErrorOnSubjectAndGradeMismatch() {
        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        final Assessment assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(OTHER_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(OTHER_TEST_GRADE);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.BAD_DATA),
                and(
                        contains("exam grade does not match asmt grade"),
                        contains("exam subject does not match asmt subject")));
    }

    private void setReposToSunnyDay() {
        examineeProcessor = mock(ExamineeProcessor.class);
        studentExamProcessor = mock(StudentExamProcessor.class);
        tdsReportProcessor = mock(TDSReportProcessor.class);

        assessmentRepository = mock(AssessmentRepository.class);
        importRepository = mock(ImportRepository.class);
        schoolRepository = mock(SchoolRepository.class);

        assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(SAMPLE_TRT_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(SAMPLE_TRT_TEST_GRADE);

        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);
    }

    private Pipeline setupPipeline() {
        // use a mostly real factory to create a mostly real pipeline
        // the pipeline has just the system post script

        // this won't get called
        final PublishedPipelineRepository repository = mock(PublishedPipelineRepository.class);

        // to avoid interfering with other tests we have to have a custom script source
        final ScriptSource scriptSource = new TestScriptSource();

        // we need a system script property resolver
        final PropertyResolver propertyResolver = new SystemScriptPropertyResolver(
                assessmentRepository,
                null,
                null,
                null,
                schoolRepository,
                null,
                null,
                examineeProcessor,
                studentExamProcessor);

        final ConfigurationCompiler configCompiler = new DefaultConfigurationCompiler();
        final AbstractToggleableSecurityManager securityManager = new DefaultSandboxSecurityManager(new DefaultSandboxPermissions());

        final PipelineFactory factory =
                new DefaultPipelineFactory(repository, configCompiler, propertyResolver, securityManager, scriptSource);

        return factory.getPipeline(ExamProcessor.PipelineName, null);
    }

    public class TestScriptSource implements ScriptSource {
        @Override
        public Optional<PipelineScriptDefinition> getScript(final PipelineScriptType type, final String pipelineCode) {
            if (type == Base) {
                return getScriptFromResource(type, "/scripts/DSLScriptBase.groovy");
            } else if (type == Post) {
                return getScriptFromResource(type, "/scripts/trt_validate.groovy");
            }
            return Optional.empty();
        }

        private Optional<PipelineScriptDefinition> getScriptFromResource(final PipelineScriptType type, final String resourceName) {
            try {
                return Optional.of(PipelineScriptDefinition.builder()
                        .type(type)
                        .body(IOUtils.toString(this.getClass().getResourceAsStream(resourceName), UTF_8))
                        .build());
            } catch (final IOException e) {
                fail(e.getMessage());
            }
            return Optional.empty();
        }
    }

}
