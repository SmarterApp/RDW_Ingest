package org.opentestsystem.rdw.ingest.processor;

import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Test;
import org.springframework.http.MediaType;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.GenericMessage;
import org.springframework.test.context.ActiveProfiles;

import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.ingest.processor.service.StudentExamProcessor;
import org.opentestsystem.rdw.ingest.processor.service.TDSReportProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.script.ConfigurationCompiler;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PropertyResolver;
import org.opentestsystem.rdw.script.ResourceType;
import org.opentestsystem.rdw.script.ScriptCompiler;
import org.opentestsystem.rdw.script.ScriptInfo;
import org.opentestsystem.rdw.script.ScriptPipelineConfiguration;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.VersionedResource;
import org.opentestsystem.rdw.script.impl.DefaultConfigurationCompiler;

import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonList;
import static org.mockito.AdditionalMatchers.and;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.startsWith;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@ActiveProfiles("test")
public class ExamProcessorValidationTest {

    // Sample (and other) data should match (not match) values in specified sample TRT file.
    private static final long IMPORT_ID = 1L;
    private static final String SAMPLE_TRT = "TDSReport.iab.2018_AIR_format.xml";
    private static final String SAMPLE_TRT_TEST_SUBJECT = "MATH";
    private static final String SAMPLE_TRT_TEST_GRADE = "04";
    private static final String OTHER_TEST_SUBJECT = "ELA";
    private static final String OTHER_TEST_GRADE = "11";

    private ExamProcessor processor;

    private ExamineeProcessor examineeProcessor;
    private StudentExamProcessor studentExamProcessor;
    private TDSReportProcessor tdsReportProcessor;

    private AssessmentRepository assessmentRepository;
    private ImportRepository importRepository;
    private SchoolRepository schoolRepository;
    private ArchiveService archiveService;

    private Message message;
    private Assessment assessment;

    @Before
    public void createProcessor() throws Exception {

        // Set up mocked repos to a good state to be able to ingest the sample TRT
        setReposToSunnyDay();

        // Set up a partially mocked pipeline that will still do the actual validations against mocked data sources.
        final PipelineFactory pipelineFactory = setupPipelineFactory();
        archiveService = mock(ArchiveService.class);
        processor = new ExamProcessor(tdsReportProcessor, importRepository, pipelineFactory, archiveService);

        message = buildMessage(SAMPLE_TRT);
    }

    private PipelineFactory setupPipelineFactory() throws Exception {
        final VersionedResource nodeDefinition = VersionedResource.builder()
                .name("test")
                .version("1.0")
                .type(ResourceType.SYSTEM_NODE)
                .build();

        final PipelineDefinition pipelineDefinition = PipelineDefinition.builder()
                .name("pipeline")
                .version("1")
                .rollbackVersion("")
                .nodeDefinitions(singletonList(nodeDefinition))
                .build();

        final ScriptSource scriptSource = mock(ScriptSource.class);
        when(scriptSource.loadPipelineDefinition(any(), any()))
                .thenReturn(pipelineDefinition);

        final String base = loadStringFromResourceFile("/scripts/DSLScriptBase.groovy");
        when(scriptSource.loadScriptBaseClass()).thenReturn(base);

        final ScriptInfo script = loadScriptFromFile("/scripts/trt_validate.groovy", emptyMap());
        when(scriptSource.loadScript(nodeDefinition)).thenReturn(script);

        ScriptPipelineConfiguration config = new ScriptPipelineConfiguration();
        ScriptCompiler scriptCompiler = new ScriptCompiler(config.groovyClassLoader(scriptSource));
        ConfigurationCompiler configurationCompiler = new DefaultConfigurationCompiler();

        final PropertyResolver propertyResolver = new SystemScriptPropertyResolver(
                assessmentRepository,
                null,
                null,
                null,
                schoolRepository,
                null,
                null,
                examineeProcessor,
                studentExamProcessor);

        return config.pipelineFactory(scriptSource,
                scriptCompiler,
                configurationCompiler,
                propertyResolver,
                null);
    }

    @Test
    public void itShouldProcessValidTrtWithNoErrors() {
        // Run the processor, which should now validate the TRT
        processor.process(message);

        verifyZeroInteractions(archiveService); // No archival because no transformation
        verify(importRepository).updateStatusAndMessageById(
                IMPORT_ID,
                ImportStatus.PROCESSED,
                null);
    }

    @Test
    public void itShouldErrorOnSchoolNotFound() {
        // Alter repos so that TRT's school isn't found.
        when(schoolRepository.findIdByNaturalId(any())).thenReturn(null);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository).updateStatusAndMessageById(
                eq(IMPORT_ID),
                eq(ImportStatus.UNKNOWN_SCHOOL),
                startsWith("unable to find a school with natural id") );
    }

    @Test
    public void itShouldErrorOnAssessmentNotFound() {
        // Alter repos so that TRTs test doesn't match an assessment.
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(null);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(IMPORT_ID),
                eq(ImportStatus.UNKNOWN_ASMT),
                startsWith("Unable to find an assessment by natural id") );
    }

    @Test
    public void itShouldErrorOnSubjectMismatch() {
        when(assessment.getSubjectCode()).thenReturn(OTHER_TEST_SUBJECT);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(IMPORT_ID),
                eq(ImportStatus.BAD_DATA),
                contains("exam subject does not match asmt subject") );
    }

    @Test
    public void itShouldErrorOnGradeMismatch() {
        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        final Assessment assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(SAMPLE_TRT_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(OTHER_TEST_GRADE);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(IMPORT_ID),
                eq(ImportStatus.BAD_DATA),
                contains("exam grade does not match asmt grade") );
    }

    @Test
    public void itShouldErrorOnSubjectAndGradeMismatch() {
        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        final Assessment assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(OTHER_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(OTHER_TEST_GRADE);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(IMPORT_ID),
                eq(ImportStatus.BAD_DATA),
                and(
                        contains("exam grade does not match asmt grade"),
                        contains("exam subject does not match asmt subject")));
    }

    private void setReposToSunnyDay() {
        examineeProcessor = mock(ExamineeProcessor.class);
        studentExamProcessor = mock(StudentExamProcessor.class);
        tdsReportProcessor = mock(TDSReportProcessor.class);

        assessmentRepository = mock(AssessmentRepository.class);
        importRepository = mock(ImportRepository.class);
        schoolRepository = mock(SchoolRepository.class);

        assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(SAMPLE_TRT_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(SAMPLE_TRT_TEST_GRADE);

        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);
    }

    private Message buildMessage(final String fileName) throws Exception {
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(null);
        accessor.setContent(ImportContent.EXAM.name());
        accessor.setContentType(MediaType.APPLICATION_XML);
        accessor.setImportId(IMPORT_ID);
        accessor.setTenantId("CA");

        final byte[] payload = loadFromResourceFile("/" + fileName);
        return new GenericMessage<>(payload, accessor.getMessageHeaders());
    }

    private byte [] loadFromResourceFile(final String name) throws Exception {
        final InputStream is = this.getClass().getResourceAsStream(name);
        return IOUtils.toByteArray(is);
    }

    private String loadStringFromResourceFile(final String name) throws Exception {
        return new String(loadFromResourceFile(name), StandardCharsets.UTF_8);
    }

    private ScriptInfo loadScriptFromFile(final String filePath, final Map<String,String> properties)  throws Exception {
        final String scriptCode = loadStringFromResourceFile(filePath);
        return new ScriptInfo(scriptCode, properties);
    }
}
