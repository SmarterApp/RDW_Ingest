package org.opentestsystem.rdw.ingest.processor;

import org.apache.commons.io.IOUtils;
import org.junit.Before;
import org.junit.Test;
import org.springframework.http.MediaType;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.GenericMessage;

import java.time.Instant;
import java.util.Optional;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.common.model.ImportContent;
import org.opentestsystem.rdw.common.model.ImportStatus;
import org.opentestsystem.rdw.ingest.common.repository.ImportRepository;
import org.opentestsystem.rdw.ingest.common.script.PipelineService;
import org.opentestsystem.rdw.ingest.processor.model.Assessment;
import org.opentestsystem.rdw.ingest.processor.model.Exam;
import org.opentestsystem.rdw.ingest.processor.repository.AssessmentRepository;
import org.opentestsystem.rdw.ingest.processor.repository.SchoolRepository;
import org.opentestsystem.rdw.ingest.processor.service.ExamineeProcessor;
import org.opentestsystem.rdw.ingest.processor.service.StudentExamProcessor;
import org.opentestsystem.rdw.ingest.processor.service.TDSReportProcessor;
import org.opentestsystem.rdw.messaging.RdwMessageHeaderAccessor;
import org.opentestsystem.rdw.script.ConfigurationCompiler;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScriptDefinition;
import org.opentestsystem.rdw.script.PropertyResolver;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.impl.DefaultConfigurationCompiler;
import org.opentestsystem.rdw.script.impl.DefaultPipelineFactory;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.mockito.AdditionalMatchers.and;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.startsWith;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.PipelineScriptType.Base;
import static org.opentestsystem.rdw.script.PipelineScriptType.Post;
import static org.opentestsystem.rdw.script.PipelineScriptType.Pre;

public class ExamProcessorValidationTest {

    // Sample (and other) data should match (not match) values in specified sample TRT file.
    private static final long importId = 1L;
    private static final String SAMPLE_TRT_TEST_SUBJECT = "MATH";
    private static final String SAMPLE_TRT_TEST_GRADE = "04";
    private static final String OTHER_TEST_SUBJECT = "ELA";
    private static final String OTHER_TEST_GRADE = "11";

    private ExamProcessor processor;

    private ExamineeProcessor examineeProcessor;
    private StudentExamProcessor studentExamProcessor;
    private TDSReportProcessor tdsReportProcessor;

    private AssessmentRepository assessmentRepository;
    private ImportRepository importRepository;
    private SchoolRepository schoolRepository;
    private ArchiveService archiveService;

    private Message message;
    private Assessment assessment;

    @Before
    public void createProcessor() throws Exception {
        // Set up mocked repos to a good state to be able to ingest the sample TRT
        setReposToSunnyDay();

        // Set up a partially mocked pipeline that will still do the actual XML transformations.
        final Pipeline pipeline = setupPipeline();
        final PipelineService pipelineService = mock(PipelineService.class);
        when(pipelineService.getPipeline(ExamProcessor.pipelineType.code())).thenReturn(Optional.of(pipeline));

        // no-op everything else since we're focusing on the transformation
        tdsReportProcessor = mock(TDSReportProcessor.class);
        importRepository = mock(ImportRepository.class);
        archiveService = mock(ArchiveService.class);

        processor = new ExamProcessor(tdsReportProcessor, importRepository, pipelineService, archiveService);
    }

    @Before
    public void createMessage() throws Exception {
        // make a nice well-formed message
        final RdwMessageHeaderAccessor accessor = RdwMessageHeaderAccessor.wrap(null);
        accessor.setContent(ImportContent.EXAM.name());
        accessor.setContentType(MediaType.APPLICATION_XML);
        accessor.setImportId(importId);
        accessor.setTenantId("CA");

        final byte[] payload = loadBytesFromResourceFile("/TDSReport.iab.2018_AIR_format.xml");

        message = new GenericMessage<>(payload, accessor.getMessageHeaders());
    }

    private Pipeline setupPipeline() throws Exception {
        // use a mostly real factory to create a mostly real pipeline
        final PipelineDefinition publishedPipeline = PipelineDefinition.builder()
                .pipelineCode("test")
                .published(Instant.now())
                .publishedBy("publisher")
                .version(null)
                .build();

        final PipelineScriptDefinition baseScript = PipelineScriptDefinition.builder()
                .type(Base)
                .body(loadStringFromResourceFile("/scripts/DSLScriptBase.groovy"))
                .build();

        final PipelineScriptDefinition postScript = PipelineScriptDefinition.builder()
                .type(Post)
                .body(loadStringFromResourceFile("/scripts/pipelines/exam/post-process.groovy"))
                .build();

        final ScriptSource scriptSource = mock(ScriptSource.class);
        when(scriptSource.getScript(eq(Base), anyString())).thenReturn(Optional.of(baseScript));
        when(scriptSource.getScript(eq(Pre), anyString())).thenReturn(Optional.empty());
        when(scriptSource.getScript(eq(Post), anyString())).thenReturn(Optional.of(postScript));

        final PublishedPipelineRepository repository = mock(PublishedPipelineRepository.class);
        when(repository.findByCodeAndVersion(anyString(), anyString())).thenReturn(publishedPipeline);

        final PropertyResolver propertyResolver = new SystemScriptPropertyResolver(
                assessmentRepository,
                null,
                null,
                null,
                schoolRepository,
                null,
                null,
                examineeProcessor,
                studentExamProcessor);

        final ConfigurationCompiler configurationCompiler = new DefaultConfigurationCompiler();


        final PipelineFactory factory =
                new DefaultPipelineFactory(repository, configurationCompiler, propertyResolver, null, scriptSource);

        return factory.getPipeline(ExamProcessor.pipelineType.code(), "1");
    }

    @Test
    public void itShouldProcessValidTrtWithNoErrors() {
        // Run the processor, which should now validate the TRT
        processor.process(message);

        verifyZeroInteractions(archiveService); // No archival because no transformation
        verify(importRepository).updateStatusAndMessageById(
                importId,
                ImportStatus.PROCESSED,
                null);
    }

    @Test
    public void itShouldErrorOnSchoolNotFound() {
        // Alter repos so that TRT's school isn't found.
        when(schoolRepository.findIdByNaturalId(any())).thenReturn(null);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.UNKNOWN_SCHOOL),
                startsWith("unable to find a school with natural id"));
    }

    @Test
    public void itShouldErrorOnAssessmentNotFound() {
        // Alter repos so that TRTs test doesn't match an assessment.
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(null);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.UNKNOWN_ASMT),
                startsWith("Unable to find an assessment by natural id"));
    }

    @Test
    public void itShouldErrorOnSubjectMismatch() {
        when(assessment.getSubjectCode()).thenReturn(OTHER_TEST_SUBJECT);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.BAD_DATA),
                contains("exam subject does not match asmt subject"));
    }

    @Test
    public void itShouldErrorOnGradeMismatch() {
        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        final Assessment assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(SAMPLE_TRT_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(OTHER_TEST_GRADE);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.BAD_DATA),
                contains("exam grade does not match asmt grade"));
    }

    @Test
    public void itShouldErrorOnSubjectAndGradeMismatch() {
        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        final Assessment assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(OTHER_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(OTHER_TEST_GRADE);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);

        processor.process(message);
        verifyZeroInteractions(archiveService); // No archival on error
        verify(importRepository, times(1)).updateStatusAndMessageById(
                eq(importId),
                eq(ImportStatus.BAD_DATA),
                and(
                        contains("exam grade does not match asmt grade"),
                        contains("exam subject does not match asmt subject")));
    }

    private void setReposToSunnyDay() {
        examineeProcessor = mock(ExamineeProcessor.class);
        studentExamProcessor = mock(StudentExamProcessor.class);
        tdsReportProcessor = mock(TDSReportProcessor.class);

        assessmentRepository = mock(AssessmentRepository.class);
        importRepository = mock(ImportRepository.class);
        schoolRepository = mock(SchoolRepository.class);

        assessment = mock(Assessment.class);
        when(assessment.getNaturalId()).thenReturn("Mock-Natural-Id");
        when(assessment.getSubjectCode()).thenReturn(SAMPLE_TRT_TEST_SUBJECT);
        when(assessment.getGradeCode()).thenReturn(SAMPLE_TRT_TEST_GRADE);

        final Exam exam = mock(Exam.class);
        when(exam.getSchoolYear()).thenReturn(2018);

        when(schoolRepository.findIdByNaturalId(any())).thenReturn(1);
        when(assessmentRepository.findOneByNaturalId(any())).thenReturn(assessment);
        when(studentExamProcessor.parseExam(any(), anyInt(), any())).thenReturn(exam);
    }

    private byte [] loadBytesFromResourceFile(final String name) throws Exception {
        return IOUtils.toByteArray(this.getClass().getResourceAsStream(name));
    }

    private String loadStringFromResourceFile(final String name) throws Exception {
        return IOUtils.toString(this.getClass().getResourceAsStream(name), UTF_8);
    }
}
