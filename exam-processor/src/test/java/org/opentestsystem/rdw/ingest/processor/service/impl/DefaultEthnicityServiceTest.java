package org.opentestsystem.rdw.ingest.processor.service.impl;


import config.DataElementsConfiguration;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.rdw.common.model.trt.Examinee;
import org.opentestsystem.rdw.common.model.trt.Examinee.ExamineeAttribute;
import org.opentestsystem.rdw.ingest.common.util.DataElementErrorCollector;
import org.opentestsystem.rdw.ingest.processor.model.DataElement;
import org.opentestsystem.rdw.ingest.processor.repository.EthnicityRepository;
import org.opentestsystem.rdw.ingest.processor.service.EthnicityService;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Sets.newHashSet;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class DefaultEthnicityServiceTest {

    private EthnicityService service;
    private Examinee examinee;
    private DataElementErrorCollector elementErrorCollector;
    private ExamineeAttribute attributeAsian;
    private DataElementsConfiguration configuration;


    @Before
    public void setUp() {
        final EthnicityRepository repository = mock(EthnicityRepository.class);
        when(repository.findAllCodes()).thenReturn(newArrayList(DataElement.Asian.name(), DataElement.White.name(), DataElement.Filipino.name()));

        configuration = mock(DataElementsConfiguration.class);
        when(configuration.getOptionalDataElements()).thenReturn(newHashSet(DataElement.Filipino));
        service = new DefaultEthnicityService(repository, configuration);

        examinee = mock(Examinee.class);
        final ExamineeAttribute attributeA = mock(ExamineeAttribute.class);
        when(examinee.getBestAttribute(DataElement.Asian.name())).thenReturn(attributeA);
        when(attributeA.getValue()).thenReturn("Y");

        final ExamineeAttribute attributeB = mock(ExamineeAttribute.class);
        when(examinee.getBestAttribute(DataElement.White.name())).thenReturn(attributeB);
        when(attributeB.getValue()).thenReturn("N");

        attributeAsian = mock(ExamineeAttribute.class);
        when(examinee.getBestAttribute(DataElement.Filipino.name())).thenReturn(attributeAsian);
        when(attributeAsian.getValue()).thenReturn("Y");

        when(repository.findIdByCode(DataElement.Asian.name())).thenReturn(10);
        when(repository.findIdByCode(DataElement.Filipino.name())).thenReturn(20);

        elementErrorCollector = new DataElementErrorCollector();
    }

    @Test
    public void itShouldReturnEthnicityIdsList() {
        service.getEthnicity(examinee, elementErrorCollector);
        assertThat(service.getEthnicity(examinee, elementErrorCollector)).containsExactly(10, 20);
        assertThat(elementErrorCollector.isEmpty()).isTrue();
    }

    @Test
    public void itShouldIgnoreUnsupportedEthnicity() {
        when(examinee.getBestAttribute(DataElement.Filipino.name())).thenReturn(null);

        service.getEthnicity(examinee, elementErrorCollector);
        assertThat(service.getEthnicity(examinee, elementErrorCollector)).containsExactly(10);
        assertThat(elementErrorCollector.isEmpty()).isTrue();
    }

    @Test
    public void itShouldReturnErrors() {
        when(attributeAsian.getValue()).thenReturn("ABC");

        service.getEthnicity(examinee, elementErrorCollector);
        assertThat(service.getEthnicity(examinee, elementErrorCollector)).containsExactly(10);
        assertThat(elementErrorCollector.isEmpty()).isFalse();
    }
}